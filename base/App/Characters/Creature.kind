type App.Characters.Creature { 
  new(
    player: Maybe<String>
    dna: App.Characters.Custom
    attributes: App.Characters.Attributes
    status: List<App.Characters.Status>
  )
}

type App.Characters.Custom {
  new(
    alteration: String //TODO
    attributes: App.Characters.Attributes
  )
}

type App.Characters.Attributes {
  new(
    hp:I32
    energy:I32
    damage:I32
    corruption: I32
  )
}

type App.Characters.Status {
  stun(duration: I32)
}

//====================================
type App.Characters.Result <A: Type> {
  new(
    value: A,
    center: Pair<U32, U32>
    //cast_data: Pair<Char,String>
    //board: App.KL.Game.Board,
    //indicators: Hexagonal.Axial.Map(App.KL.Game.Indicator)
    energy_cost: I32 
    //cemetery: App.KL.Game.Cemetery
    description: String
    //player_data: App.KL.Game.PlayerData
  )
}


App.Characters.modified_creature(
  creature: App.Characters.Creature
  customization: App.Characters.Custom
): App.Characters.Attributes
  let hp = creature@attributes@hp + customization@attributes@hp
  let energy = creature@attributes@energy + customization@attributes@energy
  let damage = creature@attributes@damage + customization@attributes@damage
  let corruption = creature@attributes@corruption + customization@attributes@corruption
  App.Characters.Attributes.new(hp, energy, damage, corruption)


App.Characters.Effect(A: Type): Type
  ((center: Pair<U32, U32>) ->
   (targets: List<Pair<U32, U32>>) ->
   (cast_data: Pair<Char,String>) ->
   (board: String) ->
   App.Characters.Result(A))


