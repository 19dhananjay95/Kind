mul_expan(a: Nat, b: Nat): (Nat.add(b, Nat.mul(a,b))) == Nat.mul(Nat.succ(a),b)
    refl


Nat.lte.mul.left(
  a: Nat
  b: Nat
  c: Nat
  Hyp: Equal<Bool>(Nat.lte(a, b), Bool.true)
): Equal<Bool>(Nat.lte(Nat.mul(c, a), Nat.mul(c, b)), Bool.true)
  case c {
    zero: 
        let aux = Nat.Order.refl(0)
        (aux :: rewrite X in (Equal<Bool>(Nat.lte(X, 0), Bool.true)) with mirror(Nat.mul.zero_left(a)))
             :: rewrite X in (Equal<Bool>(Nat.lte(Nat.mul(0,a), X), Bool.true)) with mirror(Nat.mul.zero_left(b))
    succ:
      let ind = Nat.Order.mul.left(a, b, c.pred, Hyp)
      let qed = Nat.Order.add.combine(a, b, Nat.mul(c.pred,a),Nat.mul(c.pred,b), Hyp, ind)
      let qed2 = qed :: rewrite X in (Nat.lte(X,Nat.add(b,Nat.mul(c.pred,b))) == Bool.true) with mul_expan(c.pred,a)
      let qed3 = qed2 :: rewrite X in (Nat.lte(Nat.mul(Nat.succ(c.pred),a),X) == Bool.true) with mul_expan(c.pred,b)
      qed3
  }: Equal<Bool>(Nat.lte(Nat.mul(c, a), Nat.mul(c, b)), true)
