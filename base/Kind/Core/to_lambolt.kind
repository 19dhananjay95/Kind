// Converts a Kind.Core term to Lambolt
Kind.Core.to_lambolt(term: Kind.Core.Term): String
  let {n_defs, term} = Kind.Core.to_lambolt.aux(term, {1, "(Typ) = 0\n"}, {})
  let {n, defs} = n_defs
  defs|term

Kind.Core.to_lambolt.get_idx: Kind.Core.to_lambolt.Builder(Nat)
  (st, ids)
    open st
    {{st.n + 1, st.ids} :: Kind.Core.to_lambolt.Builder.aux, st.n}

Kind.Core.to_lambolt.add_binder<A: Type>(
  b: Kind.Core.to_lambolt.Builder(A)
  id: String
): Kind.Core.to_lambolt.Builder(A)
  (st, ids)
    b(st, ids{id} <- unit)

Kind.Core.to_lambolt.test_binder(id: String): Kind.Core.to_lambolt.Builder(Bool)
  (st, ids)
    {st, Maybe.is_some!(ids{id})}

//Kind.Core.to_lambolt.Builder.show(
//  st: Kind.Core.to_lambolt.Builder.aux
//): String
//  open st
//  "{\n"
//  |"  "|Nat.show(st.n)|",\n"
//  |"  "|st.ids|",\n"
//  |"  "|Map.show!((u) "*", st.local_binders)|"\n"
//  |"}"
//
// TODO add indentation level
Kind.Core.to_lambolt.aux(
  term: Kind.Core.Term
): Kind.Core.to_lambolt.Builder(String)
  case term {
    var:
      Kind.Core.to_lambolt.Builder {
        return term.name
      }
    ref:
      Kind.Core.to_lambolt.Builder {
        get cond = Kind.Core.to_lambolt.test_binder(term.name)
        if cond then
          Kind.Core.to_lambolt.Builder {
            return "(Ref ("|String.capitalize(term.name)|"))"
          }
        else
          Kind.Core.to_lambolt.Builder {
            return term.name
          }
      }
    typ:
      Kind.Core.to_lambolt.Builder {
        return "(Typ)"
      }
    all: 
      Kind.Core.to_lambolt.Builder {
        let eras = if term.eras then "(True)" else "(False)"
        get xtyp_code = Kind.Core.to_lambolt.aux(term.xtyp)
        get body_code = Kind.Core.to_lambolt.add_binder!(
          Kind.Core.to_lambolt.add_binder!(
            Kind.Core.to_lambolt.aux(
              term.body(Kind.Core.Term.ref(term.self), Kind.Core.Term.ref(term.name))
            )
            term.self
          )
          term.name
        )
        get self_n = Kind.Core.to_lambolt.get_idx
        let let_self =
          case term.self {
              nil:
                ""
              cons:
                "\nlet "|term.self|" = "|Nat.show(self_n)
          }
        get name_n = Kind.Core.to_lambolt.get_idx
        let let_name =
          case term.name {
            nil:
              ""
            cons:
              "\nlet "|term.name|" = "|Nat.show(name_n)
          }
        return 
          let_self
          |let_name|"\n"
          |"(All "|eras|" "|term.self|" "|term.name|" "|xtyp_code|" 位"|term.self|" 位"|term.name|" "|body_code|")"
      }
    lam:
      Kind.Core.to_lambolt.Builder {
        let new_body = term.body(Kind.Core.Term.ref(term.name))
        get lam_body = Kind.Core.to_lambolt.add_binder!(Kind.Core.to_lambolt.aux(new_body), term.name)
        return "位"|term.name|" "|lam_body
      }
    app:
      Kind.Core.to_lambolt.Builder {
        get fun = Kind.Core.to_lambolt.aux(term.func)
        get arg = Kind.Core.to_lambolt.aux(term.argm)
        return "(App "|fun|" "|arg|")"
      }
    let:
      Kind.Core.to_lambolt.Builder {
        get let_expr = Kind.Core.to_lambolt.aux(term.expr)
        get let_body = Kind.Core.to_lambolt.add_binder!(
          Kind.Core.to_lambolt.aux(term.body(Kind.Core.Term.ref(term.name)))
          term.name
        )
        get n = Kind.Core.to_lambolt.get_idx
        return "let "|term.name|" = "|Nat.show(n)|"\n(Let "|term.name|" "|let_expr|" 位"|term.name|" "|let_body|")"
      }
    ann:
      Kind.Core.to_lambolt.Builder {
        get expr = Kind.Core.to_lambolt.aux(term.expr)
        get type = Kind.Core.to_lambolt.aux(term.type)
        return "(Ann "|expr|" "|type|")"
      }
  }
//  log("============================")
//  log("state:")
//  log(Kind.Core.to_lambolt.Builder.show(st))
//  log("term:")
//  log(Kind.Core.show(Kind.Core.to_kind(term)))
//  let {n, ids, local_binders} = st
