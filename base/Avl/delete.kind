Avl.delete<K: Type, V: Type>(
  cmp : K -> K -> Cmp
  key: K, 
  map: Avl<K, V>, 
) : Avl<K, V>
  case map {
    tip: Avl.tip!!
    bin: 
      case cmp(key, map.key) {
        // when recursion comes back rebalance the node
        ltn: Avl.balance!!(map.key, map.val, Avl.delete!!(cmp, key, map.left), map.right)
        // when recursion comes back rebalance the node
        gtn: Avl.balance!!(map.key, map.val, map.left, Avl.delete!!(cmp, key, map.right))
        eql: 
          // get min value from right subtree
          let min = Avl.min!!(map.right)
          case min {
            //no nodes on right, return left; if left is empty then will return empty anyway
            none: map.left
            some:
                open min.value
                let right_without_min = Avl.delete_min!!(map.right) // deletes right's min, rebalancing this subtree
                Avl.balance!!(min.value.fst, min.value.snd, map.left, right_without_min) // rebalance his own node with the new right tree
          }!
      }!
  }!