Kind.Term.check(
  term: Kind.Term,
  type: Maybe<Kind.Term>,
  defs: Kind.Defs,
  ctx: Kind.Context,
  path: Kind.MPath,
  orig: Maybe<Pair<Nat,Nat>>,
): Kind.Check<Kind.Term>
  do Kind.Check {
    get infr = case term {
      ref: case Kind.Map.get!(term.name, defs) as got {
        none: Kind.Check.result!(type, [Kind.Error.undefined_reference(orig, term.name)]),
        some: case got.value {
          new:
            let ref_name = got.value.name;
            let ref_type = got.value.type;
            let ref_term = got.value.term;
            let ref_stat = got.value.stat;
            case ref_stat {
              init: Kind.Check.result!(Maybe.some!(ref_type), [Kind.Error.waiting(ref_name)]),
              wait: Kind.Check.result!(Maybe.some!(ref_type), []),
              done: Kind.Check.result!(Maybe.some!(ref_type), []),
              fail: Kind.Check.result!(Maybe.some!(ref_type), [Kind.Error.indirect(ref_name)]),
            },
        }
      },
      var: case List.at_last!(term.indx, ctx) as got {
        none: Kind.Check.result!(type, [Kind.Error.undefined_reference(orig, term.name)]),
        some: do Kind.Check { return case got.value { new: got.value.snd }; },
      },
      typ: do Kind.Check {
        return Kind.Term.typ;
      },
      all: do Kind.Check {
        let ctx_size = List.length!(ctx);
        let self_var = Kind.Term.var(term.self, ctx_size);
        let body_var = Kind.Term.var(term.name, Nat.succ(ctx_size));
        let body_ctx = List.cons!({term.name,term.xtyp}, List.cons!({term.self,term}, ctx));
        Kind.Term.check(term.xtyp, Maybe.some!(Kind.Term.typ), defs, ctx, Kind.MPath.o(path), orig);
        Kind.Term.check(term.body(self_var,body_var), Maybe.some!(Kind.Term.typ), defs, body_ctx, Kind.MPath.i(path), orig);
        return Kind.Term.typ;
      },
      lam: case type {
        none: do Kind.Check {
          //let lam_arit = Kind.Term.arity(term);
          //let lam_type = Nat.for!(Kind.Term.hol(Bits.e),0,lam_arit,(i,t) 
            //Kind.Term.all(Bool.false, "", "", Kind.Term.hol(Bits.e), (s,x) t));
          let lam_type = Kind.Term.hol(Bits.e);
          let lam_term = Kind.Term.ann(Bool.false, term, lam_type);
          Kind.Check.result!(type, [Kind.Error.patch(Kind.MPath.to_bits(path),lam_term)]);
          //Kind.Check.result!(type, [Kind.Error.cant_infer(orig, term, ctx)]);
        },
        some: do Kind.Check {
          let typv = Kind.Term.reduce(type.value, defs);
          case typv {
            all: do Kind.Check {
              let ctx_size = List.length!(ctx);
              let self_var = term;
              let body_var = Kind.Term.var(term.name, ctx_size);
              let body_typ = typv.body(self_var, body_var);
              let body_ctx = List.cons!({term.name,typv.xtyp}, ctx);
              Kind.Term.check(term.body(body_var), Maybe.some!(body_typ), defs, body_ctx, Kind.MPath.o(path), orig);
              return type.value;
            },
            //hol: do Kind.Check {
              //let lam_type = Kind.Term.all(Bool.false, "", "", Kind.Term.hol(Bits.e), (s,x) Kind.Term.hol(Bits.e));
              //let lam_term = Kind.Term.ann(Bool.false, term, lam_type);
              //Kind.Check.result!(type, [Kind.Error.patch(Kind.MPath.to_bits(path),lam_term)]);
            //},
            _: do Kind.Check {
              let expected = Either.left!!("function");
              let detected = Either.right!!(type.value);
              Kind.Check.result!(type, [Kind.Error.type_mismatch(orig, expected, detected, ctx)]);
            }
          };
        }
      },
      app: do Kind.Check {
        get func_typ = Kind.Term.check(term.func, Maybe.none!, defs, ctx, Kind.MPath.o(path), orig);
        let func_typ = Kind.Term.reduce(func_typ, defs);
        case func_typ {
          all: do Kind.Check {
            Kind.Term.check(term.argm, Maybe.some!(func_typ.xtyp), defs, ctx, Kind.MPath.i(path), orig);
            return func_typ.body(term.func, term.argm);
          },
          _: do Kind.Check {
            let expected = Either.left!!("function");
            let detected = Either.right!!(func_typ);
            let orig = case term.func { ori: some(term.func.orig) } default orig
            Kind.Check.result!(type, [Kind.Error.type_mismatch(orig, expected, detected, ctx)]);
          },
        };
      },
      ann:
        if term.done then do Kind.Check {
          return term.type;
        } else do Kind.Check {
          Kind.Term.check(term.term, Maybe.some!(term.type), defs, ctx, Kind.MPath.o(path), orig);
          Kind.Term.check(term.type, Maybe.some!(Kind.Term.typ), defs, ctx, Kind.MPath.i(path), orig);
          return term.type;
        },
      let: do Kind.Check {
        let ctx_size = List.length!(ctx);
        get expr_typ = Kind.Term.check(term.expr, Maybe.none!, defs, ctx, Kind.MPath.o(path), orig);
        let body_val = term.body(Kind.Term.var(term.name, ctx_size));
        let body_ctx = List.cons!({term.name, expr_typ}, ctx);
        get body_typ = Kind.Term.check(body_val, type, defs, body_ctx, Kind.MPath.i(path), orig);
        return body_typ;
      },
      def: do Kind.Check {
        let ctx_size = List.length!(ctx);
        get expr_typ = Kind.Term.check(term.expr, Maybe.none!, defs, ctx, Kind.MPath.o(path), orig);
        let body_val = term.body(Kind.Term.ann(Bool.true, term.expr, expr_typ));
        let body_ctx = List.cons!({term.name, expr_typ}, ctx);
        get body_typ = Kind.Term.check(body_val, type, defs, body_ctx, Kind.MPath.i(path), orig);
        return body_typ;
        //Kind.Term.check(term.body(term.expr), type, defs, ctx, path, orig);
      },
      nat: do Kind.Check {
        return Kind.Term.ref("Nat");
      },
      chr: do Kind.Check {
        return Kind.Term.ref("Char");
      },
      str: do Kind.Check {
        return Kind.Term.ref("String");
      },
      cse: do Kind.Check {
        let expr = term.expr;
        get etyp = Kind.Term.check(expr, Maybe.none!, defs, ctx, Kind.MPath.o(path), orig);
        get wyth = Kind.Term.check.infer_types_of_with(term.with, defs, ctx, path, orig)
        let dsug = Kind.Term.check.expand.cse(term.expr, term.name, wyth, term.cses, term.moti, etyp, type, defs, ctx)
        case dsug {
          none: Kind.Check.result!(type, [Kind.Error.cant_infer(orig, term, ctx)]),
          some: Kind.Check.result!(type, [Kind.Error.patch(Kind.MPath.to_bits(path),dsug.value)]),
        };
      },
      new: do Kind.Check {
        let dsug = Kind.Term.check.expand.new(term.args, type, defs)
        case dsug {
          none: Kind.Check.result!(type, [Kind.Error.cant_infer(orig, term, ctx)])
          some: Kind.Check.result!(type, [Kind.Error.patch(Kind.MPath.to_bits(path),dsug.value)])
        }
      },
      get: do Kind.Check {
        let expr = term.expr;
        get etyp = Kind.Term.check(expr, Maybe.none!, defs, ctx, Kind.MPath.o(path), orig);
        let dsug = Kind.Term.check.expand.get(term.expr, term.fkey, etyp, defs)
        case dsug {
          none: Kind.Check.result!(type, [Kind.Error.cant_infer(orig, term, ctx)])
          some: Kind.Check.result!(type, [Kind.Error.patch(Kind.MPath.to_bits(path),dsug.value)])
        }
      },
      set: do Kind.Check {
        let expr = term.expr;
        get etyp = Kind.Term.check(expr, Maybe.none!, defs, ctx, Kind.MPath.o(path), orig);
        let dsug = Kind.Term.check.expand.set(term.expr, term.fkey, term.fval, etyp, defs)
        case dsug {
          none: Kind.Check.result!(type, [Kind.Error.cant_infer(orig, term, ctx)])
          some: Kind.Check.result!(type, [Kind.Error.patch(Kind.MPath.to_bits(path),dsug.value)])
        }
      },
      gol: do Kind.Check {
        Kind.Check.result!(type, [
          Kind.Error.show_goal(term.name, term.dref, term.verb, type, ctx)
        ]);
      },
      hol: do Kind.Check {
        Kind.Check.result!(type, []);
      },
      ori: do Kind.Check {
        Kind.Term.check(term.expr, type, defs, ctx, path, Maybe.some!(term.orig));
      },
    };
    case type {
      none:
        Kind.Check.result!(Maybe.some!(infr), []),
      some: do Kind.Check {
        get eqls = Kind.Term.equal.go(type.value, infr, defs, List.length!(ctx), BitsSet.mut.new(unit));
        if eqls then do Kind.Check {
          return type.value;
        } else do Kind.Check {
          Kind.Check.result!(type, [
            Kind.Error.type_mismatch(
              orig,
              Either.right!!(type.value),
              Either.right!!(infr),
              ctx)
          ]);
        }
      }
    };
  }

// Expands `{a,b,c}` into `Foo.new(a,b,c)`
Kind.Term.check.expand.new(
  args: List(Kind.Term)
  type: Maybe(Kind.Term)
  defs: Kind.Defs
): Maybe<Kind.Term>
  let got = case type {
    some: case Kind.Term.reduce(type.value, defs) as type {
      all: case Kind.Term.reduce(type.body(Kind.Term.typ,Kind.Term.typ), defs) as ctor {
        all: 
          let tnam = String.slice(0, Nat.sub(String.length(type.self),5), type.self)
          let term = Kind.Term.ref(tnam | "." | ctor.name)
          let pars = Kind.Term.check.expand.set.count_params(type.xtyp)
          let term = for i from 0 to pars: Kind.Term.app(term, Kind.Term.hol(Bits.e))
          let term = for arg in args: Kind.Term.app(term, arg)
          some(term)
      } default none
    } default none
  } default none
  case got {
    none: Kind.Term.check.expand.new.pair(args, type, defs)
    some: some(got.value)
  }

Kind.Term.check.expand.new.pair(
  args: List(Kind.Term)
  type: Maybe(Kind.Term)
  defs: Kind.Defs
): Maybe<Kind.Term>
  // TODO: make Triple, Quadruple, etc.
  if Nat.eql(List.length!(args), 2) then
    let term = Kind.Term.ref("Pair.new")
    let term = Kind.Term.app(term, Kind.Term.hol(Bits.e))
    let term = Kind.Term.app(term, Kind.Term.hol(Bits.e))
    let term = Kind.Term.app(term, args[0] <> Kind.Term.ref("pair_fst"))
    let term = Kind.Term.app(term, args[1] <> Kind.Term.ref("pair_snd"))
    some(term)
  else
    none

// Expands `term@a` into `term(() _)((a) (b) (c) a)
Kind.Term.check.expand.get(
  expr: Kind.Term
  fkey: String
  etyp: Kind.Term
  defs: Kind.Defs
): Maybe<Kind.Term>
  case Kind.Term.reduce(etyp, defs) as etyp {
    all: case Kind.term.reduce(etyp.body(Kind.Term.typ,Kind.Term.typ), defs) as ctor {
      all: 
        let term = Kind.Term.app(expr, Kind.Term.lam("", () Kind.Term.hol(Bits.e)))
        let rett = Kind.Term.ref(fkey|"_field")
        let sele = Kind.Term.check.expand.get.selector(fkey, ctor.xtyp, defs, rett)
        some(Kind.Term.app(term, sele))
    } default none
  } default none

Kind.Term.check.expand.get.selector(
  fkey: String
  ctor: Kind.Term
  defs: Kind.Defs
  rett: Kind.Term
): Kind.Term
  case Kind.Term.reduce(ctor, defs) as ctor {
    all: Kind.Term.lam(ctor.name, (x)
      let body = ctor.body(Kind.Term.typ, Kind.Term.typ)
      let rett = if String.eql(ctor.name, fkey) then x else rett
      Kind.Term.check.expand.get.selector(fkey, body, defs, rett))
  } default rett

// Expands `term@a <- val` into `term(() _)((a) (b) (c) Foo.new(val,b,c))`
Kind.Term.check.expand.set(
  expr: Kind.Term
  fkey: String
  fval: Kind.Term
  etyp: Kind.Term
  defs: Kind.Defs
): Maybe<Kind.Term>
  case Kind.Term.reduce(etyp, defs) as etyp {
    all: case Kind.term.reduce(etyp.body(Kind.Term.typ,Kind.Term.typ), defs) as ctor {
      all: 
        let term = Kind.Term.app(expr, Kind.Term.lam("", () Kind.Term.hol(Bits.e)))
        let tnam = String.slice(0, Nat.sub(String.length(etyp.self),5), etyp.self)
        let rett = Kind.Term.ref(tnam | "." | ctor.name)
        let pars = Kind.Term.check.expand.set.count_params(etyp.xtyp)
        let rett = for i from 0 to pars: Kind.Term.app(rett, Kind.Term.hol(Bits.e))
        let sele = Kind.Term.check.expand.set.selector(fkey, fval, ctor.xtyp, defs, rett)
        some(Kind.Term.app(term, sele))
    } default none
  } default none

Kind.Term.check.expand.set.selector(
  fkey: String
  fval: Kind.Term
  ctor: Kind.Term
  defs: Kind.Defs
  rett: Kind.Term
): Kind.Term
  case Kind.Term.reduce(ctor, defs) as ctor {
    all: Kind.Term.lam(ctor.name, (x)
      let body = ctor.body(Kind.Term.typ, Kind.Term.typ)
      let rett = Kind.Term.app(rett, if String.eql(ctor.name, fkey) then fval else x)
      Kind.Term.check.expand.set.selector(fkey, fval, body, defs, rett))
  } default rett
// foo(() _)((a) (b) (c) Foo.new(a)(b)(c))

Kind.Term.check.expand.set.count_params(xtyp: Kind.Term): Nat
  let {bnds,body} = Kind.Term.get_bnds(xtyp, 0) 
  let {func,args} = Kind.Term.get_args(Pair.snd!!(List.last!(bnds) <> {"",Kind.Term.typ}))
  let indexs = Nat.pred(List.length!(bnds))
  let params = Nat.sub(List.length!(args), indexs)
  params
  
// Infers the type of the variables on the 'with' field of Kind.Term.cse
Kind.Term.check.infer_types_of_with(
  vars: List<Kind.Ann>, 
  defs: Kind.Defs,
  ctx: Kind.Context,
  path: Kind.MPath,
  orig: Maybe<Pair<Nat,Nat>>,
): Kind.Check<List<Kind.Ann>>
  case vars {
    nil: do Kind.Check {
      return []
    }
    cons: 
      open vars.head
      do Kind.Check {
        get type = case vars.head.type {
          none: do Kind.Check { 
            get infer = Kind.Term.check(vars.head.term, none, defs, ctx, path, orig)
            return some(infer)
          }
          some: do Kind.Check {
            return some(vars.head.type.value)
          }
        }
        get rest = Kind.Term.check.infer_types_of_with(vars.tail, defs, ctx, path, orig)
        return Kind.Ann.new(vars.head.name, vars.head.term, type) & rest
      }
  }

Kind.Term.check.expand.cse(
  expr: Kind.Term,
  name: Kind.Name,
  wyth: List<Kind.Ann>,
  cses: BitsMap<Kind.Term>,
  moti: Maybe<Kind.Term>,
  etyp: Kind.Term, // type of expr
  rtyp: Maybe<Kind.Term>, // inferred return type
  defs: Kind.Defs,
  ctxt: Kind.Context,
): Maybe<Kind.Term>
  case Kind.Term.reduce(etyp, defs) as etyp {
    all:
      let moti = Kind.Term.check.expand.cse.motive(wyth, moti, name, expr, etyp, rtyp, defs, List.length!(ctxt));
      let argm = Kind.Term.check.expand.cse.argument(name, [], etyp.xtyp, moti, defs);
      let expr = Kind.Term.app(expr, argm);
      let type = etyp.body(Kind.Term.var(etyp.self,0), Kind.Term.var(etyp.name,0));
      Maybe.some!(Kind.Term.check.expand.cse.cases(expr, name, wyth, cses, type, defs, ctxt))
    _:
      Maybe.none!
  }: Maybe<Kind.Term>

Kind.Term.check.expand.cse.argument(
  name: Kind.Name,
  wyth: List<Kind.Ann>,
  type: Kind.Term,
  body: Kind.Term,
  defs: Kind.Defs,
): Kind.Term
  case Kind.Term.reduce(type, defs) as type {
    all:
      def type = type.body(Kind.Term.var(type.self,0), Kind.Term.var(type.name,0));
      def lam_name =
        if String.is_empty(type.name) then
          name
        else
          String.flatten([name, ".", type.name]);
      def lam_body = (x) Kind.Term.check.expand.cse.argument(name, wyth, type, body, defs);
      Kind.Term.lam(lam_name, lam_body),
    _: case wyth {
      cons:
        open wyth.head
        def lam_name = wyth.head.name;
        def lam_body = (x) Kind.Term.check.expand.cse.argument(name, wyth.tail, type, body, defs);
        Kind.Term.lam(lam_name, lam_body)
      nil:
        body
    }
  }

Kind.Term.check.expand.cse.cases(
  expr: Kind.Term,
  name: Kind.Name,
  wyth: List<Kind.Ann>,
  cses: BitsMap<Kind.Term>,
  type: Kind.Term,
  defs: Kind.Defs,
  ctxt: Kind.Context,
): Kind.Term
  case Kind.Term.reduce(type, defs) as type {
    all: 
      let argm = Maybe.or!(Kind.Map.get!(type.name, cses), Kind.Map.get!("_", cses));
      let argm = argm <> Kind.Term.ref(name | "_" | type.name | "_case");
      let argm = Kind.Term.check.expand.cse.argument(name, wyth, type.xtyp, argm, defs)
      let expr = Kind.Term.app(expr, argm);
      let type = type.body(Kind.Term.var(type.self,0), Kind.Term.var(type.name,0));
      Kind.Term.check.expand.cse.cases(expr, name, wyth, cses, type, defs, ctxt),
    _:
      let expr = for defn in wyth:
        Kind.Term.app(expr, case defn { new: defn.term })
      expr
  }

Kind.Term.check.expand.cse.motive.go(
  wyth: List<Kind.Ann>,
  moti: Maybe<Kind.Term>,
  name: String,
  expr: Kind.Term,
  etyp: Kind.Term,
  rtyp: Maybe<Kind.Term>,
  defs: Kind.Defs,
  size: Nat,
): Kind.Term
  case wyth {
    cons:
      open wyth.head
      def all_name = wyth.head.name;
      def all_xtyp = wyth.head.type <> Kind.Term.hol(Bits.e);
      def all_body = (s,x) Kind.Term.check.expand.cse.motive(wyth.tail, moti, name, expr, etyp, rtyp, defs, Nat.succ(Nat.succ(size)));
      Kind.Term.all(Bool.false, "", all_name, all_xtyp, all_body)
    nil: case moti {
      none:
        case rtyp {
          none:
            Kind.Term.hol(Bits.e)
          some:
            Kind.Term.normalize(rtyp.value, Kind.Map.new!)
        }
      some: 
        moti.value
    }
  }

Kind.Term.check.expand.cse.motive(
  wyth: List<Kind.Ann>,
  moti: Maybe<Kind.Term>,
  name: String,
  expr: Kind.Term,
  etyp: Kind.Term,
  rtyp: Maybe<Kind.Term>,
  defs: Kind.Defs,
  size: Nat,
): Kind.Term
  let done = Kind.Term.check.expand.cse.motive.go(wyth, moti, name, expr, etyp, rtyp, defs, size)
  case moti {
    none: Kind.Term.SmartMotive.make(name, expr, etyp, done, size, defs)
    some: done
  }
