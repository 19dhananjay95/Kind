Buffer32.from(str: String): Buffer32
  let size = String.length(str)
  Buffer32.from.go(str, Buffer32.alloc(size), 0#32)

Buffer32.from.go(str: String, buf: Buffer32, idx: U32): Buffer32
  case str {
    nil : buf
    cons:
      let c = Char.to_utf8(str.head)
      log("char to utf-8: " | Bits.show(U8.to_bits(Buffer8.get(0#32, c))))
      let u = Buffer8.to_u32(c)
      log("u8 to u32: " | Bits.show(U32.to_bits(u)))
      let new_buf = Buffer32.set(idx, u, buf)
      Buffer32.from.go(str.tail, new_buf, U32.add(1, idx))
  }

// Buffer32.Bytelist.bytes_to_u32(bytes: List<U8>, u_aux: U32): U32
//   case bytes {
//     nil:
//       u_aux 
//     cons:
//       let h = Nat.to_u32(U8.to_nat(bytes.head))
//       let u_aux = U32.shl(8, u_aux)
//       let u_aux = U32.or(h, u_aux)
//       Buffer32.Bytelist.bytes_to_u32(bytes.tail, u_aux)
//   } 

// Buffer32.Bytelist.to_buffer32(list: List<U8>, buf: Buffer32, idx: U32): Buffer32
//   let bytes = List.take!(4, list)
//   let u = Buffer32.Bytelist.bytes_to_u32(bytes, 0)
//   let u = U32.shl(8*(4 - Nat.to_u32(List.length!(bytes))), u)
//   let buf = Buffer32.set(idx, u, buf)
//   let tail = List.drop!(4, list)
//   case tail {
//     nil:
//       buf
//     cons:
//       Buffer32.Bytelist.to_buffer32(tail, buf, U32.add(1#32, idx))
//   }

// Char.to_ut8(c: U16): U32
//   let c_aux = U16.to_u32(c)
//   if U16.ltn(c, 0x80) then
//     let b0 = U16.or(0x00, n(0x7F, U16.shr(0, c))) // (c>>0 & 0x7F) | 0x00
//     //b0 & String.to_utf8_bytes(str.tail) 
//     U16.to_u32(b0)
//   else if U16.ltn(c, 0x0800) then
//     ?a
//     // let b0 = U16.to_u8(U16.or(0xC0, U16.and(0x1F, U16.shr(6, c)))) // (c>>6 & 0x1F) | 0xC0
//     // let b1 = U16.to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(0, c)))) // (c>>0 & 0x3F) | 0x80
//     // b0 & b1 & String.to_utf8_bytes(str.tail) 
//   else if U16.ltn(c, 0x010000) then
//     ?b
//     // let b0 = U16.to_u8(U16.or(0xE0, U16.and(0x0F, U16.shr(12, c)))) // (c>>12 & 0x0F) | 0xE0
//     // let b1 = U16.to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(6,  c)))) // (c>>6 & 0x3F) | 0x80
//     // let b2 = U16.to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(0,  c)))) // (c>>0 & 0x3F) | 0x80
//     // b0 & b1 & b2 & String.to_utf8_bytes(str.tail)
//   else // 0x110000
//     ?c
//     // let b0 = U16.to_u8(U16.or(0xF0, U16.and(0x07, U16.shr(18, c)))) // (c>>18 & 0x07) | 0xF0
//     // let b1 = U16.to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(12, c)))) // (c>>12 & 0x3F) | 0x80
//     // let b2 = U16.to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(6,  c)))) // (c>>6 & 0x3F) | 0x80
//     // let b3 = U16.to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(0,  c)))) // (c>>0 & 0x3F) | 0x80
//     // b0 & b1 & b2 & b3 & String.to_utf8_bytes(str.tail)

// // String.to_utf8_bytes(str: String): List<U8>
// //   case str {
// //     nil:
// //       []
// //     cons:
// //       let c = str.head
// //       if U16.ltn(c, 0x80) then
// //         let b0 = U16.to_u8(U16.or(0x00, U16.and(0x7F, U16.shr(0, c)))) // (c>>0 & 0x7F) | 0x00
// //         b0 & String.to_utf8_bytes(str.tail) 
// //       else if U16.ltn(c, 0x0800) then
// //         let b0 = U16.to_u8(U16.or(0xC0, U16.and(0x1F, U16.shr(6, c)))) // (c>>6 & 0x1F) | 0xC0
// //         let b1 = U16.to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(0, c)))) // (c>>0 & 0x3F) | 0x80
// //         b0 & b1 & String.to_utf8_bytes(str.tail) 
// //       else if U16.ltn(c, 0x010000) then
// //         let b0 = U16.to_u8(U16.or(0xE0, U16.and(0x0F, U16.shr(12, c)))) // (c>>12 & 0x0F) | 0xE0
// //         let b1 = U16.to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(6,  c)))) // (c>>6 & 0x3F) | 0x80
// //         let b2 = U16.to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(0,  c)))) // (c>>0 & 0x3F) | 0x80
// //         b0 & b1 & b2 & String.to_utf8_bytes(str.tail)
// //       else // 0x110000
// //         let b0 = U16.to_u8(U16.or(0xF0, U16.and(0x07, U16.shr(18, c)))) // (c>>18 & 0x07) | 0xF0
// //         let b1 = U16.to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(12, c)))) // (c>>12 & 0x3F) | 0x80
// //         let b2 = U16.to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(6,  c)))) // (c>>6 & 0x3F) | 0x80
// //         let b3 = U16.to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(0,  c)))) // (c>>0 & 0x3F) | 0x80
// //         b0 & b1 & b2 & b3 & String.to_utf8_bytes(str.tail)
// //   }

// // Buffer32.from(str: String): Buffer32
// //   let bytelist = String.to_utf8_bytes(str)
// //   let buf_size = ((List.length!(bytelist)-1) / 4) + 1 // divide by 4 rounding up
// //   let buf = Buffer32.alloc(buf_size)
// //   Buffer32.Bytelist.to_buffer32(bytelist, buf, 0)
 

// // 1. calcular o comprimento em bytes (da str)
// // 2. passa escrevendo no buffer
// // 00 73 | 05 AF
// // c = 00 73
// // c>>0 = 00 73
// // c>>0 & 0x7F = 00 73
// // c>>0 & 0x7F | 0x00 = 00 73
// // 73
// // c = 05 AF
// // c>>6 = 00 16
// // c>>6 & 0x1F = 00 16
// // c>>6 & 0x1F | 0xC0 = 00 D6
