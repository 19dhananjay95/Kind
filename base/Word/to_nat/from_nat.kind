Word.size.zero(w: Word(0)): w((w, w.size) Type, Unit, (size, pred) Empty, (size, pred) Empty)
  let contra = refl :: 0 == 0
  (case w {
    e:
      (contra)
        unit
    o:
      (contra)
        Empty.absurd!(Nat.succ_neq_zero(w.size, contra))
    i:
      (contra)
        Empty.absurd!(Nat.succ_neq_zero(w.size, contra))
  }: (h: w.size == 0) -> w((k, k.size) Type, Unit, (size, pred) Empty, (size, pred) Empty))(contra)

Word.size.succ(n: Nat, w: Word(Nat.succ(n))): w((w, w.size) Type, Empty, (size, pred) Unit, (size, pred) Unit)
  let contra = refl :: Nat.succ(n) == Nat.succ(n)
  (case w {
    e:
      (contra)
        Empty.absurd!(Nat.succ_neq_zero(n, contra))
    o:
      (contra)
        unit
    i:
      (contra)
        unit
  }: (h: Nat.succ(n) == w.size) -> w((k, k.size) Type, Empty, (size, pred) Unit, (size, pred) Unit))(contra)

Word.to_nat.from_nat<size: Nat>(
  n: Nat
): Word.to_nat(size, Nat.to_word(size, n)) == Nat.mod(n, Nat.pow(2, size))
  case size {
    zero:
      let case_elim = Word.size.zero(Nat.to_word(0, n))
      let qed =
        case Nat.to_word(0, n) {
          e:
            (case_elim)
              case refl :: 1 == Nat.pow(2, 0) {
                refl:
                  case Nat.mod.one(n) {
                    refl:
                      refl
                  }: Equal(Nat, self.b, Nat.mod(n, 1))
              }: Equal(Nat, 0, Nat.mod(n, self.b))
          i:
            (case_elim)
              Empty.absurd!(case_elim)
          o:
            (case_elim)
              Empty.absurd!(case_elim)
        }: (case_elim: self((w, w.size) Type, Unit, (size, pred) Empty, (size, pred) Empty)) -> (Word.to_nat(self.size, self) == Nat.mod(n, Nat.pow(2, 0)))
      qed(case_elim)
    succ:
      case n {
        zero:
          let lemma_right =
            let contra = Nat.pow.lte(1, Nat.succ(size.pred))
            (case Nat.pow(2,Nat.succ(size.pred)) {
              zero:
                (contra)
                  Empty.absurd!(Bool.true_neq_false(contra))
              succ:
                (contra)
                  refl
            }: (contra: Nat.lte(self,0) == Bool.false) -> (0 == Nat.mod(0,self)))(contra)
          let lemma_left = mirror(Word.to_nat.zero(Nat.succ(size.pred)))
          chain(lemma_left, lemma_right)
        succ:
          let lemma = refl :: Word.inc(Nat.succ(size.pred),Nat.to_word(Nat.succ(size.pred),n.pred)) == Nat.to_word(Nat.succ(size.pred),Nat.succ(n.pred))
          ?succ
      }!
  }!
// to_nat(_, to_word(_, succ(n.pred))) == mod(succ(n.pred), 2^succ(size.pred))
// to_nat(_, inc(to_word(_, n.pred)))  == mod(succ(n.pred), 2^succ(size.pred))
//   * to_nat(_, inc(to_word(_, n.pred)))  == mod(succ(n.pred), 2^succ(size.pred))
// ind:
//   to_nat(_, to_word(_, n.pred)) == mod(n.pred, 2^succ(size.pred))


Word.to_nat.zero(size: Nat): 0 == Word.to_nat(size, Word.zero(size))
  case size {
    zero:
      refl
    succ:
      case Word.to_nat.zero(size.pred) {
        refl:
          refl
      }: 0 == Nat.mul(2, self.b)
  }!
