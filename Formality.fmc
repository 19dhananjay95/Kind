// Bool
// ====

Bool : Type
  self(P: (x: Bool) -> Type;) ->
  (t: P(true)) ->
  (f: P(false)) ->
  P(self)

true: Bool
  (P;) => (t) => (f) => t

false: Bool
  (P;) => (t) => (f) => f

case_bool
  : (b: Bool) ->
    (P: (x: Bool) -> Type;) ->
    (t: P(true)) ->
    (f: P(false)) ->
    P(b)
  (b) => (P;) => (t) => (f) => b(P;)(t)(f)

or: (:Bool) -> (:Bool) -> Bool
  (a) => (b) =>
  let case_a_tru = (b)(() => Bool;)(true)(true)
  let case_a_fal = (b)(() => Bool;)(true)(false)
  let case_a_mot = () => Bool
  a(case_a_mot;)(case_a_tru)(case_a_fal)

and: (:Bool) -> (:Bool) -> Bool
  (a) => (b) =>
  let case_a_tru = (b)(() => Bool;)(true)(false)
  let case_a_fal = (b)(() => Bool;)(false)(false)
  let case_a_mot = () => Bool
  a(case_a_mot;)(case_a_tru)(case_a_fal)
  
// Cmp

Cmp : Type
  self(P: (x: Cmp) -> Type;) ->
  (ltn: P(ltn)) ->
  (eql: P(eql)) ->
  (gtn: P(gtn)) ->
  P(self)

ltn: Cmp
  (P;) => (ltn) => (eql) => (gtn) => ltn

eql: Cmp
  (P;) => (ltn) => (eql) => (gtn) => eql

gtn: Cmp
  (P;) => (ltn) => (eql) => (gtn) => gtn

// Bit
// ===

Bit : Type
  self(P: (x: Bool) -> Type;) ->
  (t: P(t0)) ->
  (f: P(t1)) ->
  P(self)

t0: Bit
  (P;) => (t0) => (t1) => t0

t1: Bit
  (P;) => (t0) => (t1) => t1

// Nat
// ===

Nat: Type
  self(P: (x: Nat) -> Type;) ->
  (z: P(zero)) ->
  (s: (pred: Nat) -> P(succ(pred))) ->
  P(self)

zero: Nat
  (P;) => (z) => (s) => z

succ: (n: Nat) -> Nat
  (n) => (P;) => (z) => (s) => s(n)

pred: (n: Nat) -> Nat
  (n) =>
  let case_zero = zero
  let case_succ = (pred) => pred
  n((self) => Nat;)(case_zero)(case_succ)

fold_nat
  : (n: Nat) ->
    (P: (n: Nat) -> Type;) ->
    (z: P(zero)) ->
    (s: (n: Nat) -> (i: P(n)) -> P(succ(n))) ->
    P(n)
  (n) => (P;) => (z) => (s) =>
  n(P;)(z)((pred) => s(pred)(fold_nat(pred)(P;)(z)(s)))

double: (n: Nat) -> Nat
  (n) => n((x) => Nat;)(zero)((pred) => succ(succ(double(pred))))

n0: Nat
  zero

n1: Nat
  succ(n0)

n2: Nat
  succ(n1)

n3: Nat
  succ(n2)

n4: Nat
  succ(n3)

n5: Nat
  succ(n4)

n6: Nat
  succ(n5)

n7: Nat
  succ(n6)

n8: Nat
  succ(n7)

n9: Nat
  succ(n8)

n9: Nat
  succ(n8)

n10: Nat
  succ(n9)

n11: Nat
  succ(n10)

n12: Nat
  succ(n11)

n13: Nat
  succ(n12)

n14: Nat
  succ(n13)

n15: Nat
  succ(n14)

n16: Nat
  succ(n15)

n17: Nat
  succ(n16)

n18: Nat
  succ(n17)

n19: Nat
  succ(n18)

n20: Nat
  succ(n19)

n21: Nat
  succ(n20)

n22: Nat
  succ(n21)

n23: Nat
  succ(n22)

n24: Nat
  succ(n23)

n25: Nat
  succ(n24)

n26: Nat
  succ(n25)

n27: Nat
  succ(n26)

n28: Nat
  succ(n27)

n29: Nat
  succ(n28)

n30: Nat
  succ(n29)

n31: Nat
  succ(n30)

n32: Nat
  succ(n31)

// Pair
// ====

Pair: (A: Type) -> (B: Type) -> Type
  (A) => (B) =>
  self(P: (x: Pair(A)(B)) -> Type;) ->
  (pair: (a: A) -> (b: B) -> P(pair(A;)(B;)(a)(b))) ->
  P(self)

pair: (A: Type;) -> (B: Type;) -> (a: A) -> (b: B) -> Pair(A)(B)
  (A;) => (B;) => (a) => (b) =>
  (P;) => (pair) =>
  pair(a)(b)

// Maybe
// =====

Maybe: (A: Type) -> Type
  (A) =>
  self(P: (x: Maybe(A)) -> Type;) ->
  (none: P(none(A;))) ->
  (some: (value: A) -> P(some(A;)(value))) ->
  P(self)

none: (A: Type;) -> Maybe(A)
  (A;) =>
  (;) => (none) => () => none

some: (A: Type;) -> (:A) -> Maybe(A)
  (A;) => (value) =>
  (;) => () => (some) => some(value)

// List
// ====

List: (A: Type) -> Type
  (A) =>
  self(P: (x: List(A)) -> Type;) ->
  (nil: P(nil(A;))) ->
  (ext: (head: A) -> (tail: List(A)) -> P(ext(A;)(head)(tail))) ->
  P(self)

nil: (A: Type;) -> List(A)
  (A;) =>
  (;) => (nil) => () => nil

ext: (A: Type;) -> (:A) -> (:List(A)) -> List(A)
  (A;) => (head) => (tail) =>
  (;) => () => (ext) => ext(head)(tail)

find
  : (A: Type;) ->
    (list: List(A)) ->
    (cond: (:A) -> (:Nat) -> Bool) ->
    (indx: Nat) ->
    Maybe(Pair(A)(Nat))
  (A;) => (list) => (cond) => (indx) =>
  let case_nil = none(Pair(A)(Nat);)
  let case_ext = (head) => (tail) =>
    let case_true  = some(Pair(A)(Nat);)(pair(A;)(Nat;)(head)(indx))
    let case_false = find(A;)(tail)(cond)(succ(indx))
    cond(head)(indx)(() => Maybe(Pair(A)(Nat));)(case_true)(case_false)
  list(() => Maybe(Pair(A)(Nat));)(case_nil)(case_ext)

// Bits
// ====

Bits: Type
  self(P: (x: Bits) -> Type;) ->
  (be: P(be)) ->
  (b0: (pred: Bits) -> P(b0(pred))) ->
  (b1: (pred: Bits) -> P(b1(pred))) ->
  P(self)

be: Bits
  (P;) => (be) => (b0) => (b1) => be

b0: (bs: Bits) -> Bits
  (bs) => (P;) => (be) => (b0) => (b1) => b0(bs)

b1: (bs: Bits) -> Bits
  (bs) => (P;) => (be) => (b0) => (b1) => b1(bs)

// Word
// ====

Word: (size: Nat) -> Type
  (size) =>
  self(P: (size: Nat) -> (x: Word(size)) -> Type;) ->
  (we: P(zero)(we)) ->
  (w0: (size: Nat;) -> (pred: Word(size)) -> P(succ(size))(w0(size;)(pred))) ->
  (w1: (size: Nat;) -> (pred: Word(size)) -> P(succ(size))(w1(size;)(pred))) ->
  P(size)(self)

we: Word(zero)
  (P;) => (we) => (w0) => (w1) =>
  we

w0: (size: Nat;) -> (wo: Word(size)) -> Word(succ(size))
  (size;) => (wo) => (P;) => (we) => (w0) => (w1) =>
  w0(size;)(wo)

w1: (size: Nat;) -> (wo: Word(size)) -> Word(succ(size))
  (size;) => (wo) => (P;) => (we) => (w0) => (w1) =>
  w1(size;)(wo)

winc: (size: Nat) -> (word: Word(size)) -> Word(size)
  (size) => (word) =>
  let case_we = we
  let case_w0 = (size;) => (pred) => w1(size;)(pred)
  let case_w1 = (size;) => (pred) => w0(size;)(winc(size)(pred))
  let motive  = (size) => (word) => Word(size)
  word(motive;)(case_we)(case_w0)(case_w1)

wadd: (size: Nat;) -> (a: Word(size)) -> (b: Word(size)) -> (c: Bool) -> Word(size)
  (size;) => (a) => (b) => (c) =>

  let case_a_we = (b) => we

  let case_a_w0 = (a_size;) => (a_pred) => (b) =>
    let case_b_we = (a_pred) =>
      we

    let case_b_w0 = (b_size;) => (b_pred) => (a_pred) =>
      // wadd (w0 a_pred) (w0 b_pred) true
      let case_c_tr = w1(b_size;)(wadd(b_size;)(a_pred)(b_pred)(false))
      // wadd (w0 a_pred) (w0 b_pred) false
      let case_c_fa = w0(b_size;)(wadd(b_size;)(a_pred)(b_pred)(false))
      let case_c_ty = (c_bool) => Word(succ(b_size))
      c(case_c_ty;)(case_c_tr)(case_c_fa)

    let case_b_w1 = (b_size;) => (b_pred) => (a_pred) =>
      // wadd (w0 a_pred) (w1 b_pred) true
      let case_c_tr = w0(b_size;)(wadd(b_size;)(a_pred)(b_pred)(true))
      // wadd (w0 a_pred) (w1 b_pred) false
      let case_c_fa = w1(b_size;)(wadd(b_size;)(a_pred)(b_pred)(false))
      let case_c_ty = (c_bool) => Word(succ(b_size))
      c(case_c_ty;)(case_c_tr)(case_c_fa)

    let case_b_ty = (b_size) => (b_word) =>
      (a_pred: Word(pred(b_size))) -> Word(b_size)

    b(case_b_ty;)(case_b_we)(case_b_w0)(case_b_w1)(a_pred)

  let case_a_w1 = (a_size;) => (a_pred) => (b) =>
    let case_b_we = (a_pred) => we

    let case_b_w0 = (b_size;) => (b_pred) => (a_pred) =>
      // wadd (w1 a_pred) (w0 b_pred) true
      let case_c_tr = w0(b_size;)(wadd(b_size;)(a_pred)(b_pred)(true))
      // wadd (w1 a_pred) (w0 b_pred) false
      let case_c_fa = w1(b_size;)(wadd(b_size;)(a_pred)(b_pred)(false))
      let case_c_ty = (c_bool) => Word(succ(b_size))
      c(case_c_ty;)(case_c_tr)(case_c_fa)

    let case_b_w1 = (b_size;) => (b_pred) => (a_pred) =>
      // wadd (w1 a_pred) (w1 b_pred) true
      let case_c_tr = w1(b_size;)(wadd(b_size;)(a_pred)(b_pred)(true))
      // wadd (w1 a_pred) (w1 b_pred) false
      let case_c_fa = w0(b_size;)(wadd(b_size;)(a_pred)(b_pred)(true))
      let case_c_ty = (c_bool) => Word(succ(b_size))
      c(case_c_ty;)(case_c_tr)(case_c_fa)

    let case_b_ty = (b_size) => (b_word) =>
      (a_pred: Word(pred(b_size))) -> Word(b_size)

    b(case_b_ty;)(case_b_we)(case_b_w0)(case_b_w1)(a_pred)

  let case_a_ty = (a_size) => (a_word) =>
    (b: Word(a_size)) -> Word(a_size)

  a(case_a_ty;)(case_a_we)(case_a_w0)(case_a_w1)(b)

word_eql : (size:Nat;) -> (:Word(size)) -> (:Word(size)) -> Bool
  (size;) => (a) => (b) =>
  let case_a_we = (b) => true
  let case_a_w0 = (a_size;) => (a_pred) => (b) =>
    let case_b_we = (a_pred) => false
    let case_b_w0 = (b_size;) => (b_pred) => (a_pred) => word_eql(b_size;)(a_pred)(b_pred)
    let case_b_w1 = (b_size;) => (b_pred) => (a_pred) => false
    let case_b_ty = (b_size) => (b_word) => (a_pred: Word(pred(b_size))) -> Bool
    b(case_b_ty;)(case_b_we)(case_b_w0)(case_b_w1)(a_pred)
  let case_a_w1 = (a_size;) => (a_pred) => (b) =>
    let case_b_we = (a_pred) => false
    let case_b_w0 = (b_size;) => (b_pred) => (a_pred) => false
    let case_b_w1 = (b_size;) => (b_pred) => (a_pred) => word_eql(b_size;)(a_pred)(b_pred)
    let case_b_ty = (b_size) => (b_word) => (a_pred: Word(pred(b_size))) -> Bool
    b(case_b_ty;)(case_b_we)(case_b_w0)(case_b_w1)(a_pred)
  let case_a_ty = (a_size) => (a_word) =>
    (b: Word(a_size)) -> Bool
  a(case_a_ty;)(case_a_we)(case_a_w0)(case_a_w1)(b)

word_cmp_aux : (size:Nat;) -> (:Word(size)) -> (:Word(size)) -> (:Cmp) -> Cmp
  (size;) => (a) => (b) => (c) =>
  let case_a_we = (b) => c
  let case_a_w0 = (a_size;) => (a_pred) => (b) =>
    let case_b_we = (a_pred) => c
    let case_b_w0 = (b_size;) => (b_pred) => (a_pred) => word_cmp_aux(b_size;)(a_pred)(b_pred)(c)
    let case_b_w1 = (b_size;) => (b_pred) => (a_pred) => word_cmp_aux(b_size;)(a_pred)(b_pred)(ltn)
    let case_b_ty = (b_size) => (b_word) => (a_pred: Word(pred(b_size))) -> Cmp
    b(case_b_ty;)(case_b_we)(case_b_w0)(case_b_w1)(a_pred)
  let case_a_w1 = (a_size;) => (a_pred) => (b) =>
    let case_b_we = (a_pred) => c
    let case_b_w0 = (b_size;) => (b_pred) => (a_pred) => word_cmp_aux(b_size;)(a_pred)(b_pred)(gtn)
    let case_b_w1 = (b_size;) => (b_pred) => (a_pred) => word_cmp_aux(b_size;)(a_pred)(b_pred)(c)
    let case_b_ty = (b_size) => (b_word) => (a_pred: Word(pred(b_size))) -> Cmp
    b(case_b_ty;)(case_b_we)(case_b_w0)(case_b_w1)(a_pred)
  let case_a_ty = (a_size) => (a_word) =>
    (b: Word(a_size)) -> Cmp
  a(case_a_ty;)(case_a_we)(case_a_w0)(case_a_w1)(b)

word_cmp : (size:Nat;) -> (:Word(size)) -> (:Word(size)) -> Cmp
  (size;) => (a) => (b) =>
  word_cmp_aux(size;)(a)(b)(eql)

// Term
// ====

Term: Type
  self(P: (x: Term) -> Type;) ->
  (var:
    (hash: Bits) ->
    (indx: Nat) ->
    P(var(indx))) ->
  (ref:
    (hash: Bits) ->
    (name: Bits) ->
    P(ref(name))) ->
  (typ:
    (hash: Bits) ->
    P(typ)) ->
  (all:
    (hash: Bits) ->
    (eras: Bool) ->
    (self: Bits) ->
    (name: Bits) ->
    (bind: Term) ->
    (body: Term) ->
    P(all(eras)(self)(name)(bind)(body))) ->
  (lam:
    (hash: Bits) ->
    (eras: Bool) ->
    (name: Bits) ->
    (body: Term) ->
    P(lam(eras)(name)(body))) ->
  (app:
    (hash: Bits) ->
    (eras: Bool) ->
    (func: Term) ->
    (argm: Term) ->
    P(app(eras)(func)(argm))) ->
  (lit:
    (hash: Bits) ->
    (name: Bits) ->
    (expr: Term) ->
    (body: Term) ->
    P(lit(name)(expr)(body))) ->
  (ann:
    (hash: Bits) ->
    (done: Bool) ->
    (expr: Term) ->
    (type: Term) ->
    P(ann(done)(expr)(type))) ->
  P(self)

var: (indx: Nat) -> Term
  (indx)=>
  (;) => (var) => () => () => () => () => () => () => () =>
  var(be)(indx)

ref: (name: Bits) -> Term
  (name)=>
  (;) => () => (ref) => () => () => () => () => () => () =>
  ref(be)(name)

typ: Term
  (;) => () => () => (typ) => () => () => () => () => () =>
  typ(be)

all: (:Bool) -> (:Bits) -> (:Bits) -> (:Term) -> (:Term) -> Term
  (eras) => (self) => (name) => (bind) => (body) =>
  (;) => () => () => () => (all) => () => () => () => () =>
  all(be)(eras)(self)(name)(bind)(body)

lam: (:Bool) -> (:Bits) -> (:Term) -> Term
  (eras) => (name) => (body) =>
  (;) => () => () => () => () => (lam) => () => () => () =>
  lam(be)(eras)(name)(body)

app: (:Bool) -> (:Term) -> (:Term) -> Term
  (eras) => (func) => (argm) =>
  (;) => () => () => () => () => () => (app) => () => () =>
  app(be)(eras)(func)(argm)

lit: (:Bits) -> (:Term) -> (:Term) -> Term
  (name) => (expr) => (body) =>
  (;) => () => () => () => () => () => () => (lit) => () =>
  lit(be)(name)(expr)(body)

ann: (done: Bool) -> (expr: Term) -> (type: Term) -> Term
  (done) => (expr) => (type) =>
  (;) => () => () => () => () => () => () => () => (ann) =>
  ann(be)(done)(expr)(type)

// Characters

Char: Type
  Word(n32)

ascii: (:Bit)->(:Bit)->(:Bit)->(:Bit)->(:Bit)->(:Bit)->(:Bit)->(:Bit)->Char
  (a) => (b) => (c) => (d) => (e) => (f) => (g) => (h) =>
  let ty = (size: Nat;) -> (wo: Word(size)) -> Word(succ(size))
  let wA = a(() => ty;)(w0)(w1)
  let wB = b(() => ty;)(w0)(w1)
  let wC = c(() => ty;)(w0)(w1)
  let wD = d(() => ty;)(w0)(w1)
  let wE = e(() => ty;)(w0)(w1)
  let wF = f(() => ty;)(w0)(w1)
  let wG = g(() => ty;)(w0)(w1)
  let wH = h(() => ty;)(w0)(w1)
  wH(n31;)(wG(n30;)(wF(n29;)(wE(n28;)(wD(n27;)(wC(n26;)(wB(n25;)(wA(n24;)(
  w0(n23;)(w0(n22;)(w0(n21;)(w0(n20;)(w0(n19;)(w0(n18;)(w0(n17;)(w0(n16;)(
  w0(n15;)(w0(n14;)(w0(n13;)(w0(n12;)(w0(n11;)(w0(n10;)(w0(n9 ;)(w0(n8 ;)(
  w0(n7 ;)(w0(n6 ;)(w0(n5 ;)(w0(n4 ;)(w0(n3 ;)(w0(n2 ;)(w0(n1 ;)(w0(n0 ;)(
  we))))))))))))))))))))))))))))))))

char_tab : Char
  ascii(t0)(t0)(t1)(t0)(t1)(t0)(t0)(t1)

char_newline : Char
  ascii(t0)(t0)(t1)(t0)(t1)(t0)(t1)(t0)

char_space : Char
  ascii(t0)(t0)(t1)(t0)(t0)(t0)(t0)(t0)

char_exclamation: Char
  ascii(t0)(t0)(t1)(t0)(t0)(t0)(t0)(t1)

char_quotation: Char
  ascii(t0)(t0)(t1)(t0)(t0)(t0)(t1)(t0)

char_number: Char
  ascii(t0)(t0)(t1)(t0)(t0)(t0)(t1)(t1)

char_dollar: Char
  ascii(t0)(t0)(t1)(t0)(t0)(t1)(t0)(t0)

char_percent: Char
  ascii(t0)(t0)(t1)(t0)(t0)(t1)(t0)(t1)

char_ampersand: Char
  ascii(t0)(t0)(t1)(t0)(t0)(t1)(t1)(t0)

char_apostrophe: Char
  ascii(t0)(t0)(t1)(t0)(t0)(t1)(t1)(t1)

char_left_parens: Char
  ascii(t0)(t0)(t1)(t0)(t1)(t0)(t0)(t0)

char_right_parens: Char
  ascii(t0)(t0)(t1)(t0)(t1)(t0)(t0)(t1)

char_asterisk: Char
  ascii(t0)(t0)(t1)(t0)(t1)(t0)(t1)(t0)

char_plus: Char
  ascii(t0)(t0)(t1)(t0)(t1)(t0)(t1)(t1)

char_comma: Char
  ascii(t0)(t0)(t1)(t0)(t1)(t1)(t0)(t0)

char_hyphen: Char
  ascii(t0)(t0)(t1)(t0)(t1)(t1)(t0)(t1)

char_period: Char
  ascii(t0)(t0)(t1)(t0)(t1)(t1)(t1)(t0)

char_slash: Char
  ascii(t0)(t0)(t1)(t0)(t1)(t1)(t1)(t1)

char_0: Char
  ascii(t0)(t0)(t1)(t1)(t0)(t0)(t0)(t0)

char_1: Char
  ascii(t0)(t0)(t1)(t1)(t0)(t0)(t0)(t1)

char_2: Char
  ascii(t0)(t0)(t1)(t1)(t0)(t0)(t1)(t0)

char_3: Char
  ascii(t0)(t0)(t1)(t1)(t0)(t0)(t1)(t1)

char_4: Char
  ascii(t0)(t0)(t1)(t1)(t0)(t1)(t0)(t0)

char_5: Char
  ascii(t0)(t0)(t1)(t1)(t0)(t1)(t0)(t1)

char_6: Char
  ascii(t0)(t0)(t1)(t1)(t0)(t1)(t1)(t0)

char_7: Char
  ascii(t0)(t0)(t1)(t1)(t0)(t1)(t1)(t1)

char_8: Char
  ascii(t0)(t0)(t1)(t1)(t1)(t0)(t0)(t0)

char_9: Char
  ascii(t0)(t0)(t1)(t1)(t1)(t0)(t0)(t1)

char_colon: Char
  ascii(t0)(t0)(t1)(t1)(t1)(t0)(t1)(t0)

char_semicolon: Char
  ascii(t0)(t0)(t1)(t1)(t1)(t0)(t1)(t1)

char_less_than: Char
  ascii(t0)(t0)(t1)(t1)(t1)(t1)(t0)(t0)

char_equals: Char
  ascii(t0)(t0)(t1)(t1)(t1)(t1)(t0)(t1)

char_greater_than: Char
  ascii(t0)(t0)(t1)(t1)(t1)(t1)(t1)(t0)

char_question: Char
  ascii(t0)(t0)(t1)(t1)(t1)(t1)(t1)(t1)

char_at: Char
  ascii(t0)(t1)(t0)(t0)(t0)(t0)(t0)(t0)

char_A: Char
  ascii(t0)(t1)(t0)(t0)(t0)(t0)(t0)(t1)

char_B: Char
  ascii(t0)(t1)(t0)(t0)(t0)(t0)(t1)(t0)

char_C: Char
  ascii(t0)(t1)(t0)(t0)(t0)(t0)(t1)(t1)

char_D: Char
  ascii(t0)(t1)(t0)(t0)(t0)(t1)(t0)(t0)

char_E: Char
  ascii(t0)(t1)(t0)(t0)(t0)(t1)(t0)(t1)

char_F: Char
  ascii(t0)(t1)(t0)(t0)(t0)(t1)(t1)(t0)

char_G: Char
  ascii(t0)(t1)(t0)(t0)(t0)(t1)(t1)(t1)

char_H: Char
  ascii(t0)(t1)(t0)(t0)(t1)(t0)(t0)(t0)

char_I: Char
  ascii(t0)(t1)(t0)(t0)(t1)(t0)(t0)(t1)

char_J: Char
  ascii(t0)(t1)(t0)(t0)(t1)(t0)(t1)(t0)

char_K: Char
  ascii(t0)(t1)(t0)(t0)(t1)(t0)(t1)(t1)

char_L: Char
  ascii(t0)(t1)(t0)(t0)(t1)(t1)(t0)(t0)

char_M: Char
  ascii(t0)(t1)(t0)(t0)(t1)(t1)(t0)(t1)

char_N: Char
  ascii(t0)(t1)(t0)(t0)(t1)(t1)(t1)(t0)

char_O: Char
  ascii(t0)(t1)(t0)(t0)(t1)(t1)(t1)(t1)

char_P: Char
  ascii(t0)(t1)(t0)(t1)(t0)(t0)(t0)(t0)

char_Q: Char
  ascii(t0)(t1)(t0)(t1)(t0)(t0)(t0)(t1)

char_R: Char
  ascii(t0)(t1)(t0)(t1)(t0)(t0)(t1)(t0)

char_S: Char
  ascii(t0)(t1)(t0)(t1)(t0)(t0)(t1)(t1)

char_T: Char
  ascii(t0)(t1)(t0)(t1)(t0)(t1)(t0)(t0)

char_U: Char
  ascii(t0)(t1)(t0)(t1)(t0)(t1)(t0)(t1)

char_V: Char
  ascii(t0)(t1)(t0)(t1)(t0)(t1)(t1)(t0)

char_W: Char
  ascii(t0)(t1)(t0)(t1)(t0)(t1)(t1)(t1)

char_X: Char
  ascii(t0)(t1)(t0)(t1)(t1)(t0)(t0)(t0)

char_Y: Char
  ascii(t0)(t1)(t0)(t1)(t1)(t0)(t0)(t1)

char_Z: Char
  ascii(t0)(t1)(t0)(t1)(t1)(t0)(t1)(t0)

char_left_bracket: Char
  ascii(t0)(t1)(t0)(t1)(t1)(t0)(t1)(t1)

char_backslash: Char
  ascii(t0)(t1)(t0)(t1)(t1)(t1)(t0)(t0)

char_right_bracket: Char
  ascii(t0)(t1)(t0)(t1)(t1)(t1)(t0)(t1)

char_caret: Char
  ascii(t0)(t1)(t0)(t1)(t1)(t1)(t1)(t0)

char_underscore: Char
  ascii(t0)(t1)(t0)(t1)(t1)(t1)(t1)(t1)

char_backtick: Char
  ascii(t0)(t1)(t1)(t0)(t0)(t0)(t0)(t0)

char_a: Char
  ascii(t0)(t1)(t1)(t0)(t0)(t0)(t0)(t1)

char_b: Char
  ascii(t0)(t1)(t1)(t0)(t0)(t0)(t1)(t0)

char_c: Char
  ascii(t0)(t1)(t1)(t0)(t0)(t0)(t1)(t1)

char_d: Char
  ascii(t0)(t1)(t1)(t0)(t0)(t1)(t0)(t0)

char_e: Char
  ascii(t0)(t1)(t1)(t0)(t0)(t1)(t0)(t1)

char_f: Char
  ascii(t0)(t1)(t1)(t0)(t0)(t1)(t1)(t0)

char_g: Char
  ascii(t0)(t1)(t1)(t0)(t0)(t1)(t1)(t1)

char_h: Char
  ascii(t0)(t1)(t1)(t0)(t1)(t0)(t0)(t0)

char_i: Char
  ascii(t0)(t1)(t1)(t0)(t1)(t0)(t0)(t1)

char_j: Char
  ascii(t0)(t1)(t1)(t0)(t1)(t0)(t1)(t0)

char_k: Char
  ascii(t0)(t1)(t1)(t0)(t1)(t0)(t1)(t1)

char_l: Char
  ascii(t0)(t1)(t1)(t0)(t1)(t1)(t0)(t0)

char_m: Char
  ascii(t0)(t1)(t1)(t0)(t1)(t1)(t0)(t1)

char_n: Char
  ascii(t0)(t1)(t1)(t0)(t1)(t1)(t1)(t0)

char_o: Char
  ascii(t0)(t1)(t1)(t0)(t1)(t1)(t1)(t1)

char_p: Char
  ascii(t0)(t1)(t1)(t1)(t0)(t0)(t0)(t0)

char_q: Char
  ascii(t0)(t1)(t1)(t1)(t0)(t0)(t0)(t1)

char_r: Char
  ascii(t0)(t1)(t1)(t1)(t0)(t0)(t1)(t0)

char_s: Char
  ascii(t0)(t1)(t1)(t1)(t0)(t0)(t1)(t1)

char_t: Char
  ascii(t0)(t1)(t1)(t1)(t0)(t1)(t0)(t0)

char_u: Char
  ascii(t0)(t1)(t1)(t1)(t0)(t1)(t0)(t1)

char_v: Char
  ascii(t0)(t1)(t1)(t1)(t0)(t1)(t1)(t0)

char_w: Char
  ascii(t0)(t1)(t1)(t1)(t0)(t1)(t1)(t1)

char_x: Char
  ascii(t0)(t1)(t1)(t1)(t1)(t0)(t0)(t0)

char_y: Char
  ascii(t0)(t1)(t1)(t1)(t1)(t0)(t0)(t1)

char_z: Char
  ascii(t0)(t1)(t1)(t1)(t1)(t0)(t1)(t0)

char_left_brace: Char
  ascii(t0)(t1)(t1)(t1)(t1)(t0)(t1)(t1)

char_bar: Char
  ascii(t0)(t1)(t1)(t1)(t1)(t1)(t0)(t0)

char_right_brace: Char
  ascii(t0)(t1)(t1)(t1)(t1)(t1)(t0)(t1)

char_tilde: Char
  ascii(t0)(t1)(t1)(t1)(t1)(t1)(t1)(t0)

// Parsing
// =======

is_space: (:Char) -> Bool
  (c) =>
    let is_spc = word_eql(n32;)(c)(char_space)
    let is_tab = word_eql(n32;)(c)(char_tab)
    let is_lin = word_eql(n32;)(c)(char_newline)
    or(is_spc)(or(is_tab)(is_lin))

// Main
// ====

example_0: Word(n4)
  let w0011 = w1(n3;)(w1(n2;)(w0(n1;)(w0(n0;)(we))))
  let w0101 = w1(n3;)(w0(n2;)(w1(n1;)(w0(n0;)(we))))
  wadd(n4;)(w0011)(w0101)(false) // 3 + 5 == 8

main : Cmp
  let w0011 = w1(n3;)(w1(n2;)(w0(n1;)(w0(n0;)(we))))
  let w0101 = w1(n3;)(w0(n2;)(w1(n1;)(w0(n0;)(we))))
  word_cmp(n4;)(w0011)(w0101)
