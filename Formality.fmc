Bool : Type
  self(P : (x : Bool) -> Type;) ->
  (t : P(true)) ->
  (f : P(false)) ->
  P(self)

true : Bool
  (P;) => (t) => (f) => t

false : Bool
  (P;) => (t) => (f) => f

case_bool
  : (b : Bool) ->
    (P : (x : Bool) -> Type;) ->
    (t : P(true)) ->
    (f : P(false)) ->
    P(b)
  (b) => (P;) => (t) => (f) => b(P;)(t)(f)
  
Nat : Type
  self(P : (x : Nat) -> Type;) ->
  (z : P(zero)) ->
  (s : (pred : Nat) -> P(succ(pred))) ->
  P(self)

zero : Nat
  (P;) => (z) => (s) => z

succ : (n : Nat) -> Nat
  (n) => (P;) => (z) => (s) => s(n)

pred : (n : Nat) -> Nat
  (n) =>
  let case_zero = zero
  let case_succ = (pred) => pred
  n((self) => Nat;)(case_zero)(case_succ)

fold_nat
  : (n : Nat) ->
    (P : (n : Nat) -> Type;) ->
    (z : P(zero)) ->
    (s : (n : Nat) -> (i : P(n)) -> P(succ(n))) ->
    P(n)
  (n) => (P;) => (z) => (s) =>
  n(P;)(z)((pred) => s(pred)(fold_nat(pred)(P;)(z)(s)))

double : (n : Nat) -> Nat
  (n) => n((x) => Nat;)(zero)((pred) => succ(succ(double(pred))))

n0 : Nat
  zero

n1 : Nat
  succ(n0)

n2 : Nat
  succ(n1)

n3 : Nat
  succ(n2)

n4 : Nat
  succ(n3)

n5 : Nat
  succ(n4)

n6 : Nat
  succ(n5)

n7 : Nat
  succ(n6)

n8 : Nat
  succ(n7)

Bits : Type
  self(P : (x : Bits) -> Type;) ->
  (be : P(be)) ->
  (b0 : (pred : Bits) -> P(b0(pred))) ->
  (b1 : (pred : Bits) -> P(b1(pred))) ->
  P(self)

be : Bits
  (P;) => (be) => (b0) => (b1) => be

b0 : (bs : Bits) -> Bits
  (bs) => (P;) => (be) => (b0) => (b1) => b0(bs)

b1 : (bs : Bits) -> Bits
  (bs) => (P;) => (be) => (b0) => (b1) => b1(bs)

Word : (size : Nat) -> Type
  (size) =>
  self(P : (size: Nat) -> (x : Word(size)) -> Type;) ->
  (we : P(zero)(we)) ->
  (w0 : (size : Nat;) -> (pred : Word(size)) -> P(succ(size))(w0(size;)(pred))) ->
  (w1 : (size : Nat;) -> (pred : Word(size)) -> P(succ(size))(w1(size;)(pred))) ->
  P(size)(self)

we : Word(zero)
  (P;) => (we) => (w0) => (w1) =>
  we

w0 : (size : Nat;) -> (wo : Word(size)) -> Word(succ(size))
  (size;) => (wo) => (P;) => (we) => (w0) => (w1) =>
  w0(size;)(wo)

w1 : (size : Nat;) -> (wo : Word(size)) -> Word(succ(size))
  (size;) => (wo) => (P;) => (we) => (w0) => (w1) =>
  w1(size;)(wo)

winc : (size: Nat) -> (word: Word(size)) -> Word(size)
  (size) => (word) =>
  let case_we = we
  let case_w0 = (size;) => (pred) => w1(size;)(pred)
  let case_w1 = (size;) => (pred) => w0(size;)(winc(size)(pred))
  let motive  = (size) => (word) => Word(size)
  word(motive;)(case_we)(case_w0)(case_w1)

wadd : (size: Nat;) -> (a: Word(size)) -> (b: Word(size)) -> (c: Bool) -> Word(size)
  (size;) => (a) => (b) => (c) =>

  let case_a_we = (b) => we

  let case_a_w0 = (a_size;) => (a_pred) => (b) =>
    let case_b_we = (a_pred) =>
      we

    let case_b_w0 = (b_size;) => (b_pred) => (a_pred) =>
      // wadd (w0 a_pred) (w0 b_pred) true
      let case_c_tr = w1(b_size;)(wadd(b_size;)(a_pred)(b_pred)(false))
      // wadd (w0 a_pred) (w0 b_pred) false
      let case_c_fa = w0(b_size;)(wadd(b_size;)(a_pred)(b_pred)(false))
      let case_c_ty = (c_bool) => Word(succ(b_size))
      c(case_c_ty;)(case_c_tr)(case_c_fa)

    let case_b_w1 = (b_size;) => (b_pred) => (a_pred) =>
      // wadd (w0 a_pred) (w1 b_pred) true
      let case_c_tr = w0(b_size;)(wadd(b_size;)(a_pred)(b_pred)(true))
      // wadd (w0 a_pred) (w1 b_pred) false
      let case_c_fa = w1(b_size;)(wadd(b_size;)(a_pred)(b_pred)(false))
      let case_c_ty = (c_bool) => Word(succ(b_size))
      c(case_c_ty;)(case_c_tr)(case_c_fa)

    let case_b_ty = (b_size) => (b_word) =>
      (a_pred : Word(pred(b_size))) -> Word(b_size)

    b(case_b_ty;)(case_b_we)(case_b_w0)(case_b_w1)(a_pred)

  let case_a_w1 = (a_size;) => (a_pred) => (b) =>
    let case_b_we = (a_pred) => we

    let case_b_w0 = (b_size;) => (b_pred) => (a_pred) =>
      // wadd (w1 a_pred) (w0 b_pred) true
      let case_c_tr = w0(b_size;)(wadd(b_size;)(a_pred)(b_pred)(true))
      // wadd (w1 a_pred) (w0 b_pred) false
      let case_c_fa = w1(b_size;)(wadd(b_size;)(a_pred)(b_pred)(false))
      let case_c_ty = (c_bool) => Word(succ(b_size))
      c(case_c_ty;)(case_c_tr)(case_c_fa)

    let case_b_w1 = (b_size;) => (b_pred) => (a_pred) =>
      // wadd (w1 a_pred) (w1 b_pred) true
      let case_c_tr = w1(b_size;)(wadd(b_size;)(a_pred)(b_pred)(true))
      // wadd (w1 a_pred) (w1 b_pred) false
      let case_c_fa = w0(b_size;)(wadd(b_size;)(a_pred)(b_pred)(true))
      let case_c_ty = (c_bool) => Word(succ(b_size))
      c(case_c_ty;)(case_c_tr)(case_c_fa)

    let case_b_ty = (b_size) => (b_word) =>
      (a_pred : Word(pred(b_size))) -> Word(b_size)

    b(case_b_ty;)(case_b_we)(case_b_w0)(case_b_w1)(a_pred)

  let case_a_ty = (a_size) => (a_word) =>
    (b : Word(a_size)) -> Word(a_size)

  a(case_a_ty;)(case_a_we)(case_a_w0)(case_a_w1)(b)

main : Word(n4)
  let w0011 = w1(n3;)(w1(n2;)(w0(n1;)(w0(n0;)(we))))
  let w0101 = w1(n3;)(w0(n2;)(w1(n1;)(w0(n0;)(we))))
  wadd(n4;)(w0011)(w0101)(false) // 3 + 5 == 8
