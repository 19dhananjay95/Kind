type Kind.Parser.ADT.Constructor {
  new(
    name: Kind.Name,
    args: List<Kind.Binder>,
    inds: List<Kind.Binder>,
  )
}

type Kind.Parser.ADT.Datatype {
  new(
    name: Kind.Name,
    pars: List<Kind.Binder>,
    inds: List<Kind.Binder>,
    ctrs: List<Kind.Parser.ADT.Constructor>,
    deri: List<String>,
  )
}

type Kind.Parser.ADT.Derived {
  new(
    name: Kind.Name
    arit: Nat
    term: Kind.Term
    type: Kind.Term
  )
}

Kind.Parser.ADT.Datatype.derive(deri: String, adt: Kind.Parser.ADT.Datatype): Maybe<Kind.Parser.ADT.Derived>
  open adt
  switch String.eql(deri) {
    "show": Maybe {
      let name = adt.name | "." | deri
      get term = Kind.Parser.ADT.Datatype.derive_show.term(adt)
      get type = Kind.Parser.ADT.Datatype.derive_show.type(adt)
      return Kind.Parser.ADT.Derived.new(name, 1, term, type)
    }
  } default none

//type Foo {
  //a(n: Nat, a: Foo, b: Foo)
  //b(x: String, y: List<Nat>)
  //c
//}

//(x) case x as x {
  //succ:
    //String.concat("Foo.succ",
    //String.concat(String.concat("(",Nat.show(x.n)),
    //String.concat(String.concat(",",String.show(x.s)),
    //String.concat(String.concat(",",self.show(x.xs)),""))),
    //")")
  //zero: "Foo.zero"
//}

//Foo.show(foo: Foo): String
  //case foo {
    //a: "Foo.a(" | Nat.show(foo.n) | "," | Foo.show(foo.a) | "," | Foo.show(foo.b) | ")"
    //b: "Foo.b(" | String.show(x) | "," | List.show!(Nat.show, y) | ")"
    //c: "Foo.c"
  //}
//cse(
    //path: Bits,
    //expr: Kind.Term,
    //name: Kind.Name,
    //with: List<Kind.Ann>,
    //cses: BitsMap<Kind.Term>,
    //moti: Maybe<Kind.Term>,
  //)

Kind.Parser.ADT.Datatype.derive_show.type(adt: Kind.Parser.ADT.Datatype): Maybe<Kind.Term>
  open adt
  if List.is_empty!(adt.pars) && List.is_empty!(adt.inds) then
    some(Kind.Term.all(false, "", "", Kind.Term.ref(adt.name), (s,x) Kind.Term.ref("String")))
  else
    none

Kind.Parser.ADT.Datatype.derive_show.term(adt: Kind.Parser.ADT.Datatype): Maybe<Kind.Term>
  open adt
  if List.is_empty!(adt.pars) && List.is_empty!(adt.inds) then
    some(Kind.Term.lam("x", (x) 
      let ctrs = Kind.Parser.ADT.Datatype.derive_show.term.ctrs(adt.name, adt.ctrs)
      let cses = Kind.Map.new!
      for ctr in ctrs with cses:
        open ctr
        Kind.Map.set!(ctr.fst, ctr.snd, cses)
      Kind.Term.cse(Bits.e, x, "x", [], cses, none)
    ))
  else
    none

Kind.Parser.ADT.Datatype.derive_show.term.ctrs(adt_name: String, ctrs: List<Kind.Parser.ADT.Constructor>): List<Pair<String,Kind.Term>>
  case ctrs {
    nil:
      []
    cons:
      List.cons!(
        Kind.Parser.ADT.Constructor.derive_show.term(adt_name, ctrs.head),
        Kind.Parser.ADT.Datatype.derive_show.term.ctrs(adt_name, ctrs.tail))
  }

Kind.Parser.ADT.Constructor.derive_show.term(adt_name: String, ctr: Kind.Parser.ADT.Constructor): Pair<String,Kind.Term>
  open ctr
  let func = Kind.Term.str(adt_name | "." | ctr.name)
  case ctr.args {
    nil: 
      {ctr.name, func}
    cons: 
      let args = Kind.Parser.ADT.Constructor.derive_show.term.args(ctr.args, true)
      let term = List.fold!(args)!(Kind.Term.str(")"), (x,t) Kind.Term.app(Kind.Term.app(Kind.Term.ref("String.concat"), x), t))
      let term = Kind.Term.app(Kind.Term.app(Kind.Term.ref("String.concat"), func), term)
      {ctr.name, term}
  }

Kind.Parser.ADT.Constructor.derive_show.term.cont(call: Kind.Term): Kind.Term
  let {call_func, call_args} = Kind.Term.get_args(call)
  let term = Kind.Term.ref(Kind.Term.extract_name(call_func) | ".show")
  let term = for par in call_args: Kind.Term.app(term, Kind.Term.hol(Bits.e))
  let term = for par in call_args: Kind.Term.app(term, Kind.Parser.ADT.Constructor.derive_show.term.cont(par))
  term

Kind.Parser.ADT.Constructor.derive_show.term.args(args: List<Kind.Binder>, fst: Bool): List<Kind.Term>
  case args {
    nil:
      []
    cons:
      open args.head
      //log(Kind.Term.show(args.head.term))
      let {call_func, call_args} = Kind.Term.get_args(args.head.term)
      //log("-> " | Kind.Term.show(call_func) | " ... " | String.join(",", List.mapped!(call_args)!(Kind.Term.show)))
      let term = Kind.Parser.ADT.Constructor.derive_show.term.cont(args.head.term)
      //let term = for par in call_args: Kind.Term.app(term, Kind.Term.hol(Bits.e))
      //let term = for par in call_args: Kind.Term.app(term, Kind.Term.ref(Kind.Term.extract_name(par) | ".show"))
      let term = Kind.Term.app(term, Kind.Term.ref("x." | args.head.name))
      let term = Kind.Term.app(Kind.Term.app(Kind.Term.ref("String.concat"), Kind.Term.str(if fst then "(" else ",")), term)
      List.cons!(term, Kind.Parser.ADT.Constructor.derive_show.term.args(args.tail, false))
  }
  
Kind.Parser.ADT.adt: Parser(Kind.Parser.ADT.Datatype)
  Parser {
    Kind.Parser.text("type ")
    get name = Kind.Parser.name1
    get pars = Parser.maybe!(Kind.Parser.binder(":"))
    get inds = Parser.maybe!(Parser {
      Kind.Parser.text("~")
      Kind.Parser.binder(":")
    })
    let pars = Maybe.default!(pars, [])
    let inds = Maybe.default!(inds, [])
    get ctrs = Kind.Parser.items!("{", Kind.Parser.ADT.ctor(name), "}")
    get deri = Parser.maybe!(Parser {
      Kind.Parser.text("deriving")
      Kind.Parser.items!("(", Kind.Parser.name1, ")")
    })
    let deri = case deri {
      none: []
      some: deri.value
    }
    return Kind.Parser.ADT.Datatype.new(name, pars, inds, ctrs, deri)
  }

Kind.Parser.ADT.ctor(namespace: Kind.Name): Parser(Kind.Parser.ADT.Constructor)
  Parser {
    get name = Kind.Parser.name1
    get args = Parser.maybe!(Kind.Parser.binder(":"))
    get inds = Parser.maybe!(Parser {
      Kind.Parser.text("~")
      Kind.Parser.binder("=")
    })
    let args = Maybe.default!(args, [])
    let inds = Maybe.default!(inds, [])
    return Kind.Parser.ADT.Constructor.new(name, args, inds)
  }

Kind.Parser.ADT.Constructor.build_term(type: Kind.Parser.ADT.Datatype, ctor: Kind.Parser.ADT.Constructor): Kind.Term
  open type
  open ctor
  Kind.Parser.ADT.Constructor.build_term.go(type, ctor, type.name, type.pars, ctor.args)
  
Kind.Parser.ADT.Constructor.build_term.go(
  type: Kind.Parser.ADT.Datatype,
  ctor: Kind.Parser.ADT.Constructor,
  name: Kind.Name,
  pars: List<Kind.Binder>,
  args: List<Kind.Binder>,
): Kind.Term
  case pars {
    cons: case pars.head {
      new:
        def par_name = pars.head.name
        def par_body = (x) Kind.Parser.ADT.Constructor.build_term.go(type, ctor, name, pars.tail, args)
        Kind.Term.lam(par_name, par_body)
    }
    nil: case args {
      cons: case args.head {
        new:
          def ctr_name = args.head.name
          def ctr_body = (x) Kind.Parser.ADT.Constructor.build_term.go(type, ctor, name, pars, args.tail)
          Kind.Term.lam(ctr_name, ctr_body)
      },
      nil:
        def lam_name = Kind.Name.read("P")
        def lam_body = (x) Kind.Parser.ADT.Constructor.build_term.opt(type, ctor)
        Kind.Term.lam(lam_name, lam_body)
    }
  }

Kind.Parser.ADT.Constructor.build_term.opt(type: Kind.Parser.ADT.Datatype, ctor: Kind.Parser.ADT.Constructor): Kind.Term
  open type
  Kind.Parser.ADT.Constructor.build_term.opt.go(type, ctor, type.ctrs)

Kind.Parser.ADT.Constructor.build_term.opt.go(
  type: Kind.Parser.ADT.Datatype,
  ctor: Kind.Parser.ADT.Constructor,
  ctrs: List<Kind.Parser.ADT.Constructor>,
): Kind.Term
  case ctrs {
    cons: case ctrs.head {
      new:
        def name = ctrs.head.name
        def body = (x) Kind.Parser.ADT.Constructor.build_term.opt.go(type, ctor, ctrs.tail)
        Kind.Term.lam(name, body)
    }
    nil: 
      case ctor {
        new:
          let ret = Kind.Term.ref(ctor.name)
          let ret = for arg in ctor.args:
            Kind.Term.app(ret, Kind.Term.ref(case arg { new: arg.name }))
          ret
      }
  }

Kind.Parser.ADT.Constructor.build_type(type: Kind.Parser.ADT.Datatype, ctor: Kind.Parser.ADT.Constructor): Kind.Term
  case type {
    new: case ctor {
      new: Kind.Parser.ADT.Constructor.build_type.go(
        type,
        ctor,
        type.name,
        type.pars,
        ctor.args)
    }
  }

Kind.Parser.ADT.Constructor.build_type.go(
  type: Kind.Parser.ADT.Datatype,
  ctor: Kind.Parser.ADT.Constructor,
  name: Kind.Name,
  pars: List<Kind.Binder>,
  args: List<Kind.Binder>,
): Kind.Term
  case pars {
    cons: case pars.head {
      new:
        def pars_eras = pars.head.eras;
        def pars_name = pars.head.name;
        def pars_xtyp = pars.head.term;
        def pars_body = (s,x) Kind.Parser.ADT.Constructor.build_type.go(type, ctor, name, pars.tail, args);
        Kind.Term.all(pars_eras, "", pars_name, pars_xtyp, pars_body),
    },
    nil: case args {
      cons: case args.head {
        new:
          def ctr_eras = args.head.eras;
          def ctr_name = args.head.name;
          def ctr_xtyp = args.head.term;
          def ctr_body = (s,x) Kind.Parser.ADT.Constructor.build_type.go(type, ctor, name, pars, args.tail);
          Kind.Term.all(ctr_eras, "", ctr_name, ctr_xtyp, ctr_body),
      },
      nil: case type {
        new: case ctor {
          new:
            let type = Kind.Term.ref(name);
            let type = for v in type.pars:
              Kind.Term.app(type, Kind.Term.ref(case v { new: v.name }));
            let type = for v in ctor.inds:
              Kind.Term.app(type, case v { new: v.term });
            type,
        }
      }
    }
  }

Kind.Parser.ADT.Datatype.build_term(type: Kind.Parser.ADT.Datatype): Kind.Term
  case type {
    new: Kind.Parser.ADT.Datatype.build_term.go(type, type.name, type.pars, type.inds),
  }

Kind.Parser.ADT.Datatype.build_term.go(
  type: Kind.Parser.ADT.Datatype,
  name: Kind.Name,
  pars: List<Kind.Binder>,
  inds: List<Kind.Binder>,
): Kind.Term
  case pars {
    cons:
      open pars.head
      def par_name = pars.head.name
      def par_body = (x) Kind.Parser.ADT.Datatype.build_term.go(type, name, pars.tail, inds)
      Kind.Term.lam(par_name, par_body)
    nil: case inds {
      cons:
        open inds.head
        def ind_name = inds.head.name
        def ind_body = (x) Kind.Parser.ADT.Datatype.build_term.go(type, name, pars, inds.tail)
        Kind.Term.lam(ind_name, ind_body)
      nil: 
        def moti = Kind.Parser.ADT.Datatype.build_term.motive(type)
        def body = (s,x) Kind.Parser.ADT.Datatype.build_term.constructors(type) // TODO
        Kind.Term.all(Bool.true, String.concat(name,".Self"), Kind.Name.read("P"), moti, body)
    }
  }

Kind.Parser.ADT.Datatype.build_term.constructor(type: Kind.Parser.ADT.Datatype, ctor: Kind.Parser.ADT.Constructor): Kind.Term
  open ctor
  Kind.Parser.ADT.Datatype.build_term.constructor.go(type, ctor, ctor.args)

Kind.Parser.ADT.Datatype.build_term.constructor.go(
  type: Kind.Parser.ADT.Datatype,
  ctor: Kind.Parser.ADT.Constructor,
  args: List<Kind.Binder>,
): Kind.Term
  case args {
    cons:
      open args.head
      let eras = args.head.eras
      let name = args.head.name
      let xtyp = args.head.term
      let body = Kind.Parser.ADT.Datatype.build_term.constructor.go(type, ctor, args.tail)
      Kind.Term.all(eras, "", name, xtyp, (s,x) body)
    nil:
      open type
      open ctor
      let ret = Kind.Term.ref(Kind.Name.read("P"))
      let ret = for v in ctor.inds:
        Kind.Term.app(ret, case v { new: v.term })
      let ctr = String.flatten([type.name,Kind.Name.read("."),ctor.name])
      let slf = Kind.Term.ref(ctr)
      let slf = for v in type.pars:
        Kind.Term.app(slf, Kind.Term.ref(case v { new: v.name }))
      let slf = for v in ctor.args:
        Kind.Term.app(slf, Kind.Term.ref(case v { new: v.name }))
      Kind.Term.app(ret, slf)
  }

Kind.Parser.ADT.Datatype.build_term.constructors(type: Kind.Parser.ADT.Datatype): Kind.Term
  open type
  Kind.Parser.ADT.Datatype.build_term.constructors.go(type, type.name, type.ctrs)

Kind.Parser.ADT.Datatype.build_term.constructors.go(
  type: Kind.Parser.ADT.Datatype,
  name: Kind.Name,
  ctrs: List<Kind.Parser.ADT.Constructor>,
): Kind.Term
  case ctrs {
    cons:
      open ctrs.head
      Kind.Term.all(Bool.false, "",
        ctrs.head.name,
        Kind.Parser.ADT.Datatype.build_term.constructor(type, ctrs.head),
        (s,x) Kind.Parser.ADT.Datatype.build_term.constructors.go(type, name, ctrs.tail))
    nil:
      open type
      let ret = Kind.Term.ref(Kind.Name.read("P"));
      let ret = for v in type.inds:
        Kind.Term.app(ret, Kind.Term.ref(case v { new: v.name }));
      Kind.Term.app(ret, Kind.Term.ref(String.concat(name,".Self")))
  }

Kind.Parser.ADT.Datatype.build_term.motive(
  type: Kind.Parser.ADT.Datatype,
): Kind.Term
  open type
  Kind.Parser.ADT.Datatype.build_term.motive.go(type, type.name, type.inds)

Kind.Parser.ADT.Datatype.build_term.motive.go(
  type: Kind.Parser.ADT.Datatype,
  name: Kind.Name,
  inds: List<Kind.Binder>,
): Kind.Term
  case inds {
    cons:
      open inds.head
      def ind_eras = inds.head.eras
      def ind_name = inds.head.name
      def ind_xtyp = inds.head.term
      def ind_body = (s,x) Kind.Parser.ADT.Datatype.build_term.motive.go(type, name, inds.tail)
      Kind.Term.all(ind_eras, "", ind_name, ind_xtyp, ind_body)
    nil:
      open type
      let slf = Kind.Term.ref(name)
      let slf = for v in type.pars:
        Kind.Term.app(slf, Kind.Term.ref(case v { new: v.name }))
      let slf = for v in type.inds:
      Kind.Term.app(slf, Kind.Term.ref(case v { new: v.name }))
      Kind.Term.all(Bool.false, "", "", slf, (s,x) Kind.Term.typ)
  }

Kind.Parser.ADT.Datatype.build_type(type: Kind.Parser.ADT.Datatype): Kind.Term
  case type {
    new: Kind.Parser.ADT.Datatype.build_type.go(type, type.name, type.pars, type.inds),
  }

Kind.Parser.ADT.Datatype.build_type.go(
  type: Kind.Parser.ADT.Datatype,
  name: Kind.Name,
  pars: List<Kind.Binder>,
  inds: List<Kind.Binder>,
): Kind.Term
  case pars {
    cons: case pars.head {
      new:
        def par_eras = pars.head.eras;
        def par_name = pars.head.name;
        def par_xtyp = pars.head.term;
        def par_body = (s,x) Kind.Parser.ADT.Datatype.build_type.go(type, name, pars.tail, inds);
        Kind.Term.all(Bool.false, "", par_name, par_xtyp, par_body)
    },
    nil: case inds {
      cons: case inds.head {
        new: 
          def ind_eras = inds.head.eras;
          def ind_name = inds.head.name;
          def ind_xtyp = inds.head.term;
          def ind_body = (s,x) Kind.Parser.ADT.Datatype.build_type.go(type, name, pars, inds.tail);
          Kind.Term.all(Bool.false, "", ind_name, ind_xtyp, ind_body)
      },
      nil: Kind.Term.typ,
    }
  }


//Kind.Parser.ADT.Datatype.derive_show.type(adt: Kind.Parser.ADT.Datatype): Maybe<Kind.Term>
  //open adt
  //Kind.Parser.ADT.Datatype.derive_show.type.poly_typs(adt, adt.pars)

//Kind.Parser.ADT.Datatype.derive_show.type.poly_typs(adt: Kind.Parser.ADT.Datatype, pars: List<Kind.Binder>): Maybe<Kind.Term>
  //open adt
  //case pars {
    //nil:
      //Kind.Parser.ADT.Datatype.derive_show.type.poly_shows(adt, adt.pars)
    //cons:
      //open pars.head
      //case Kind.Term.reduce(pars.head.term, Kind.Map.new!) as poly_typ {
        //typ: Maybe {
          //get rest = Kind.Parser.ADT.Datatype.derive_show.type.poly_typs(adt, pars.tail)
          //return Kind.Term.all(true, "", pars.head.name, Kind.Term.typ, (s,x) rest)
        //}
      //} default none
  //}
  
//Kind.Parser.ADT.Datatype.derive_show.type.poly_shows(adt: Kind.Parser.ADT.Datatype, pars: List<Kind.Binder>): Maybe<Kind.Term>
  //open adt
  //case pars {
    //nil: 
      //some(Kind.Term.all(false, "", "", Kind.Term.ref(adt.name), (s,x) Kind.Term.ref("String")))
    //cons:
      //open pars.head
      //let rest = Kind.Parser.ADT.Datatype.derive_show.type.poly_shows(adt, pars.tail)
      //case rest {
        //none: none
        //some: some(Kind.Term.all(false, "", "", Kind.Term.ref(pars.head.name|".show"), (s,x) rest.value))
      //}
  //}

//Kind.Parser.ADT.Datatype.derive_show.term(adt: Kind.Parser.ADT.Datatype): Maybe<Kind.Term>
  //open adt
  //some(Kind.Parser.ADT.Datatype.derive_show.term.poly_typs(adt, adt.pars))

//Kind.Parser.ADT.Datatype.derive_show.term.poly_typs(adt: Kind.Parser.ADT.Datatype, pars: List<Kind.Binder>): Kind.Term
  //open adt
  //case pars {
    //nil: Kind.Parser.ADT.Datatype.derive_show.term.poly_shows(adt, adt.pars)
    //cons:
      //open pars.head
      //Kind.Term.lam(pars.head.name, (x) Kind.Parser.ADT.Datatype.derive_show.term.poly_typs(adt, pars.tail))
  //}

//Kind.Parser.ADT.Datatype.derive_show.term.poly_shows(adt: Kind.Parser.ADT.Datatype, pars: List<Kind.Binder>): Kind.Term
  //open adt
  //case pars {
    //nil: 
      //Kind.Term.lam("x", (x) 
        //let ctrs = Kind.Parser.ADT.Datatype.derive_show.term.ctrs(adt.name, adt.ctrs)
        //let cses = Kind.Map.new!
        //for ctr in ctrs with cses:
          //open ctr
          //Kind.Map.set!(ctr.fst, ctr.snd, cses)
        //Kind.Term.cse(Bits.e, x, "x", [], cses, none))
    //cons:
      //open pars.head
      //Kind.Term.lam(pars.head.name|".show", (x) Kind.Parser.ADT.Datatype.derive_show.term.poly_shows(adt, pars.tail))
  //}
