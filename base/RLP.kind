// The RLP format
// 
// Serialization and deserialization for the BytesTree type, under the following grammar:
// | First byte | Meaning                                                                    |
// | ---------- | -------------------------------------------------------------------------- |
// | 0   to 127 | HEX(leaf)                                                                  |
// | 128 to 183 | HEX(length_of_leaf + 128) + HEX(leaf)                                      |
// | 184 to 191 | HEX(length_of_length_of_leaf + 128 + 56) + HEX(length_of_leaf) + HEX(leaf) |
// | 192 to 247 | HEX(length_of_node + 192) + HEX(node)                                      |
// | 248 to 255 | HEX(length_of_length_of_node + 192 + 56) + HEX(length_of_node) + HEX(node) |
// 
// The first byte of RLP.encode.length
// buffer length (len) | RLP.encode.length(add,len)[0]
// ------------------- | -----------------------------
// 56     ~ 256**1-1   | 185
// 256**1 ~ 256**2-1   | 186
// 256**2 ~ 256**3-1   | 187
// 256**3 ~ 256**4-1   | 188
// 256**4 ~ 256**5-1   | 189
// 256**5 ~ 256**6-1   | 190
// 256**6 ~ 256**7-1   | 191

// Type
// ----

type RLP {
  data(value: List<U8>)
  node(child: List<RLP>)
}

RLP.show(r: RLP): String
  case r {
    data:
      Bytes.to_hex(r.value)
    node:
      let ret = "["
      for child in r.child with ret:
        ret|RLP.show(child)|","
      ret|"]"
  }

// Length
// ------

RLP.encode.length(add: Nat, length: Nat): Bytes
  if Nat.lte(length, 55) then
    [Nat.to_u8(Nat.add(add,length))]
  else
    let b = Bytes.from_nat(length)
    let a = Nat.to_u8(Nat.add(56, Nat.add(add, List.length!(b))))
    a & b

RLP.split.length(add: Nat, bytes: Bytes): Pair<Bytes, Bytes>
  case bytes {
    nil:
      {[], []}
    cons:
      let fst = Nat.sub(U8.to_nat(bytes.head), add)
      if Nat.lte(fst, 55) then
        Bytes.split(bytes.tail, fst)
      else
        let {length, tail} = Bytes.split(bytes.tail, Nat.sub(fst, 56))
        Bytes.split(tail, Bytes.to_nat(length))
  }

// Repeat
// ------
RLP.encode.many(trees: List<RLP>): Bytes
  case trees {
    nil:
      []
    cons:
      List.concat!(RLP.encode(trees.head), RLP.encode.many(trees.tail))
  }

// RLP
// ---

RLP.encode(tree: RLP): Bytes
  case tree {
    data:
      if Bool.and(Nat.eql(List.length!(tree.value),1), Nat.lte(U8.to_nat((List.head_with_default!(0#8,tree.value))), 127)) then
        tree.value
      else
        List.concat!(RLP.encode.length(128, List.length!(tree.value)), tree.value)
    node:
      let rest = RLP.encode.many(tree.child)
      List.concat!(RLP.encode.length(192, List.length!(rest)), rest)
  }
  
RLP.decode.many(bytes: Bytes): List<RLP>
  case bytes {
    nil:
      []
    cons:
      let prefix = U8.to_nat(bytes.head)
      if Nat.lte(prefix, 127) then
        RLP.data([bytes.head]) & RLP.decode.many(bytes.tail)
      else if Nat.lte(prefix, 191) then
        let {head, tail} = RLP.split.length(128, bytes)
        RLP.data(head) & RLP.decode.many(tail)
      else
        let {head, tail} = RLP.split.length(192, bytes)
        RLP.node(RLP.decode.many(head)) & RLP.decode.many(tail)
  }

RLP.max: Nat
  Nat.pred(Nat.pow(256, 7))

RLP.decode(bytes: Bytes): RLP
  List.head!(RLP.decode.many(bytes)) <> RLP.data([])
