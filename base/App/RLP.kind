App.RLP.article: DOM
  <article> 
  <h3>` Kind is amazing ^-^ `</h3>
  <p>`
  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
  incididunt ut labore et dolore magna aliqua. Nibh ipsum consequat nisl vel
  pretium lectus quam id. Tempor orci eu lobortis elementum nibh. Nulla facilisi
  cras fermentum odio eu feugiat. Est velit egestas dui id. Blandit aliquam
  etiam erat velit. 
  `</p>
  <p>`
  Donec ultrices tincidunt arcu non. Eu nisl nunc mi ipsum faucibus vitae
  aliquet nec. Duis tristique sollicitudin nibh sit amet commodo nulla facilisi
  nullam. Malesuada bibendum arcu vitae elementum curabitur vitae nunc sed
  velit. Nullam eget felis eget nunc lobortis mattis aliquam faucibus purus. 
  `
  </p>
  </article>

App.RLP.State: App.State
  App.State.new(App.RLP.State.Local, App.RLP.State.Global)

App.RLP.State.Global: Type
  Unit

type App.RLP.State.Local {
  new(
    input: String
    output: String
    mode: App.RLP.Mode
    dirty: Bool
    error: Maybe<DOM>
  )
}

type App.RLP.Mode {
  encoding
  decoding
}

App.RLP.Mode.toggle(m: App.RLP.Mode): App.RLP.Mode
  case m {
    encoding: App.RLP.Mode.decoding
    decoding: App.RLP.Mode.encoding
  }

App.RLP.State.Local.default: App.RLP.State.Local
  let input = `["hihi"]`
  let output = 
    case Parser.run!(Ether.RLP.parser, input) {
      none: ""
      some: Bytes.to_hex(Ether.RLP.encode(self.value))
    }
  App.RLP.State.Local.new(
    input
    output
    App.RLP.Mode.encoding
    false
    none
  )

App.RLP.css: String
  `
    .error {
      color: red;
    }
    .center-box {
      margin: auto;
      max-width: 512px;
    }
    main > * {
      margin-bottom: 1em;
    }
    main hr {
      border-color: #FDFDFD;
    }
    .page-block {
      width: 100%;
      padding: 16px;
    }
    .page-block.bg {
      border-radius: 8px;
      background-color: #F2F2F2;
    }
    .page-block.bg.bytes {
      background-color: #333333;
    }
    .page-block > * {
      margin: 0.5em 0;
    }
    .block-label {
      font-weight: bold;
    }
    .text-input {
      width: 100%;
      min-height: 8em;
    }
    .text-output {
      background-color: #FDFDFD;
      padding: 1em;
    }
    .text-output.dirty {
      color: #A0A0A0;
    }
    .button-wrapper {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
    }
    .button-wrapper button {
      padding: 0.5em 1em;
    }
    article * {
      margin-bottom: 1em;
    }
    footer {
      display: flex;
      justify-content: space-between;
      padding: 2em 1em;
    }
  `

App.RLP.Mode.present(m: App.RLP.Mode): String
  case m {
    encoding:
      "RLP"
    decoding:
      "Bytes"
  }

App.RLP.input_background(m: App.RLP.Mode, classes: String): String
  case m {
    encoding:
      classes
    decoding:
      classes | " bytes"
  }

App.RLP.draw(state: App.RLP.State.Local): DOM
  open state
  def toggle = App.RLP.Mode.toggle
  let style_top = App.RLP.input_background(state.mode)
  let style_bottom = App.RLP.input_background(toggle(state.mode))
  <div>
  <style> App.RLP.css </style>
  <main class="center-box">
    <div class="page-block">
      <h1> "RLP encoder/decoder" </h1>
      <p class="subtitle">
        "Formally verified with "
        <a href="https://github.com/kind-lang/Kind">
        "Kind"
        </a>
        "!"
      </p>
    </div>
    <div class=style_top("page-block bg")>
      <p class=style_top("block-label")>
        App.RLP.Mode.present(state.mode)
      </p>
      <textarea id="input" class="text-input">
        state@input
      </textarea>
      <div class="button-wrapper">
        <button id="btn-switch">
          "Switch"
        </button>
        <button id="btn-translate">
          case state.mode {
            encoding: "Encode"
            decoding: "Decode"
          }
        </button>
      </div>
      <p class="error">{
        case state.error {
          none: <p></p>
          some: state.error.value
        }
      }</p>
    </div>
    <div class=style_bottom("page-block bg")>
      <p class=style_bottom("block-label")>
        App.RLP.Mode.present(toggle(state.mode))
      </p>
      <p 
        class= "text-output " | if state@dirty then "dirty" else ""
        >
        state@output
      </p>
    </div>
    <hr></hr>
    <div class="page-block bg">
      { App.RLP.article }
    </div>
  </main>
  <footer class="center-box">
    <div id="join-us">
      <p><strong>` Join Us `</strong></p>
      <p><a href="https://github.com/kind-lang/Kind">
        `Github`
      </a></p>
      <p><a href="https://t.me/formality_lang">
        `Telegram`
      </a></p>
    </div>
    <div>
      `made with ‚ù§ using `
      <a href="https://github.com/kind-lang/Kind">
        `Kind-lang`
      </a>
      // ` by ??`
    </div>
  </footer>
  </div>

App.RLP.parser: Parser(Ether.RLP)
  Parser {
    get rlp = Ether.RLP.parser
    Kind.Parser.spaces
    Parser.eof
    return rlp
  }

App.RLP.parser.bytes: Parser(Bytes)
  Parser {
    get bytes = Ether.RLP.parser.bytes
    Kind.Parser.spaces
    Parser.eof
    return bytes
  }

App.RLP.IO: Type
  IO<Maybe<App.State.local(App.RLP.State)>>

App.RLP.when(
  event: App.Event
  store: App.Store<App.RLP.State>
): App.RLP.IO
  let state = store@local
  case event {
    input:
      switch String.eql(event.id) {
        "input":
          let state = state@input <- event.text
          let state = state@dirty <- true
          App.set_local!(state)
      } default App.pass!
    mouse_click:
      switch String.eql(event.id) {
        "btn-translate":
          let state =
            case state@mode {
              encoding:
                case App.RLP.parser(Parser.State.from_code(state@input)) as parsed_rlp {
                  error:
                    let state = state@error <- some(Parser.Error.to_dom(state@input, parsed_rlp.err))
                    let state = state@dirty <- true
                    state
                  value:
                    let state = state@error <- none
                    let state = state@dirty <- false
                    let state = state@output <- App.RLP.encode(parsed_rlp.val)
                    state
                }
              decoding:
                case App.RLP.parser.bytes(Parser.State.from_code(state@input)) as parsed_bytes {
                  error:
                    let state = state@error <- some(Parser.Error.to_dom(state@input, parsed_bytes.err))
                    let state = state@dirty <- true
                    state
                  value:
                    case Ether.RLP.decode.check(parsed_bytes.val) {
                      true:
                        let state = state@error <- none
                        let state = state@dirty <- false
                        let state = state@output <- App.RLP.decode(parsed_bytes.val)
                        state
                      false:
                        let state = state@error <- some(<p>"Error: invalid remainder"</p>)
                        let state = state@dirty <- true
                        state
                    }
                }
            }
          App.set_local!(state)
        "btn-switch":
          let state = state@error <- none
          let state = state@mode <- App.RLP.Mode.toggle(state@mode)
          let state = state@dirty <- true
          App.set_local!(state)
      } default App.pass!
  } default App.pass!

App.RLP.decode(input:Bytes): String
  Ether.RLP.show(Ether.RLP.decode(input))

App.RLP.encode(input: Ether.RLP): String
  Bytes.to_hex(Ether.RLP.encode(input))

App.RLP: App(App.RLP.State)
  let init =
    App.Store.new!(
      App.RLP.State.Local.default
      Unit.new
    )
  def St = App.RLP.State
  let draw = (state) App.RLP.draw(state@local)
  let when = App.RLP.when
  let tick = App.no_tick<St>
  let post = App.no_post<St>
  App.new!(init, draw, when, tick, post)
