// ANIMATIONS
// ==========================
type App.KL.Game.Assets.Animation {
  new(
    frames: List<String>
    actual_frame: Nat
    init_loop: Nat
    end_loop:  Nat 
    seconds_per_frame: Nat
    when_end: Maybe<App.KL.Game.State.Local -> App.KL.Game.State.Local>
    active: Bool
  )
}

App.KL.Game.Assets.Animation.update_map(
  animations: Map<App.KL.Game.Assets.Animation>
): Map<App.KL.Game.Assets.Animation>
  for id:animation in animations with animations:
    let animation = App.KL.Game.Assets.Animation.increment_frame(animation)
    animations{id} <- animation
  animations

App.KL.Game.Assets.Animation.update_local(
  animations: Map<App.KL.Game.Assets.Animation>
  local: App.KL.Game.State.Local
): App.KL.Game.State.Local
  for id:animation in animations with local:
    let actual_frame = animation@actual_frame
    let end_frame    = App.KL.Game.Assets.Animation.get_limit(animation)
    
    if actual_frame =? end_frame then
      let action = animation@when_end
      case action {
        none: local
        some: action.value(local)
      }
    else
      local
  local

App.KL.Game.Assets.Animation.increment_frame(
  animation: App.KL.Game.Assets.Animation
): App.KL.Game.Assets.Animation
  let {init_loop_frame, end_loop_frame} = App.KL.Game.Assets.Animation.get_loop_bounds(animation)
  let actual_frame = animation@actual_frame
  let end_frame    = App.KL.Game.Assets.Animation.get_limit(animation)
  let active       = animation@active

  let animation = 
    if actual_frame =? end_loop_frame then
      if active then
        animation@actual_frame <- init_loop_frame
      else
        if actual_frame =? end_frame then
          animation
        else 
          animation@actual_frame <- actual_frame + 1
    else
      animation@actual_frame <- actual_frame + 1
  
  animation

App.KL.Game.Assets.Animation.get_actual_img(
  animation: App.KL.Game.Assets.Animation
): Maybe<String>
  let actual_frame = animation@actual_frame
  let index = Nat.div(actual_frame, animation@seconds_per_frame)
  List.get!(index, animation@frames)

App.KL.Game.Assets.Animation.get_loop_bounds(
  animation: App.KL.Game.Assets.Animation
): Pair<Nat, Nat>
  let seconds_per_frame = animation@seconds_per_frame
  let initial = animation@init_loop
  let initial = initial * seconds_per_frame

  let final   = animation@end_loop
  let final   = ((final + 1) * seconds_per_frame) - 1

  {initial, final}

App.KL.Game.Assets.Animation.get_limit(
  animation: App.KL.Game.Assets.Animation
): Nat
  (List.length!(animation@frames) * animation@seconds_per_frame) - 1

App.KL.Game.Assets.Animation.deactivate(
  animation: App.KL.Game.Assets.Animation
): App.KL.Game.Assets.Animation
  let animation = animation@active <- false
  let animation = animation@actual_frame <- 0
  animation

// BUTTON CLICK
// ==========================
type App.KL.Game.Assets.ButtonClick.Image {
  new(
    normal: String,
    hover: String,
    click: String
  )
}

type App.KL.Game.Assets.ButtonClick {
  new(image: App.KL.Game.Assets.ButtonClick.Image, hovered: Bool, clicked: Bool)
}

App.KL.Game.Assets.ButtonClick.generate(
  image: App.KL.Game.Assets.ButtonClick.Image
): App.KL.Game.Assets.ButtonClick
  App.KL.Game.Assets.ButtonClick.new(image, false, false)

App.KL.Game.Assets.ButtonClick.get_img(
  button: App.KL.Game.Assets.ButtonClick
): String
  if button@clicked then
    button@image@click
  else
    if button@hovered then
      button@image@hover
    else
      button@image@normal