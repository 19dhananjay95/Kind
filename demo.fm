type Bool {
  true,
  false,
}

type Bit {
  0,
  1,
}

type Bits {
  nil,
  0(pred: Bits),
  1(pred: Bits),
}

type Nat {
  zero,
  succ(pred: Nat),
}

type Word ~ (size: Nat) {
  nil                            ~ (size: Nat.zero),
  0<size: Nat>(pred: Word(size)) ~ (size: Nat.succ(size)),
  1<size: Nat>(pred: Word(size)) ~ (size: Nat.succ(size)),
}

type U16 {
  new(value: Word(16))
}

Char: Type
  U16

type String {
  nil,
  cons(head: Char, tail: String),
}

not(x: Bool): Bool
  case x {
    true: Bool.false,
    false: Bool.true,
  }

double(x: Nat): Nat
  case x {
    zero: Nat.zero,
    succ: Nat.succ(Nat.succ(double(x.pred))),
  }

Word.from_bits(size: Nat, bits: Bits): Word(size)
  case size {
    zero: Word.nil,
    succ: case bits {
      nil: Word.0<size.pred>(Word.from_bits(size.pred, Bits.nil)),
       0 : Word.0<size.pred>(Word.from_bits(size.pred, bits.pred)),
       1 : Word.1<size.pred>(Word.from_bits(size.pred, bits.pred))
    } : Word(Nat.succ(size.pred))
  } : Word(size.self)

Char.new(
  b0: Bit, b1: Bit, b2: Bit, b3: Bit,
  b4: Bit, b5: Bit, b6: Bit, b7: Bit,
  b8: Bit, b9: Bit, bA: Bit, bB: Bit,
  bC: Bit, bD: Bit, bE: Bit, bF: Bit,
): U16
  let kF = b0<(x) Word( 0) -> Word( 1)>(Word.0<_>, Word.1<_>);
  let kE = b1<(x) Word( 1) -> Word( 2)>(Word.0<_>, Word.1<_>);
  let kD = b2<(x) Word( 2) -> Word( 3)>(Word.0<_>, Word.1<_>);
  let kC = b3<(x) Word( 3) -> Word( 4)>(Word.0<_>, Word.1<_>);
  let kB = b4<(x) Word( 4) -> Word( 5)>(Word.0<_>, Word.1<_>);
  let kA = b5<(x) Word( 5) -> Word( 6)>(Word.0<_>, Word.1<_>);
  let k9 = b6<(x) Word( 6) -> Word( 7)>(Word.0<_>, Word.1<_>);
  let k8 = b7<(x) Word( 7) -> Word( 8)>(Word.0<_>, Word.1<_>);
  let k7 = b8<(x) Word( 8) -> Word( 9)>(Word.0<_>, Word.1<_>);
  let k6 = b9<(x) Word( 9) -> Word(10)>(Word.0<_>, Word.1<_>);
  let k5 = bA<(x) Word(10) -> Word(11)>(Word.0<_>, Word.1<_>);
  let k4 = bB<(x) Word(11) -> Word(12)>(Word.0<_>, Word.1<_>);
  let k3 = bC<(x) Word(12) -> Word(13)>(Word.0<_>, Word.1<_>);
  let k2 = bD<(x) Word(13) -> Word(14)>(Word.0<_>, Word.1<_>);
  let k1 = bE<(x) Word(14) -> Word(15)>(Word.0<_>, Word.1<_>);
  let k0 = bF<(x) Word(15) -> Word(16)>(Word.0<_>, Word.1<_>);
  let kx = Word.nil;
  U16.new(k0(k1(k2(k3(k4(k5(k6(k7(k8(k9(kA(kB(kC(kD(kE(kF(kx)))))))))))))))))


Nat.add(n: Nat, m: Nat): Nat
  case n {
    zero: m,
    succ: Nat.succ(Nat.add(n.pred, m)),
  }

Nat.sum(n: Nat): Nat
  case n {
    zero: Nat.zero,
    succ: Nat.add(n, Nat.sum(n.pred)),
  }

demo: String
  Nat.show(Nat.sum(100))
