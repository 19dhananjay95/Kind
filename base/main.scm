; Short alias to vector-ref
(define get vector-ref)

; Converts a Kind word to a native integer
(define (word-to-u16 w)
  (define (word-to-u16-go i w x)
    (cond ((= 16 i) x)
      ((eq? 'Word.e (get w 0)) (word-to-u16-go (+ i 1) (vector 'Word.e) x))
      ((eq? 'Word.o (get w 0)) (word-to-u16-go (+ i 1) (get w 1) x))
      ((eq? 'Word.i (get w 0)) (word-to-u16-go (+ i 1) (get w 1) (fxior x (fxarithmetic-shift-left 1 i))))))
  (word-to-u16-go 0 w 0))

; Converts a native integer to a Kind word
(define (u16-to-word x)
  (define (u16-to-word-go i x w)
    (if (= 16 i) w (u16-to-word-go (+ i 1) x
      (if (= (fxand (fxarithmetic-shift-right x (- 15 i)) 1) 0)
        (vector 'Word.o w)
        (vector 'Word.i w)))))
  (u16-to-word-go 0 x (vector 'Word.e)))

; Joins a list of strings with an intercalated separator
(define (string_join sep strs fst)
  (if (null? strs) 
    ""
    (string-append
      (if fst "" sep)
      (car strs)
      (string_join sep (cdr strs) #f))))

; Returns the last index that chr occurs in str, -1 otherwise
(define (last_index_of chr str idx)
  (if (eq? idx (string-length str))
    -1
    (let ((rest (last_index_of chr str (+ idx 1))))
      (if (eq? (string-ref str idx) chr)
        (max idx rest)
        rest))))

; Splits a string using an identifier
(define (split_at_last chr str)
  (let ((split_idx (last_index_of chr str 0)))
    (if (eq? split_idx -1)
      str
      (cons
        (substring str 0 split_idx)
        (substring str (+ split_idx 1) (string-length str))))))

; Converts a date to a string, in milliseconds
(define (time_to_string time)
  (+ (* (time-second (current-time)) 1000)
     (div (time-nanosecond (current-time)) 1000000)))

; Prints a text with a newline
(define (print txt)
  (display txt)
  (display "
"))

; Gets a line from stdin
(define (get_line)
  (let ((port (current-input-port)))
    (get-line port)))

; Deletes a file
(define (del_file file)
  (delete-file file))

; Gets the contents of a file as a string
; If it doesn't exist, returns empty
(define (get_file file)
  (if (file-exists? file)
    (let ((port (open-input-file file)))
      (let ((text (get-string-all port)))
        (begin
          (close-input-port port)
          text)))
    ""))

; Sets the contents of a file
(define (set_file file text)
  (system (string-append "mkdir -p " (car (split_at_last #\/ file))))
  (if (file-exists? file) (delete-file file))
  (let ((port (open-output-file file)))
    (begin
      (display text port)
      (close-output-port port))))

; Returns a list of files in a directory
(define (get_dir path)
  (directory-list path)) 

; Returns the time a file was modified. TODO: test on Windows/Linux
(define (get_file_mtime file)
  (time_to_string (file-modification-time file)))

; Returns the current time
(define (get_time)
  (time_to_string (get-time)))

; Performs a single Kind IO action
(define (io_action name)
  (case name
    ("print" (lambda (x) (print x)))
    ("put_string" (lambda (x) (display x)))
    ("get_line" (lambda (x) (get_line)))
    ("del_file" (lambda (x) (del_file x)))
    ("set_file" (lambda (x) (let ((file_text (split_at_last #\= x))) (set_file (car file_text) (cdr file_text)))))
    ("get_dir" (lambda (x) (get_dir x)))
    ("get_file_mtime" (lambda (x) (get_file_mtime x)))
    ("get_time" (lambda (x) (get_time x)))))

; Runs a Kind IO program
(define (run_io io)
  (case (get io 0)
    ('IO.end (get io 0))
    ('IO.ask (let (
      (io_query (get io 1))
      (io_param (get io 2))
      (io_then (get io 3)))
      (run_io (io_then ((io_action io_query) io_param)))))))

(define Bool-inst (lambda (x) ((x #t) #f)))
(define Bool-elim (lambda (x) (let ((self0 x)) (case self0 (#t (let () (lambda (c0) (lambda (c1) c0)))) (#f (let () (lambda (c0) (lambda (c1) c1))))))))
(define Nat-inst (lambda (x) ((x 0) (lambda (x0) (+ x0 1)))))
(define Nat-elim (lambda (x) (let ((self0 x)) (case (= self0 0) (#t (let () (lambda (c0) (lambda (c1) c0)))) (#f (let ((f0 (- self0 1))) (lambda (c0) (lambda (c1) (c1 f0)))))))))
(define U16-inst (lambda (x) (x (lambda (x0) (word-to-u16 x0)))))
(define U16-elim (lambda (x) (let ((self0 x)) (case #t (#t (let ((f0 (u16-to-word self0))) (lambda (c0) (c0 f0))))))))
(define String-inst (lambda (x) ((x "") (lambda (x0) (lambda (x1) (string-append (make-string 1 (integer->char x0)) x1))))))
(define String-elim (lambda (x) (let ((self0 x)) (case (= (string-length self0) 0) (#t (let () (lambda (c0) (lambda (c1) c0)))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (lambda (c0) (lambda (c1) ((c1 f0) f1)))))))))
(define ($Bits) '())
(define (Bits) ($Bits))
(define ($BitsMap A) '())
(define (BitsMap) (lambda (A) ($BitsMap A)))
(define ($BitsMap.get bits map) (let ((self0 bits)) (case (get self0 0) ('Bits.e (let () (let ((self0 map)) (case (get self0 0) ('BitsMap.new (let () ($Maybe.none))) ('BitsMap.tie (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) f0)))))) ('Bits.o (let ((f0 (get self0 1))) (let ((self1 map)) (case (get self1 0) ('BitsMap.new (let () ($Maybe.none))) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.get f0 f2))))))) ('Bits.i (let ((f0 (get self0 1))) (let ((self1 map)) (case (get self1 0) ('BitsMap.new (let () ($Maybe.none))) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.get f0 f3))))))))))
(define (BitsMap.get) (lambda (bits) (lambda (map) ($BitsMap.get bits map))))
(define ($BitsMap.new) (vector 'BitsMap.new))
(define (BitsMap.new) ($BitsMap.new))
(define ($BitsMap.set bits val map) (let ((self0 bits)) (case (get self0 0) ('Bits.e (let () (let ((self0 map)) (case (get self0 0) ('BitsMap.new (let () ($BitsMap.tie ($Maybe.some val) ($BitsMap.new) ($BitsMap.new)))) ('BitsMap.tie (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($BitsMap.tie ($Maybe.some val) f1 f2))))))) ('Bits.o (let ((f0 (get self0 1))) (let ((self1 map)) (case (get self1 0) ('BitsMap.new (let () ($BitsMap.tie ($Maybe.none) ($BitsMap.set f0 val ($BitsMap.new)) ($BitsMap.new)))) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.tie f1 ($BitsMap.set f0 val f2) f3))))))) ('Bits.i (let ((f0 (get self0 1))) (let ((self1 map)) (case (get self1 0) ('BitsMap.new (let () ($BitsMap.tie ($Maybe.none) ($BitsMap.new) ($BitsMap.set f0 val ($BitsMap.new))))) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.tie f1 f2 ($BitsMap.set f0 val f3)))))))))))
(define (BitsMap.set) (lambda (bits) (lambda (val) (lambda (map) ($BitsMap.set bits val map)))))
(define ($BitsMap.tie val lft rgt) (vector 'BitsMap.tie val lft rgt))
(define (BitsMap.tie) (lambda (val) (lambda (lft) (lambda (rgt) ($BitsMap.tie val lft rgt)))))
(define ($Bits.concat a b) (let ((self0 a)) (case (get self0 0) ('Bits.e (let () b)) ('Bits.o (let ((f0 (get self0 1))) ($Bits.o ($Bits.concat f0 b)))) ('Bits.i (let ((f0 (get self0 1))) ($Bits.i ($Bits.concat f0 b)))))))
(define (Bits.concat) (lambda (a) (lambda (b) ($Bits.concat a b))))
(define ($Bits.e) (vector 'Bits.e))
(define (Bits.e) ($Bits.e))
(define ($Bits.i pred) (vector 'Bits.i pred))
(define (Bits.i) (lambda (pred) ($Bits.i pred)))
(define ($Bits.o pred) (vector 'Bits.o pred))
(define (Bits.o) (lambda (pred) ($Bits.o pred)))
(define ($Bool) '())
(define (Bool) ($Bool))
(define ($Bool.and a b) (and a b))
(define (Bool.and) (lambda (a) (lambda (b) ($Bool.and a b))))
(define ($Bool.false) #f)
(define (Bool.false) ($Bool.false))
(define ($Bool.true) #t)
(define (Bool.true) ($Bool.true))
(define ($Char) '())
(define (Char) ($Char))
(define ($Either A B) '())
(define (Either) (lambda (A) (lambda (B) ($Either A B))))
(define ($Either.left value) (vector 'Either.left value))
(define (Either.left) (lambda (value) ($Either.left value)))
(define ($Either.right value) (vector 'Either.right value))
(define (Either.right) (lambda (value) ($Either.right value)))
(define ($IO A) '())
(define (IO) (lambda (A) ($IO A)))
(define ($IO.ask query param then) (vector 'IO.ask query param then))
(define (IO.ask) (lambda (query) (lambda (param) (lambda (then) ($IO.ask query param then)))))
(define ($IO.end value) (vector 'IO.end value))
(define (IO.end) (lambda (value) ($IO.end value)))
(define ($IO.print text) ($IO.put_string ($String.concat text "\xA;")))
(define (IO.print) (lambda (text) ($IO.print text)))
(define ($IO.put_string text) ($IO.ask "put_string" text (lambda (skip) ($IO.end ($Unit.new)))))
(define (IO.put_string) (lambda (text) ($IO.put_string text)))
(define ($List A) '())
(define (List) (lambda (A) ($List A)))
(define ($List.at index list) (let ((self0 list)) (case (get self0 0) ('List.nil (let () ($Maybe.none))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 index)) (case (= self2 0) (#t (let () ($Maybe.some f0))) (#f (let ((f2 (- self2 1))) ($List.at f2 f1))))))))))
(define (List.at) (lambda (index) (lambda (list) ($List.at index list))))
(define ($List.cons head tail) (vector 'List.cons head tail))
(define (List.cons) (lambda (head) (lambda (tail) ($List.cons head tail))))
(define ($List.fold list nil cons) (let ((self0 list)) (case (get self0 0) ('List.nil (let () nil)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ((cons f0) ($List.fold f1 nil cons)))))))
(define (List.fold) (lambda (list) (lambda (nil) (lambda (cons) ($List.fold list nil cons)))))
(define ($List.nil) (vector 'List.nil))
(define (List.nil) ($List.nil))
(define ($Map V) '())
(define (Map) (lambda (V) ($Map V)))
(define ($Map.from_list xs) (let ((self0 xs)) (case (get self0 0) ('List.nil (let () ($BitsMap.new))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) ($BitsMap.set ($String.to_bits f2) f3 ($Map.from_list f1)))))))))))
(define (Map.from_list) (lambda (xs) ($Map.from_list xs)))
(define ($Map.get key map) ($BitsMap.get ($String.to_bits key) map))
(define (Map.get) (lambda (key) (lambda (map) ($Map.get key map))))
(define ($Map.set key val map) ($BitsMap.set ($String.to_bits key) val map))
(define (Map.set) (lambda (key) (lambda (val) (lambda (map) ($Map.set key val map)))))
(define ($Maybe A) '())
(define (Maybe) (lambda (A) ($Maybe A)))
(define ($Maybe.default m a) (let ((self0 m)) (case (get self0 0) ('Maybe.none (let () a)) ('Maybe.some (let ((f0 (get self0 1))) f0)))))
(define (Maybe.default) (lambda (m) (lambda (a) ($Maybe.default m a))))
(define ($Maybe.none) (vector 'Maybe.none))
(define (Maybe.none) ($Maybe.none))
(define ($Maybe.some value) (vector 'Maybe.some value))
(define (Maybe.some) (lambda (value) ($Maybe.some value)))
(define ($Nat) '())
(define (Nat) ($Nat))
(define ($Nat.add n m) (+ n m))
(define (Nat.add) (lambda (n) (lambda (m) ($Nat.add n m))))
(define ($Nat.div_mod n m) ($Nat.div_mod.go n m ($Nat.zero)))
(define (Nat.div_mod) (lambda (n) (lambda (m) ($Nat.div_mod n m))))
(define ($Nat.div_mod.go n m d) (let ((self0 ($Nat.sub_rem n m))) (case (get self0 0) ('Either.left (let ((f0 (get self0 1))) ($Nat.div_mod.go f0 m ($Nat.succ d)))) ('Either.right (let ((f0 (get self0 1))) ($Pair.new d n))))))
(define (Nat.div_mod.go) (lambda (n) (lambda (m) (lambda (d) ($Nat.div_mod.go n m d)))))
(define ($Nat.eql n m) (= n m))
(define (Nat.eql) (lambda (n) (lambda (m) ($Nat.eql n m))))
(define ($Nat.for state from til func) (let ((self0 ($Nat.eql from til))) (case self0 (#t state) (#f ($Nat.for ((func from) state) ($Nat.succ from) til func)))))
(define (Nat.for) (lambda (state) (lambda (from) (lambda (til) (lambda (func) ($Nat.for state from til func))))))
(define ($Nat.gtn n m) (> n m))
(define (Nat.gtn) (lambda (n) (lambda (m) ($Nat.gtn n m))))
(define ($Nat.lte n m) (<= n m))
(define (Nat.lte) (lambda (n) (lambda (m) ($Nat.lte n m))))
(define ($Nat.mod n m) (mod n m))
(define (Nat.mod) (lambda (n) (lambda (m) ($Nat.mod n m))))
(define ($Nat.mod.go n m r) (let ((self0 m)) (case (= self0 0) (#t (let () ($Nat.mod.go n r m))) (#f (let ((f0 (- self0 1))) (let ((self1 n)) (case (= self1 0) (#t (let () r)) (#f (let ((f1 (- self1 1))) ($Nat.mod.go f1 f0 ($Nat.succ r)))))))))))
(define (Nat.mod.go) (lambda (n) (lambda (m) (lambda (r) ($Nat.mod.go n m r)))))
(define ($Nat.show n) (number->string n))
(define (Nat.show) (lambda (n) ($Nat.show n)))
(define ($Nat.show_digit base n) (let ((m ($Nat.mod n base))) (let ((base64 ($List.cons 48 ($List.cons 49 ($List.cons 50 ($List.cons 51 ($List.cons 52 ($List.cons 53 ($List.cons 54 ($List.cons 55 ($List.cons 56 ($List.cons 57 ($List.cons 65 ($List.cons 66 ($List.cons 67 ($List.cons 68 ($List.cons 69 ($List.cons 70 ($List.cons 71 ($List.cons 72 ($List.cons 73 ($List.cons 74 ($List.cons 75 ($List.cons 76 ($List.cons 77 ($List.cons 78 ($List.cons 79 ($List.cons 80 ($List.cons 81 ($List.cons 82 ($List.cons 83 ($List.cons 84 ($List.cons 85 ($List.cons 86 ($List.cons 87 ($List.cons 88 ($List.cons 89 ($List.cons 90 ($List.cons 97 ($List.cons 98 ($List.cons 99 ($List.cons 100 ($List.cons 101 ($List.cons 102 ($List.cons 103 ($List.cons 104 ($List.cons 105 ($List.cons 106 ($List.cons 107 ($List.cons 108 ($List.cons 109 ($List.cons 110 ($List.cons 111 ($List.cons 112 ($List.cons 113 ($List.cons 114 ($List.cons 115 ($List.cons 116 ($List.cons 117 ($List.cons 118 ($List.cons 119 ($List.cons 120 ($List.cons 121 ($List.cons 122 ($List.cons 43 ($List.cons 47 ($List.nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (let ((self2 ($Bool.and ($Nat.gtn base 0) ($Nat.lte base 64)))) (case self2 (#t (let () (let ((self2 ($List.at m base64))) (case (get self2 0) ('Maybe.none (let () 35)) ('Maybe.some (let ((f2 (get self2 1))) f2)))))) (#f (let () 35)))))))
(define (Nat.show_digit) (lambda (base) (lambda (n) ($Nat.show_digit base n))))
(define ($Nat.sub_rem n m) (begin (display "UE") (let ((self0 m)) (case (= self0 0) (#t (let () ($Either.left n))) (#f (let ((f0 (- self0 1))) (let ((self1 n)) (case (= self1 0) (#t (let () ($Either.right ($Nat.succ f0)))) (#f (let ((f1 (- self1 1))) ($Nat.sub_rem f1 f0)))))))))))
(define (Nat.sub_rem) (lambda (n) (lambda (m) ($Nat.sub_rem n m))))
(define ($Nat.succ pred) (+ pred 1))
(define (Nat.succ) (lambda (pred) ($Nat.succ pred)))
(define ($Nat.to_base base nat) ($Nat.to_base.go base nat ($List.nil)))
(define (Nat.to_base) (lambda (base) (lambda (nat) ($Nat.to_base base nat))))
(define ($Nat.to_base.go base nat res) (let ((self0 ($Nat.div_mod nat base))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (= self2 0) (#t (let () ($List.cons f1 res))) (#f (let ((f2 (- self2 1))) ($Nat.to_base.go base f0 ($List.cons f1 res)))))))))))
(define (Nat.to_base.go) (lambda (base) (lambda (nat) (lambda (res) ($Nat.to_base.go base nat res)))))
(define ($Nat.to_string_base base nat) ($List.fold ($Nat.to_base base nat) ($String.nil) (lambda (n) (lambda (str) ($String.cons ($Nat.show_digit base n) str)))))
(define (Nat.to_string_base) (lambda (base) (lambda (nat) ($Nat.to_string_base base nat))))
(define ($Nat.zero) 0)
(define (Nat.zero) ($Nat.zero))
(define ($Pair A B) '())
(define (Pair) (lambda (A) (lambda (B) ($Pair A B))))
(define ($Pair.new fst snd) (vector 'Pair.new fst snd))
(define (Pair.new) (lambda (fst) (lambda (snd) ($Pair.new fst snd))))
(define ($String) '())
(define (String) ($String))
(define ($String.concat as bs) (string-append as bs))
(define (String.concat) (lambda (as) (lambda (bs) ($String.concat as bs))))
(define ($String.cons head tail) (string-append (make-string 1 (integer->char head)) tail))
(define (String.cons) (lambda (head) (lambda (tail) ($String.cons head tail))))
(define ($String.nil) "")
(define (String.nil) ($String.nil))
(define ($String.to_bits str) (let ((self0 str)) (case (= (string-length self0) 0) (#t (let () ($Bits.e))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($Bits.concat ($U16.to_bits f0) ($String.to_bits f1)))))))
(define (String.to_bits) (lambda (str) ($String.to_bits str)))
(define ($Test) (let ((name "Test.main")) '()))
(define (Test) ($Test))
(define ($Test.main) (let ((map ($Map.from_list ($List.nil)))) (let ((sum 0)) (let ((lim 200000)) (let ((map ($Nat.for map 0 lim (lambda (i) (lambda (map) ($Map.set ($Nat.show i) i map)))))) (let ((sum ($Nat.for sum 0 lim (lambda (i) (lambda (sum) ($Nat.add sum ($Maybe.default ($Map.get ($Nat.show i) map) 0))))))) ($IO.print ($Nat.show sum))))))))
(define (Test.main) ($Test.main))
(define ($Unit) '())
(define (Unit) ($Unit))
(define ($Unit.new) (vector 'Unit.new))
(define (Unit.new) ($Unit.new))
(define ($U16) '())
(define (U16) ($U16))
(define ($U16.new value) (word-to-u16 value))
(define (U16.new) (lambda (value) ($U16.new value)))
(define ($U16.to_bits a) (let ((self0 a)) (case #t (#t (let ((f0 (u16-to-word self0))) ($Word.to_bits f0))))))
(define (U16.to_bits) (lambda (a) ($U16.to_bits a)))
(define ($Word size) '())
(define (Word) (lambda (size) ($Word size)))
(define ($Word.e) (vector 'Word.e))
(define (Word.e) ($Word.e))
(define ($Word.i pred) (vector 'Word.i pred))
(define (Word.i) (lambda (pred) ($Word.i pred)))
(define ($Word.o pred) (vector 'Word.o pred))
(define (Word.o) (lambda (pred) ($Word.o pred)))
(define ($Word.to_bits a) (let ((self0 a)) (case (get self0 0) ('Word.e (let () ($Bits.e))) ('Word.o (let ((f0 (get self0 1))) ($Bits.o ($Word.to_bits f0)))) ('Word.i (let ((f0 (get self0 1))) ($Bits.i ($Word.to_bits f0)))))))
(define (Word.to_bits) (lambda (a) ($Word.to_bits a)))
(run_io (Test.main))
