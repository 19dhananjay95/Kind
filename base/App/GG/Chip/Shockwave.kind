App.GG.Chip.Shockwave: App.GG.Chip
  App.GG.Chip.new(
    "ShockWave"
    App.GG.Chip.Shockwave.Effect
    App.GG.img.chip
  )

App.GG.Effect.vbox.set(
  vbox: VoxBox -> VoxBox
): App.GG.Effect<Unit>
  (center, origin, grid)
  App.GG.Effect.Result.new!(unit, center, origin, grid, vbox, 0, "")

App.GG.Effect.vbox.in_tile(
  vbox: VoxBox
): App.GG.Effect<Unit>
  (center, origin, grid)
  let {x, y}  = App.GG.Coord.to_xy(center)
  let img     = VoxBox.Draw.image(x, y, 0, vbox)
  App.GG.Effect.Result.new!(unit, center, origin, grid, img, 0, "")

App.GG.Effect.frame.inc: App.GG.Effect<Unit>
  (center, origin, grid)
  let new_grid =
    case origin {
      creature: App.GG.Actions.inc(center, grid)
      projectile: App.GG.Projectile.inc(center, origin.id, grid)
    }
  App.GG.Effect.Result.new!(unit, center, origin, new_grid, (img) img, 0, "")

App.GG.Effect.Grid.get: App.GG.Effect<App.GG.Grid>
  (center, origin, grid)
  App.GG.Effect.Result.new!(grid, center, origin, grid, (img) img, 0, "")

App.GG.Effect.tile.get: App.GG.Effect<Maybe<App.GG.Tile>>
  (center, origin, grid)
  let tile = App.GG.Grid.get(center, grid)
  App.GG.Effect.Result.new!(tile, center, origin, grid, (img) img, 0, "")

App.GG.Effect.creature.get: App.GG.Effect<Maybe<App.GG.Creature>>
  (center, origin, grid)
  let creature = App.GG.Creature.get(center, grid)
  App.GG.Effect.Result.new!(creature, center, origin, grid, (img) img, 0, "")

App.GG.Effect.creature.get_at(pos: App.GG.Coord): App.GG.Effect<Maybe<App.GG.Creature>>
  (center, origin, grid)
  let creature = App.GG.Creature.get(pos, grid)
  App.GG.Effect.Result.new!(creature, center, origin, grid, (img) img, 0, "")

App.GG.Effect.coord.get_center: App.GG.Effect<App.GG.Coord>
  (center, origin, grid)
  App.GG.Effect.Result.new!(center, center, origin, grid, (img) img, 0, "")

App.GG.Effect.frame.get: App.GG.Effect<Maybe<U64>>
  (center, origin, grid)
  let frame =  
  case origin {
    creature: 
      Maybe {
        get creature = App.GG.Creature.get(center, grid)
        let actions = creature@actions
        get current = actions@current
        return current@frame
      }
    projectile: 
      Maybe {
        get projectile = App.GG.Projectile.get(center, origin, grid)
        let info = projectile@info
        return info@frame
      }

  }
  App.GG.Effect.Result.new!(frame, center, origin, grid, (img) img, 0, "")

App.GG.Effect.actions.del: App.GG.Effect<Unit>
(center, origin, grid)
let f = 
  (creature)
    let actions = creature@actions
    let new_actions = actions@current <- none
    creature@actions <- new_actions
let new_grid = App.GG.Creature.modify_at(f, center, grid)
App.GG.Effect.Result.new!(unit, center, origin, new_grid, (img) img, 0, "")

App.GG.Effect.projectile.add_at(pos: App.GG.Coord, projectile: App.GG.Projectile): App.GG.Effect<Unit>
  (center, origin, grid)
  let new_grid = App.GG.Projectile.create(pos, projectile, grid)
  App.GG.Effect.Result.new!(unit, center, origin, new_grid, (img) img, 0, "")

App.GG.Effect.projectile.get: App.GG.Effect<Maybe<App.GG.Projectile>>
  (center, origin, grid)
  let projectile = App.GG.Projectile.get(center, origin, grid)
  App.GG.Effect.Result.new!(projectile, center, origin, grid, (img) img, 0, "")


App.GG.Effect.pass: App.GG.Effect<Unit>
App.GG.Effect {
  return unit
}


App.GG.Effect.team.get(center: App.GG.Coord, origin: App.GG.Effect.Origin, grid: App.GG.Grid): Maybe<App.GG.Team>
  case origin {
    creature: 
      Maybe {
        get creature = App.GG.Creature.get(center, grid)
        return creature@team
      }
    projectile:
      Maybe {
        get projectile = App.GG.Projectile.get(center, origin, grid)
        let info = projectile@info
        return info@team
      }
  }

App.GG.Effect.creature.is_enemy(coord: App.GG.Coord): App.GG.Effect<Bool>
  (center, origin, grid)
  let bool =
    Maybe {
      get creature = App.GG.Creature.get(coord, grid)
      get team  = App.GG.Effect.team.get(center, origin, grid)
      let bool = App.GG.Team.is_same(creature@team, team)
      return not(bool) 
    } <> false
  App.GG.Effect.Result.new!(bool, center, origin, grid, (img) img, 0, "")

App.GG.Effect.projectile.move(new_pos: App.GG.Coord): App.GG.Effect<Bool>
  (center, origin, grid)
  let {bool, new_grid} = 
    case origin {
      creature: {false, grid}
      projectile:
        let tile_exists =
          Maybe.is_some!(App.GG.Grid.get(new_pos, grid))
        let new_grid = App.GG.Projectile.move(center, new_pos, origin.id, grid)
        {tile_exists, new_grid}
    }
  App.GG.Effect.Result.new!(bool, center, origin, new_grid, (img) img, 0, "")

App.GG.Effect.creature.change_hp_at(dmg: I32, pos: App.GG.Coord): App.GG.Effect<I32>
  (center, origin, grid)
  let {real_dmg, new_grid} =
    Maybe {
      get tile = App.GG.Grid.get(pos, grid)
      get creature = tile@creature
      let hp = creature@hp
      let new_hp = I32.max(hp + dmg, 0)
      let new_creature = creature@hp <- new_hp
      let new_tile = tile@creature <- some(new_creature)
      let real_dmg = hp - new_hp
      let new_grid = App.GG.Grid.set(pos, new_tile, grid)
      return {real_dmg, new_grid}
    } <> {+0#32, grid}
  App.GG.Effect.Result.new!(real_dmg, center, origin, new_grid, (img) img, 0, "")

App.GG.Effect.projectile.add_hit(pos: App.GG.Coord): App.GG.Effect<Unit>
  (center, origin, grid)
  let new_grid =
    let creature = App.GG.Creature.get(pos, grid)
    without creature: grid
    let id = creature@id
    case origin {
      creature: grid
      projectile:
        App.GG.Projectile.add_hit(id, center, origin.id, grid)
    }
  App.GG.Effect.Result.new!(unit, center, origin, new_grid, (img) img, 0, "")

App.GG.Effect.projectile.has_hit(pos: App.GG.Coord): App.GG.Effect<Bool>
  (center, origin, grid)
  let bool =
    Maybe {
      get creature = App.GG.Creature.get(pos, grid)
      get projectile = App.GG.Projectile.get(center, origin, grid)
      let info = projectile@info
      let bool = NatSet.has(creature@id, info@hits)
      return bool
    } <> false
  App.GG.Effect.Result.new!(bool, center, origin, grid, (img) img, 0, "")


// App.GG.Chip.Shockwave.Effect(
//   coord: App.GG.Coord,
//   origin: App.GG.Effect.Origin,
//   grid: App.GG.Grid
// ): App.GG.Effect.Result<Unit>
//   let vbox = 
//     let {x, y} = App.GG.Coord.to_xy(coord)
//     VoxBox.Draw.image(x, y, 0, App.GG.img.target_tile)
//   let grid = App.GG.Actions.inc(coord, grid)
//   let new_grid = 
//     Maybe {
//       get tile = App.GG.Grid.get(coord, grid)
//       get creature = App.GG.Creature.get(coord, grid)
//       let actions = creature@actions
//       get current = actions@current
//       log("Action - Shockwave's current frame: " | U64.show(current@frame))
//       let new_grid = 
//       if current@frame =? 16 then 
//         let new_actions = actions@current <- none
//         let new_creature = creature@actions <- new_actions
//         let new_tile = tile@creature <- some(new_creature)
//         let new_grid = App.GG.Grid.set(coord, new_tile, grid)
//         let projectile_info = App.GG.Projectile.Info.new(creature@team, App.GG.Projectile.Status.unit, coord, 0#64)
//         let projectile_effect = App.GG.Chip.Shockwave.Projectile.Effect  
//         let projectile = App.GG.Projectile.new(projectile_info, projectile_effect)
//         let new_grid = App.GG.Projectile.create(coord, projectile, new_grid)
//         new_grid
//       else
//         grid
//       return new_grid 
//     } <> grid
//   App.GG.Effect.Result.new(new_grid, vbox)

// App.GG.Chip.Shockwave.Projectile.Effect: App.GG.Effect<Unit>
//   (coord, origin, grid)
//   let vbox = 
//     let {x, y} = App.GG.Coord.to_xy(coord)
//     VoxBox.Draw.image(x, y, 10, App.GG.img.target_tile)
//   let tile = App.GG.Grid.get(coord, grid)
//   case tile {
//     none: App.GG.Effect.Result.err
//     some:
//       case origin {
//         creature: App.GG.Effect.Result.err
//         projectile:
//           let grid = App.GG.Projectile.inc(coord, origin.id, grid)
//           let projectile = List.get!(origin.id, tile.value@projectiles)
//           case projectile {
//             none: App.GG.Effect.Result.err
//             some: 
//               let info = projectile.value@info
//               let new_grid =
//                 case tile.value@creature as creature {
//                   none: grid
//                   some: 
//                     case info@team creature.value@team {
//                       blue red: log("deals dmg") grid
//                       red blue: log("deals dmg") grid 
//                     }default log("same team") grid 
//                 }
//               log("Projectile - Shockwave's current frame: " | U64.show(info@frame))
//               let new_grid =
//                 if (info@frame % 16) =? (0) then 
//                   let new_coord = case info@team {
//                     blue: {coord@fst + 1, coord@snd}
//                     red:  {coord@fst - 1, coord@snd}
//                     neutral: coord
//                   }
//                   log(U32.show(new_coord@fst) | U32.show(new_coord@snd))
//                   App.GG.Projectile.move(coord, new_coord, origin.id, new_grid)
//                 else
//                   new_grid
//               App.GG.Effect.Result.new(new_grid, vbox)
//           }
//       }
//   }

App.GG.Chip.Shockwave.Effect: App.GG.Effect<Unit>
  App.GG.Effect {
    // TODO: Need to waste the chip when used
    get creature = App.GG.Effect.creature.get
    get center = App.GG.Effect.coord.get_center
    get frame = App.GG.Effect.frame.get
    // App.GG.Effect.vbox.in_tile(App.GG.img.target_tile) // Cannon image if has
    App.GG.Effect.frame.inc // Increases action's frame by 1
    without creature: App.GG.Effect.pass
    without frame: App.GG.Effect.pass
    App.GG.Effect {
      if frame =? 16 then // At 16th frame
        App.GG.Effect {
          App.GG.Effect.actions.del // Delete action from creature
          let projectile_info = App.GG.Projectile.Info.new(creature@team, App.GG.Projectile.Status.unit, NatSet.new, 0#64)
          let projectile_effect = App.GG.Chip.Shockwave.Projectile.Effect 
          let projectile = App.GG.Projectile.new(projectile_info, projectile_effect)
          let projectile_coord = App.GG.Coord.front(center, creature@team) // Gets the coordinate in front of the creature
          App.GG.Effect.projectile.add_at(projectile_coord, projectile)
        }
      else
        App.GG.Effect.pass
    }
  }

App.GG.Chip.Shockwave.Projectile.Effect: App.GG.Effect<Unit>
  App.GG.Effect {
    App.GG.Effect.vbox.in_tile(App.GG.img.target_tile) // Adds image bound to tile
    App.GG.Effect.frame.inc // Increases projectile frame by 1
    get center = App.GG.Effect.coord.get_center
    get projectile = App.GG.Effect.projectile.get
    get frame = App.GG.Effect.frame.get
    get is_enemy = App.GG.Effect.creature.is_enemy(center) // Checks if projectile is over an enemy
    get has_hit  = App.GG.Effect.projectile.has_hit(center) // Checks if projectile has already hit that enemy
    if is_enemy && not(has_hit) then
      App.GG.Effect {
        App.GG.Effect.projectile.add_hit(center) // Adds enemy to lits of targets hit by projectile
        App.GG.Effect.creature.change_hp_at(-10, center) 
        return unit
      }
    else
      App.GG.Effect.pass
    without frame: App.GG.Effect.pass
    without projectile: App.GG.Effect.pass
    if (frame % 16) =? 0 then // Each 16 frames
      App.GG.Effect {
        let new_pos = App.GG.Coord.front(center, projectile@info@team) // Gets coord in front of projectile's
        App.GG.Effect.projectile.move(new_pos) // Moves projectile a tile forward
        return unit
      }
    else
      App.GG.Effect.pass
  }
    