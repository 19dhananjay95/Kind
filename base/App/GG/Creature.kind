type App.GG.Creature { 
  new(
    category: App.GG.Monster
    team: App.GG.Team
    animation: Pair<App.GG.Animation, U64>
    actions: App.GG.Actions
    statuses: App.GG.Creature.Statuses
    hp: I32
    id: Nat
  )
}

//===========================================================
//Creature Management

App.GG.Creature.modify_at(
  mod: App.GG.Creature -> App.GG.Creature
  pos: App.GG.Coord
  grid: App.GG.Grid
): App.GG.Grid
  
  let result = Maybe { 
    get creature = App.GG.Creature.get(pos, grid)
    let mod = App.GG.Tile.update_creature(mod)
    let new_grid = App.GG.Grid.update(pos, mod, grid)
    return new_grid
  }
  result <> grid


App.GG.Creature.get(
  place: App.GG.Coord
  grid: App.GG.Grid
): Maybe<App.GG.Creature>

  let tile = App.GG.Grid.get(place, grid)
  case tile { 
    none:
      none
    some:
      tile.value@creature
  }


//===========================================================
//Status Management

type App.GG.Creature.Statuses {
  new(
    poison: Maybe<App.GG.Creature.Status>
    stun: Maybe<App.GG.Creature.Status>
    barrier: Maybe<App.GG.Creature.Status>
    intangible: Maybe<App.GG.Creature.Status>
    intangible_immunity: Maybe<App.GG.Creature.Status>
    pendent_movement: Maybe<App.GG.Creature.Status>
  )
}

App.GG.Creature.Statuses.pure: App.GG.Creature.Statuses
  App.GG.Creature.Statuses.new(none, none, none, none, none, none)

App.GG.Creature.Status.update_grid(coord: App.GG.Coord, game: App.GG.Game): App.GG.Game
  App.GG.Creature.Status.update_grid.go(0, coord, game)

App.GG.Creature.Status.update_grid.go(count: Nat, coord: App.GG.Coord, game: App.GG.Game): App.GG.Game
let grid = game@grid
  let new_game = 
    Maybe {
      get creature = App.GG.Creature.get(coord, grid)
      let statuses = creature@statuses
      get status = App.GG.Creature.Status.get_from_nat(count, statuses)
      let new_game = 
        without status: game
        App.GG.Creature.Status.update_function(status, coord, game)
      let new_game = App.GG.Creature.Status.update_grid.go(count +1, coord, new_game)
      return new_game
    } <> game
  new_game

type App.GG.Creature.Status {
  // invulnerable(duration: U64)
  // intangible(duration: U64)
  // poison(duration: U64, damage: I32)
  // root(duration: U64)
  barrier(duration: U64, health: I32)
  poison(duration: U64, damage: I32)
  stun(category: App.GG.Creature.Status.Stun)
  intangible(duration: U64)
  intangible_immunity
  pendent_movement(duration: U64, destination: App.GG.Coord)
}

App.GG.Creature.Status.del_from_nat(count: Nat, creature: App.GG.Creature): App.GG.Creature
  let statuses = creature@statuses
  let new_statuses = 
    switch Nat.eql(count) {
    0: statuses@poison <- none
    1: statuses@stun <- none
    2: statuses@barrier <- none
    3: statuses@intangible <- none
    4: statuses@intangible_imunity <- none
    5: statuses@pendent_movement <- none
  }default statuses
  creature@statuses <- new_statuses

App.GG.Creature.Status.add(status: App.GG.Creature.Status, creature: App.GG.Creature): App.GG.Creature
  let statuses = creature@statuses
  let new_statuses = 
    case status {
      poison: statuses@poison <- some(status)
      stun: statuses@stun <- some(status)
      barrier: statuses@barrier <- some(status)
      intangible: statuses@intangible <- some(status)
      intangible_immunity: statuses@intangible_immunity <- some(status)
      pendent_movement: statuses@pendent_movement <- some(status)
    }
  creature@statuses <- new_statuses

App.GG.Creature.Status.get_from_nat(count: Nat, statuses: App.GG.Creature.Statuses): Maybe<Maybe<App.GG.Creature.Status>>
  switch Nat.eql(count) {
    0: some(statuses@poison)
    1: some(statuses@stun)
    2: some(statuses@barrier)
    3: some(statuses@intangible)
    4: some(statuses@intangible_immunity)
    5: some(statuses@pendent_movement)
  }default none

App.GG.Creature.Status.update_function(status: App.GG.Creature.Status, coord: App.GG.Coord, game: App.GG.Game): App.GG.Game
  case status {
    poison:     
      App.GG.Creature.Status.update_poison(status, coord, game)
    stun:       
      App.GG.Creature.Status.update_stun(status, coord, game)
    barrier:      
      App.GG.Creature.Status.update_barrier(status, coord, game)
    intangible: 
      App.GG.Creature.Status.update_intangible(status, coord, game)
    intangible_immunity: 
      App.GG.Creature.Status.update_intangible_immunity(status, coord, game)
    pendent_movement: 
      App.GG.Creature.Status.update_pendent_movement(status, coord, game)
  }default game

App.GG.Creature.Status.draw(statuses: App.GG.Creature.Statuses, xy: Pair<U32, U32>, img: VoxBox): VoxBox
  App.GG.Creature.Status.draw.go(0, statuses, xy, img)

App.GG.Creature.Status.draw.go(count: Nat, statuses: App.GG.Creature.Statuses, xy: Pair<U32, U32>, img: VoxBox): VoxBox
  let next = App.GG.Creature.Status.draw.go(count + 1, statuses, xy)
  let status = App.GG.Creature.Status.get_from_nat(count, statuses)
  without status: img
  without status: next(img)
  let img = App.GG.Creature.Status.draw.function(status, xy, img)
  next(img)

App.GG.Creature.Status.draw.function(status: App.GG.Creature.Status, xy: Pair<U32, U32>, img: VoxBox): VoxBox
  case status {
    poison:     App.GG.Creature.Status.draw.poison(status, xy, img)
    // stun:       App.GG.Creature.Status.draw.stun(status, img)
    barrier:    App.GG.Creature.Status.draw.barrier(status, xy, img)
    // intangible: App.GG.Creature.Status.draw.intangible(status, img)
  }default img

// =============================================================
// Poison Status

App.GG.Creature.Status.update_poison(status: App.GG.Creature.Status, coord: App.GG.Coord, game: App.GG.Game): App.GG.Game
  case status {
    poison: 
      let grid = game@grid
      let new_duration = App.GG.Creature.Status.add(App.GG.Creature.Status.poison(status.duration - 1, status.damage))
      let update = (x: App.GG.Creature -> App.GG.Creature) App.GG.Creature.modify_at(x, coord, grid)
      let new_grid = 
        if status.duration =? 0 then
          let new_creature = App.GG.Creature.Status.del_from_nat(0)
          update(new_creature)
        else
          if (status.duration % 10) =? 0 then 
          //log(U64.show(status.duration) | " Hits")
          let eff = App.GG.Effect.damage(status.damage, false, false, coord)
          let new_game = game@grid <- update(new_duration)
          let result = eff(coord, App.GG.Effect.Origin.creature, new_game)
          case result {err: grid, new: result.game@grid}
        else
          update(new_duration)

        game@grid<- new_grid

  } default game

App.GG.Creature.Status.draw.poison(status: App.GG.Creature.Status, xy: Pair<U32, U32>, img: VoxBox): VoxBox
  let poison = App.GG.img.Status.poison.poison
  VoxBox.Draw.image(xy@fst, xy@snd, 20, poison, img)
  
// =============================================================
// Stun Status

type App.GG.Creature.Status.Stun {
  flinch
  shock
}

App.GG.Creature.Status.update_stun(status: App.GG.Creature.Status, coord: App.GG.Coord, game: App.GG.Game): App.GG.Game
  case status {
    stun: 
      // let grid = game@grid
      // let new_creature = App.GG.Creature.Status.add(App.GG.Creature.Status.stun(status.category))
      // let new_grid     = App.GG.Creature.modify_at(new_creature, coord, grid)
      // let new_game    = game@grid <- new_grid
      // new_game
      game
  }default game

// =============================================================
// Barrier Status

App.GG.Creature.Status.update_barrier(status: App.GG.Creature.Status, coord: App.GG.Coord, game: App.GG.Game): App.GG.Game
  case status {
    barrier:
      let grid = game@grid
      let new_grid = 
        if status.duration =? 0 then
          let new_creature = App.GG.Creature.Status.del_from_nat(2)
          let new_grid     = App.GG.Creature.modify_at(new_creature, coord, grid)
          new_grid
        else
          let new_creature = App.GG.Creature.Status.add(App.GG.Creature.Status.barrier(status.duration - 1, status.health))
          let new_grid = App.GG.Creature.modify_at(new_creature, coord, grid)
          new_grid
      let new_game = game@grid <- new_grid
      new_game
  }default game

App.GG.Creature.Status.draw.barrier(status: App.GG.Creature.Status, xy: Pair<U32, U32>, img: VoxBox): VoxBox
  let barrier = App.GG.img.Status.barrier.barrier
  VoxBox.Draw.image(xy@fst, xy@snd, 20, barrier, img)

// =============================================================
// Intangible Status

App.GG.Creature.Status.update_intangible(status: App.GG.Creature.Status, coord: App.GG.Coord, game: App.GG.Game): App.GG.Game
  case status {
    intangible:
      let grid = game@grid
      let new_grid = 
        if status.duration =? 0 then
          let new_creature = App.GG.Creature.Status.del_from_nat(3)
          let new_grid     = App.GG.Creature.modify_at(new_creature, coord, grid)
          new_grid
        else
          let new_creature = App.GG.Creature.Status.add(App.GG.Creature.Status.intangible(status.duration - 1))
          let new_grid = App.GG.Creature.modify_at(new_creature, coord, grid)
          new_grid
      let new_game = game@grid <- new_grid
      new_game
  }default game

App.GG.Creature.Status.intangible_draw_invisible(statuses: App.GG.Creature.Statuses): Bool
  let intangible = statuses@intangible
  case intangible {
    none: false
    some: 
      case intangible.value {
        intangible: (intangible.value.duration % 5) <? 2
      }default false
  }

// =============================================================
// Intangible_immunity Status

App.GG.Creature.Status.update_intangible_immunity(status: App.GG.Creature.Status, coord: App.GG.Coord, game: App.GG.Game): App.GG.Game
  case status {
    intangible_immunity: game
  }default game


// =============================================================
// Pendent_movement Status

App.GG.Creature.Status.update_pendent_movement(status: App.GG.Creature.Status, coord: App.GG.Coord, game: App.GG.Game): App.GG.Game
  case status {
    pendent_movement:
      let grid = game@grid
      let new_grid = 
        if status.duration =? 0 then
          let new_creature = App.GG.Creature.Status.del_from_nat(5)
          let new_grid     = App.GG.Creature.modify_at(new_creature, coord, grid)
          let new_grid     = App.GG.Grid.move_creature(coord, status.destination, new_grid, false)
          new_grid
        else
          let new_creature = App.GG.Creature.Status.add(App.GG.Creature.Status.pendent_movement(status.duration - 1, status.destination))
          let new_grid = App.GG.Creature.modify_at(new_creature, coord, grid)
          new_grid
      let new_game = game@grid <- new_grid
      new_game
  }default game

// ============================

App.GG.Creature.sub_folder(quantity: Nat, creature: App.GG.Creature): App.GG.Creature
  case creature@category as monster {
    minion: creature
    slime:
      creature@category <- App.GG.Monster.slime(monster.data, monster.attributes, monster.charge, monster.hand, List.drop!(quantity, monster.folder), monster.energy)
  }

App.GG.Creature.shuffle_folder(seed: Nat, creature: App.GG.Creature): App.GG.Creature
  case creature@category as monster {
    minion: creature
    slime:
      let new_folder = App.GG.Chips.shuffle(seed, monster.folder)
      creature@category <- App.GG.Monster.slime(monster.data, monster.attributes, monster.charge, monster.hand, new_folder, monster.energy)
  }

App.GG.Creature.add_chip(chip: App.GG.Chip, creature: App.GG.Creature): App.GG.Creature
  case creature@category as monster {
    minion: creature
    slime:
      let category = App.GG.Monster.slime(monster.data, monster.attributes, monster.charge, chip & monster.hand, monster.folder, monster.energy)
      creature@category <- category
  }

App.GG.Creature.delete(coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  let tile = App.GG.Grid.get(coord, grid)
  without tile: grid
  let new_tile = tile@creature <- none
  App.GG.Grid.set(coord, new_tile, grid)

App.GG.Creature.create_slime(slime: App.GG.Slime, grid: App.GG.Grid): App.GG.Creature
  let team = App.GG.Team.blue
  let animation = {App.GG.Animation.idle, 0#64}
  let actions = App.GG.Actions.new(none, none, false)
  let status = App.GG.Creature.Statuses.pure
  let id = App.GG.Grid.next_id(grid)
  let body = slime@body
  let data = slime
  let charge = none
  let hand = []
  let folder = App.GG.Body.to_folder(body)
  let attributes = App.GG.Body.attributes(body)
  let hp = attributes@hp * 10
  let energy = 0 :: I32
  let monster = App.GG.Monster.slime(data, attributes, none, hand, folder, energy)
  App.GG.Creature.new(monster, team, animation, actions, status, hp, id)

App.GG.Creature.create_minion(minion: App.GG.Minion, grid: App.GG.Grid): App.GG.Creature
  let team = App.GG.Team.red
  let animation = {App.GG.Animation.idle, 0#64}
  let actions = App.GG.Actions.new(none, none, false)
  let status = App.GG.Creature.Statuses.pure
  // let status = status@barrier <- some(App.GG.Creature.Status.barrier(400, 30))
  let status = status@intangible_immunity <- some(App.GG.Creature.Status.intangible_immunity)
  let id = App.GG.Grid.next_id(grid)
  let AI = {"seen": +0#32, "unseen": +0#32}
  let hp = minion@hp
  let monster = App.GG.Monster.minion(minion, AI)
  App.GG.Creature.new(monster, team, animation, actions, status, hp, id)


App.GG.Creature.create_minion_2(minion: App.GG.Minion, team: App.GG.Team, grid: App.GG.Grid): App.GG.Creature
  let animation = {App.GG.Animation.idle, 0#64}
  let actions = App.GG.Actions.new(none, none, false)
  let status = App.GG.Creature.Statuses.pure
  let id = App.GG.Grid.next_id(grid)
  let AI = {"": +0#32, "": +0#32}
  let hp = minion@hp
  let monster = App.GG.Monster.minion(minion, AI)
  App.GG.Creature.new(monster, team, animation, actions, status, hp, id)

App.GG.Creature.place(creature: App.GG.Creature, coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  let f = 
    (tile: App.GG.Tile)
    tile@creature <- some(creature)
  App.GG.Grid.update(coord, f, grid)

App.GG.Creature.dmg_with_attribute(creature: App.GG.Creature, dmg: I32): I32
  let attributes = App.GG.Attributes.get(creature)
  without attributes: dmg
  let destruction = attributes@damage
  (dmg * destruction) / 25

App.GG.Creature.basic_attack_dmg(creature: App.GG.Creature): I32
  let attributes = App.GG.Attributes.get(creature)
  without attributes: 0 :: I32
  let base_dmg  = 2 :: I32
  let extra_dmg = (attributes@damage - 25) / 5
  let total_dmg = base_dmg + extra_dmg
  total_dmg

App.GG.Creature.max_hp_percentage(creature: App.GG.Creature): I32
  let max_hp = App.GG.Monster.get_max_hp(creature@category)
  let actual_hp = creature@hp
  actual_hp/max_hp


App.GG.Attributes.get(creature: App.GG.Creature): Maybe<App.GG.Attributes>
  case creature@category as monster {
    minion: none
    slime:
      some(monster.attributes)
  }

// ============================================================================
// Grid Update functions

// If creature hasn't acted, update its actions, run its effects and update animation to next frame
App.GG.Creature.run(coord: App.GG.Coord, game: App.GG.Game): App.GG.Game
  if App.GG.Creature.has_acted(coord, game) then 
    game
  else
    let new_game = App.GG.Creature.update_charge()
    let new_game = App.GG.Creature.run_ai(coord, game)
    let new_game = App.GG.Creature.update_actions(coord, new_game)
    let new_game = App.GG.Creature.update_animation(coord, new_game)
    let new_game = App.GG.Actions.run(coord, new_game)
    new_game

// Checks if creature has acted in this frame
App.GG.Creature.has_acted(coord: App.GG.Coord, game: App.GG.Game): Bool
  let creature = App.GG.Creature.get(coord, game@grid)
  without creature: false
  creature@actions@has_acted

App.GG.Creature.reset_actions.aux(creature: App.GG.Creature): App.GG.Creature
  let actions = creature@actions
  let new_actions = actions@has_acted <- false
  creature@actions <- new_actions

// Updates animation to its next frame
App.GG.Creature.update_animation(coord: App.GG.Coord, game: App.GG.Game): App.GG.Game
  let mod = (creature: App.GG.Creature) creature@animation <- {creature@animation@fst, creature@animation@snd + 1}
  let new_grid = App.GG.Creature.modify_at(mod, coord, game@grid)
  let new_game = game@grid <- new_grid
  new_game
// If current action is "none", moves next action to its place
App.GG.Creature.update_actions(coord: App.GG.Coord, game: App.GG.Game): App.GG.Game
  let grid = game@grid
  let new_grid = App.GG.Creature.modify_at(App.GG.Creature.update_actions.aux, coord, grid)
  let new_game = game@grid <- new_grid
  new_game

App.GG.Creature.update_actions.aux(creature: App.GG.Creature): App.GG.Creature
  let actions = creature@actions
  let next_action = actions@next
  let curr_action  = actions@current
  without curr_action: 
    without next_action: creature
    let new_actions = actions@current <- some(next_action)
    let new_actions = new_actions@next <- none
    let new_creature = creature@actions <- new_actions
    new_creature
  creature

// Changes creature's has_acted to false
App.GG.Creature.reset_actions(coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  App.GG.Creature.modify_at(App.GG.Creature.reset_actions.aux, coord, grid)

App.GG.Creature.run_ai(coord: App.GG.Coord, game: App.GG.Game): App.GG.Game
  Maybe {
    let grid = game@grid
    get minion = App.GG.Minion.get(coord, grid)
    let result = minion@effect(coord, App.GG.Effect.Origin.creature, game)
    let new_game = case result {err: game, new: result.game}
    return new_game
  } <> game

App.GG.Creature.update_charge(coord: App.GG.Coord, game: App.GG.Game): App.GG.Game
  let grid = game@grid
  let mod = (creature: App.GG.Creature)
    case creature@category as monster {
      minion: creature
      slime:
        let body = monster.data@body
        let hull_data = App.GG.Body.Hull.Form.data(body@hull@form) 
        let extra_charge = hull_data@frame_charge
        let new_charge = Maybe.map!!(U64.min(960) Maybe.map!!(U64.add(extra_charge), monster.charge))
        let monster = App.GG.Monster.slime(monster.data, monster.attributes, new_charge, monster.hand, monster.folder, monster.energy)
        creature@category <- monster
    }
  let new_grid = App.GG.Creature.modify_at(mod, coord, grid)
  let new_game = game@grid <- new_grid
  new_game

// ============================================================================
