Lit.Lang.Bits: String
`
Bits.tail(a: Bits): Bits
  case a : Bits { 
    e: Bits/e
    o: a.pred
    i: a.pred
  }

Bits.inc(a: Bits): Bits
  case a : Bits { 
    e:
      Bits/i{pred: Bits/e}
    o:
      Bits/i{pred: a.pred}
    i:
      call inc = Bits.inc(a.pred)
      Bits/o{pred: inc}
  }

Bits.size.aux(b: Bits, n: Nat, s: Nat): Nat
  case b : Bits {
    e: s
    o: 
      call rec = Bits.size.aux(b.pred, Nat/succ{pred: n}, s)
      rec
    i:
      call rec = Bits.size.aux(b.pred, Nat/succ{pred: n}, Nat/succ{pred: n})
      rec
  }

Bits.size(b: Bits): Nat
  call size = Bits.size.aux(b, Nat/zero, Nat/zero)
  size

Bits.and(a: Bits, b: Bits): Bits
  case a : Bits { 
    e: a
    o: case b : Bits { 
      e: b
      o: 
        call rec = Bits.and(a.pred, b.pred)
        Bits/o{pred: rec}
      i:
        call rec = Bits.and(a.pred, b.pred)
        Bits/o{pred: rec}
      }
    i: case b : Bits { 
      e: b
      o:
        call rec = Bits.and(a.pred, b.pred)
        Bits/o{pred: rec}
      i:
        call rec = Bits.and(a.pred, b.pred)
        Bits/i{pred: rec} 
    }
  }

Bits.concat(a: Bits, b: Bits): Bits
  case a : Bits { 
    e: b,
    o:
      call rec = Bits.concat(a.pred, b)
      Bits/o{pred: rec}
    i:
      call rec = Bits.concat(a.pred, b)
      Bits/i{pred: rec}
  }

Bits.not(b: Bits): Bits 
  case b : Bits {
    e: Bits/e
    o: 
      call rec = Bits.not(b.pred)
      Bits/i{pred: rec}
    i:
      call rec = Bits.not(b.pred)
      Bits/o{pred: rec}
  }

Bits.or(a: Bits, b: Bits): Bits
  case a : Bits { 
    e: b
    o: case b : Bits { 
      e: a
      o: 
        call rec = Bits.or(a.pred, b.pred)
        Bits/o{pred: rec}
      i:
        call rec = Bits.or(a.pred, b.pred)
        Bits/i{pred: rec}
    }
    i: case b : Bits { 
      e: a
      o: 
        call rec = Bits.or(a.pred, b.pred)
        Bits/i{pred: rec}
      i:
        call rec = Bits.or(a.pred, b.pred)
        Bits/i{pred: rec}
    }
  }

Bits.reverse.aux(a: Bits, r: Bits): Bits
  case a : Bits { 
    e: r
    o:
      call rec = Bits.reverse.aux(a.pred, Bits/o{pred: r})
      rec
    i:
      call rec = Bits.reverse.aux(a.pred, Bits/i{pred: r})
      rec
  }

Bits.reverse(b: Bits): Bits
  call rev = Bits.reverse.aux(b, Bits/e)
  rev

// Operations

Bits.add(a: Bits, b: Bits): Bits
  case b : Bits { 
    e: a
    o: case a : Bits { 
      e: b
      o: 
        call rec = Bits.add(a.pred, b.pred)
        Bits/o{pred: rec}
      i:
        call rec = Bits.add(a.pred, b.pred)
        Bits/i{pred: rec}
    }
    i: case a : Bits { 
      e: b
      o:
        call rec = Bits.add(a.pred, b.pred)
        Bits/i{pred: rec}
      i:
        call inc = Bits.inc(a.pred)
        call rec = Bits.add(inc, b.pred)
        Bits/o{pred: rec}
    }
  }

Bits.sub.aux(a: Bits, b: Bits, r: Bits): Bits
  case b : Bits { 
    e: case a : Bits { 
      e: r
      o:
        call rec = Bits.sub.aux(a.pred, b, Bits/o{pred: r})
        rec
      i:
        call rec = Bits.sub.aux(a.pred, b, Bits/i{pred: r})
        rec
    }
    o: case a : Bits { 
      e: 
        call rec = Bits.sub.aux(a, b.pred, Bits/o{pred: r})
        rec
      o:
        call rec = Bits.sub.aux(a.pred, b.pred, Bits/o{pred: r})
        rec
      i:
        call rec = Bits.sub.aux(a.pred, b.pred, Bits/i{pred: r})
        rec
    }
    i: case a : Bits {
      e: Bits/e
      o:
        call inc = Bits.inc(b.pred)
        call rec = Bits.sub.aux(a.pred, inc , Bits/i{pred: r})
        rec
      i:
        call rec = Bits.sub.aux(a.pred, b.pred, Bits/o{pred: r})
        rec
    }
  }

Bits.sub(a: Bits, b: Bits): Bits
  call aux = Bits.sub.aux(a, b, Bits/e)
  call sub = Bits.reverse(aux)
  sub

Bits.mul.aux(a: Bits, b: Bits, r: Bits): Bits
  case b : Bits { 
    e: r
    o:
      call rec = Bits.mul.aux(Bits/o{pred: a}, b.pred, r)
      rec
    i:
      call add = Bits.add(a, r)
      call rec = Bits.mul.aux(Bits/o{pred:a}, b.pred, add)
      rec
  }

Bits.mul(a: Bits, b: Bits): Bits
  call mul = Bits.mul.aux(a, b, Bits/e)
  mul

////////////

Bits.take(n: Nat, xs: Bits): Bits
  case n : Nat {
    zero: Bits/e
    succ: case xs : Bits {
      e: Bits/e
      o: 
        call rec = Bits.take(n.pred, xs.pred)
        Bits/o{pred: rec}
      i:
        call rec = Bits.take(n.pred, xs.pred)
        Bits/i{pred: rec}
    }
  }

Bits.drop(n: Nat, xs: Bits): Bits
 case n : Nat {
   zero: xs
   succ: case xs : Bits { 
     e: xs
     o:
       call rec = Bits.drop(n.pred, xs.pred)
       rec
     i:
       call rec = Bits.drop(n.pred, xs.pred)
       rec
   }
 }

//Comparisons

Bits.cmp.aux(a: Bits, b: Bits, c: Cmp): Cmp
  case a : Bits { 
    e: case b : Bits {
      e: c
      o:
        call rec = Bits.cmp.aux(Bits/e, b.pred, c)
        rec
      i: Cmp/ltn
    }
    o: case b : Bits { 
      e:
        call rec = Bits.cmp.aux(a.pred, Bits/e, c)
        rec
      o:
        call rec = Bits.cmp.aux(a.pred, b.pred, c)
        rec
      i:
        call rec = Bits.cmp.aux(a.pred, b.pred, Cmp/ltn)
        rec
      }
    i: case b : Bits { 
      e: Cmp/gtn
      o: 
        call rec = Bits.cmp.aux(a.pred, b.pred, Cmp/gtn)
        rec
      i:
        call rec = Bits.cmp.aux(a.pred, b.pred, c)
        rec
    }
  }


Bits.eql(a: Bits, b: Bits): Bool
  case a : Bits { 
    e: case b : Bits { 
      e: Bool/true
      o: Bool/false
      i: Bool/false
    }
    o: case b : Bits { 
      e: Bool/false
      o:
        call rec = Bits.eql(a.pred, b.pred)
        rec
      i: Bool/false
    }
    i: case b : Bits { 
      e: Bool/false
      o: Bool/false
      i: 
        call rec = Bits.eql(a.pred, b.pred)
        rec
    }
  }

Bits.cmp(a: Bits, b: Bits): Cmp
  call cmp = Bits.cmp.aux(a, b, Cmp/eql)
  cmp

Bits.gte(a: Bits, b: Bits): Bool
  call cmp = Bits.cmp(a,b)
  call gte = Cmp.as_gte(cmp)
  gte

Bits.gtn(a: Bits, b: Bits): Bool
  call cmp = Bits.cmp(a,b)
  call gtn = Cmp.as_gtn(cmp)
  gtn

Bits.lte(a: Bits, b: Bits): Bool
  call cmp = Bits.cmp(a,b)
  call lte = Cmp.as_lte(cmp)
  lte

Bits.ltn(a: Bits, b: Bits): Bool
  call cmp = Bits.cmp(a,b)
  call ltn = Cmp.as_ltn(cmp)
  ltn

Bits.dup(a: Bits): Pair.Bits
  case a : Bits {
    e:
      Bits/new{fst: Bits/e, snd: Bits/e}
    o:
      Bits/new
    i:
  }
`
