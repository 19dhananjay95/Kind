// Litereum: a minimal decentralized computer
// ==========================================

// TODO:
// - merge type-checking and validation / allow reusing word terms
// - cost measure, WIP r√≠gille
// - Lit.Core.Term.get_caller ?
// - owned types/constructors ?
// - conseguir modificar o dono no Lit.Core.Term.bind
// - block difficulty (nakamoto consensus)
// - Lit.Lang:
//   - consertar parser para ir ate o final do arquivo !
//
// - paper:
//   - use railroad diagrams for syntax

//
// Types
// -----

// A Litereum term
type Lit.Core.Term {
  // A variable
  var(
    name: String
  )
  // Creates a value
  create(
    type: String
    ctor: Nat
    vals: List<Lit.Core.Term>
  )
  // Pattern-matches a value
  match(
    name: String
    type: String
    expr: Lit.Core.Term
    cses: List<Lit.Core.Term.Case>
  )
  // Creates a new 64-bit word
  word(
    numb: U64
  )
  // Compares two words
  compare(
    val0: Lit.Core.Term
    val1: Lit.Core.Term
    iflt: Lit.Core.Term
    ifeq: Lit.Core.Term
    ifgt: Lit.Core.Term
  )
  // Word addition
  operate(
    oper: Lit.Core.Operation
    val0: Lit.Core.Term
    val1: Lit.Core.Term
  )
  // Calls an external program
  call(
    name: String
    func: String
    args: List<Lit.Core.Term>
    cont: Lit.Core.Term
  )
  // Binds an new program
  bind(
    name: String
    main: Lit.Core.Term   // TODO rename to `body`
    cont: Lit.Core.Term
  )
}

// An operation
type Lit.Core.Operation {
  add
  sub
  mul
  div
  mod
  or
  and
  xor
}

// A pattern-matching case
type Lit.Core.Term.Case {
  new(
    fields: List<String>
    body: Lit.Core.Term
  )
}

// Lit.Core types are algebraic datatypes (ADTs)
type Lit.Core.Type {
  word
  data(
    name: String
    constructors: List<Lit.Core.Type.Constructor>
  )
}

// A constructor of an ADT
type Lit.Core.Type.Constructor {
  new(
    name: String
    fields: List<Lit.Core.Type.Field>
  )
}

// A field of an ADT's constructor
type Lit.Core.Type.Field {
  new(
    name: String
    type: String
  )
}

// A function
type Lit.Core.Bond {
  new(
    name: String
    owners: List<String>
    main: Lit.Core.Term
    input_names: List<String>
    input_types: List<String>
    output_type: String
  )
}

// A Lit.Core global entry
type Lit.Core.Entry {
  type(value: Lit.Core.Type)
  bond(value: Lit.Core.Bond)
}

// Lit.Core's global state
Lit.Core.World: Type
  Map<Lit.Core.Entry>

// A paragraph in a Litereum page
type Lit.Core.Statement {
  define(entry: Lit.Core.Entry)
  call(expr: Lit.Core.Term)
}

// A page of the Litereum book
Lit.Core.Page: Type
  List<Lit.Core.Statement>

type Lit.Core.Costs {
  new(
    var: Nat
    create: Nat
    match: Nat
    compare: Nat
    operate: Nat
    call: Nat
  )
}

Lit.Core.Costs.default: Lit.Core.Costs
  Lit.Core.Costs.new(
    Nat.pow(2, 8*0)
    Nat.pow(2, 8*1)
    Nat.pow(2, 8*2)
    Nat.pow(2, 8*3)
    Nat.pow(2, 8*4)
    Nat.pow(2, 8*5)
  )

//
// Getters and Setters
// -------------------

Lit.Core.World.get_type(name: String, world: Lit.Core.World): Maybe<Lit.Core.Type>
  if name =? "U64" then
    some(Lit.Core.Type.word)
  else
    case world{name} as entry {
      some: case entry.value {
        type: some(entry.value.value)
      } default none
    } default none

Lit.Core.World.get_func(name: String, world: Lit.Core.World): Maybe<Lit.Core.Bond>
  case world{name} as entry {
    some: case entry.value {
      bond: some(entry.value.value)
    } default none
  } default none

Lit.Core.Type.find_ctor(name: String, type: Lit.Core.Type): Maybe<Pair<Nat,Lit.Core.Type.Constructor>>
  case type {
    word:
      none
    data:
      List.ifind!((i,f) String.eql(f@name,name), type.constructors)
  }

//
// Type-Checking
// -------------

Lit.Core.Type.equal(a: Lit.Core.Type, b: Lit.Core.Type): Bool
  case a b {
    word word: true
    data data: String.eql(a.name, b.name)
  } default false

type Lit.Core.Check.Context {
  new(
    world: Lit.Core.World
    caller: Maybe<String>
    variables: Map<Lit.Core.Type>
  )
}

Lit.Core.Check.Context.from_world(world: Lit.Core.World): Lit.Core.Check.Context
  Lit.Core.Check.Context.new(world, none, {})

Lit.Core.Check.Context.add_var(
  context: Lit.Core.Check.Context
  name: String
  type: Lit.Core.Type
): Lit.Core.Check.Context
  open context
  let new_variables = context.variables{name} <- type
  Lit.Core.Check.Context.new(context.world, context.caller, new_variables)

Lit.Core.World.check.term(
  context: Lit.Core.Check.Context
  term: Lit.Core.Term
  type: Lit.Core.Type
): Bool
  // log("- chk: " | Lit.Lang.show.term(term, context@world) | " : " | Lit.Lang.show.type.short(type))  // DEBUG
  // log("- ctx: " | String.join(", ", List.map!!((a) a@fst|":"|Lit.Lang.show.type.short(a@snd), Map.to_list!(variables))))  // DEBUG
  // log("")  // DEBUG
  let result = case term {
    var:
      let var_type = context@variables{term.name} abort false
      //log("-- var " | term.name | " " | Lit.Lang.show.type.short(var_type) | " " | Lit.Lang.show.type.short(type))  // DEBUG
      Lit.Core.Type.equal(var_type, type)
    create:
      //log("-- create")  // DEBUG
      let ttyp = Lit.Core.World.get_type(term.type, context@world) abort false
      case ttyp {
        data:
          use ctor = ttyp.constructors[term.ctor] abort false
          let args = Lit.Core.World.check.many(context, term.vals, List.mapped!(ctor.fields)!((x) x@type))
          args && Lit.Core.Type.equal(ttyp, type)
      } default false
    call:
      //log("-- call")  // DEBUG
      // verify owner
      let ownr = Lit.Core.World.check.owner(context, term.func)
      use func = Lit.Core.World.get_func(term.func, context@world) abort false
      use otyp = Lit.Core.World.get_type(func.output_type, context@world) abort false
      let args = Lit.Core.World.check.many(context, term.args, func.input_types)
      let context_new = Lit.Core.Check.Context.add_var(context, term.name, otyp)
      let cont = Lit.Core.World.check.term(context_new, term.cont, type)
      ownr && args && cont
    match:
      //log("-- match ")  // DEBUG
      let expr_type = Lit.Core.World.get_type(term.type, context@world) abort false
      //log("-- match2 ")  // DEBUG

      case expr_type {
        data:
          let expr = Lit.Core.World.check.term(context, term.expr, expr_type)
          let cses = List.mapped!(term.cses)!((x) x@body)
          let cses = Lit.Core.World.check.match.cases(context, cses, type, expr_type.constructors, term.name)
          expr && cses
      } default false
    bind:
      //log("-- bind ")  // DEBUG
      // TODO: check access
      let owner_ok = Lit.Core.World.check.owner(context, term.name)
      use func = Lit.Core.World.get_func(term.name, context@world) abort false
      use out_type = Lit.Core.World.get_type(func.output_type, context@world) abort false
      let nofn_ok = List.is_empty!(func.input_names)  // TODO: should we allow binds with functions?
      let main_ok = Lit.Core.World.check.term(context, term.main, out_type)
      // should the ctx change?
      let cont_ok = Lit.Core.World.check.term(context, term.cont, type)
      owner_ok && nofn_ok && main_ok && cont_ok
    word:
      //log("-- word ")  // DEBUG
      case type {
        word:
          true
      } default
        log("not word")
        false
    compare:
      //log("-- compare ")  // DEBUG
      let val0 = Lit.Core.World.check.term(context, term.val0, Lit.Core.Type.word)
      let val1 = Lit.Core.World.check.term(context, term.val0, Lit.Core.Type.word)
      let iflt = Lit.Core.World.check.term(context, term.iflt, type)
      let ifeq = Lit.Core.World.check.term(context, term.ifeq, type)
      let ifgt = Lit.Core.World.check.term(context, term.ifgt, type)
      val0 && val1 && iflt && ifeq && ifgt
    operate:
      //log("-- operate ")  // DEBUG
      let val0 = Lit.Core.World.check.term(context, term.val0, Lit.Core.Type.word)
      let val1 = Lit.Core.World.check.term(context, term.val1, Lit.Core.Type.word)
      val0 && val1
  }
  //log("\n")
  result

Lit.Core.World.check.many(
  context: Lit.Core.Check.Context,
  terms: List<Lit.Core.Term>
  types: List<String>
): Bool
  case terms types {
    cons cons:
      let type = Lit.Core.World.get_type(types.head, context@world) abort false
      let head = Lit.Core.World.check.term(context, terms.head, type)
      let tail = Lit.Core.World.check.many(context, terms.tail, types.tail)
      head && tail
    nil nil:
      true
  } default false

Lit.Core.World.check.match.cases(
  context: Lit.Core.Check.Context
  cases: List<Lit.Core.Term>
  type: Lit.Core.Type
  ctors: List<Lit.Core.Type.Constructor>
  name: String
): Bool
  open context
  case cases ctors {
    cons cons:
      let ext_variables = context.variables
      
      for field in ctors.head@fields with ext_variables:
        let field_type =
          Lit.Core.World.get_type(field@type, context.world)
            <> Lit.Core.Type.data("Empty", [])
        ext_variables{name | "." | field@name} <- field_type
      let new_context = Lit.Core.Check.Context.new(
        context.world
        context.caller
        ext_variables
      )
      let case_ok = Lit.Core.World.check.term(new_context, cases.head, type)
      let rest_ok = Lit.Core.World.check.match.cases(new_context, cases.tail, type, ctors.tail, name)
      case_ok && rest_ok
    nil nil:
      true
  } default false

Lit.Core.World.check.owner(
  context: Lit.Core.Check.Context
  name: String
): Bool
  open context
  let entry = context.world{name}
  case entry {
    none: false
    some: 
      case entry.value as func {
        bond: 
          use f = func.value
          case f.owners {
            nil:
              true
            cons:
              case context.caller as caller {
                some:
                  if caller.value =? name then
                    true
                  else
                    List.in!(String.eql(caller.value), f.owners)
                none:
                  false
              }
          }
      } default false
  }

//
// Execution
// ---------

//Pair<Lit.Core.Term, Lit.Core.World>
type Lit.Core.run.Context {
  new(
    term: Lit.Core.Term
    world: Lit.Core.World
    gas: Nat
  )
}

Lit.Core.World.run.page(
  page: Lit.Core.Page
  world: Lit.Core.World
): Maybe<Lit.Core.World>
  case page {
    nil:
      some(world)
    cons:
      case Lit.Core.World.run.statement(page.head, world) as new_world {
        none:
          none
        some:
          Lit.Core.World.run.page(page.tail, new_world.value)
      }
  }

Lit.Core.World.run.statement(
  statement: Lit.Core.Statement
  world: Lit.Core.World
): Maybe<Lit.Core.World>
  let result = case statement {
    define:
      case statement.entry {
        type:
          let type = statement.entry.value
          case type {
            word:
              log("error: word as an entry definition")
              none
            data: 
              log("- new_type: " | type.name)
              case world{type.name} as got_type {
                none:
                  if not(type.name =? "U64") then
                    some(world{type.name} <- Lit.Core.Entry.type(type))
                  else
                    log("error: cannot redefine built-in type named 'U64'") none
              } default log("error: type redefinition: " | type.name) none
          }
        bond:
          use func = statement.entry.value
          log("- new_func: " | func.name | List.show!(Function.id!, func.owners))
          case world{func.name} as got {
            none:
              let new_world = world{func.name} <- Lit.Core.Entry.bond(func)
              let ctx = some({})
              let args = List.zip!!(func.input_names, func.input_types)
              let ctx = for arg in args:
                Maybe {
                let {arg_name, arg_type} = arg
                get ctx = ctx
                get typ = Lit.Core.World.get_type(arg_type, world)
                return ctx{arg_name} <- typ
              }
              let vld = {}
              let vld = for iarg in func.input_names:
                vld{iarg} <- false
              case ctx {
                none:
                  log("error: func input type undefined: " | func.name) none
                some:
                  let otyp = Lit.Core.World.get_type(func.output_type, world)
                    abort log("error: func otyp not found: " | func.name) none
                  let new_context =
                    Lit.Core.Check.Context.new(
                      new_world
                      some(func.name)
                      ctx.value
                    )
                  let term_ok = Lit.Core.World.check.term(
                      new_context
                      func.main
                      otyp
                    )
                  if term_ok then
                    some(new_world)
                  else
                    log("error: func ill-typed: " | func.name) none
              }
          } default log("error: func redefinition: " | func.name) none
      }
    call:
      let exec_term = statement.expr
      // log(Lit.Lang.show.term(exec_term, world))  // DEBUG
      // This assumes that the call returns the built-in type Word to avoid
      // duplicating the typechecking function.
      let call_type = Lit.Core.Type.word
      let context = Lit.Core.Check.Context.from_world(world)
      let term_ok = Lit.Core.World.check.term(context, exec_term, call_type)
      if term_ok then
        use ctx =
          Lit.Core.World.run.term(exec_term, world, {}, _) // TODO
          log("- ext_exec: " | Lit.Lang.show.term(ctx.term, world))
        some(ctx.world)
      else
        log("error: exec failed in typecheck") none
  }
  // log("")  // DEBUG
  result

Lit.Core.World.run.term(
  term: Lit.Core.Term
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
  gas: Nat
): Lit.Core.run.Context
  // log("- run " | Lit.Lang.show.term(term,world)) // DEBUG
  // log("- var " | String.join(", ", List.map!!((x) x@fst|":"|Lit.Lang.show.term(x@snd,world), Map.to_list!(vars)))) // DEBUG
  // log("")
  case term {
    var:
      Lit.Core.World.run.term.var(world, vars, term.name)
    create:
      Lit.Core.World.run.term.create(world, vars, term.type, term.ctor, term.vals)
    match:
      Lit.Core.World.run.term.match(world, vars, term.name, term.type, term.expr, term.cses)
    word:
      {term, world, gas}
    compare:
      Lit.Core.World.run.term.compare(world, vars, term.val0, term.val1, term.iflt, term.ifeq, term.ifgt)
    operate:
      Lit.Core.World.run.term.operate(world, vars, term.oper, term.val0, term.val1)
    call:
      Lit.Core.World.run.term.call(world, vars, term.name, term.func, term.args, term.cont)
    bind:
      Lit.Core.World.run.term.bind(world, vars, term.name, term.main, term.cont)
  }

Lit.Core.World.run.terms(
  terms: List<Lit.Core.Term>
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
  gas: Nat
): Triple<List<Lit.Core.Term>, Lit.Core.World, Nat>
  case terms {
    nil:
      {[], world, gas}
    cons:
      //let {head, world} = Lit.Core.World.run.term(terms.head, world, vars, _) // TODO
      use ctx = Lit.Core.World.run.term(terms.head, world, vars, gas) // TODO
      use tail = Lit.Core.World.run.terms(terms.tail, ctx.world, vars, ctx.gas)
      {ctx.term & tail.fst, tail.snd, tail.trd}
  }
Lit.Core.World.run.term.call(
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
  name: String
  func: String
  args: List<Lit.Core.Term>
  cont: Lit.Core.Term
): Lit.Core.run.Context
  case world{func} as got {
    none:
      //{Lit.Core.Term.call(name, func, args, cont), world}
      _ // TODO
    some:
      case got.value as entry {
        bond:
          use func = entry.value
          let inner_vars = vars
          let state = {inner_vars, world}
          for arg in List.zip!!(func.input_names, args) with state:
            let {inner_vars, world} = state
            let {arg_name, arg_term} = arg
            use ctx = Lit.Core.World.run.term(arg_term, world, inner_vars, _)
            let _ = Lit.Core.run.term.check_sanity(ctx.term)  // DEBUG-ish
            let inner_vars = inner_vars{arg_name} <- ctx.term
            {inner_vars, ctx.world}
          let {inner_vars, world} = state
          //let {done, world} = Lit.Core.World.run.term(func.main, world, inner_vars, _)
          use ctx = Lit.Core.World.run.term(func.main, world, inner_vars, _)
          let _ = Lit.Core.run.term.check_sanity(ctx.term)  // DEBUG-ish
          let vars = vars{name} <- ctx.term
          Lit.Core.World.run.term(cont, ctx.world, vars, _) // TODO
      } default
        //{Lit.Core.Term.call(name, func, args, cont), world}
        _ // TODO
  }

Lit.Core.World.run.term.compare(
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
  val0: Lit.Core.Term
  val1: Lit.Core.Term
  iflt: Lit.Core.Term
  ifeq: Lit.Core.Term
  ifgt: Lit.Core.Term
): Lit.Core.run.Context
  //let {val0, world} = Lit.Core.World.run.term(val0, world, vars, _) // TODO
  use ctx0 = Lit.Core.World.run.term(val0, world, vars, _) // TODO
  //let {val1, world} = Lit.Core.World.run.term(val1, ctx.world, vars, _) // TODO
  use ctx1 = Lit.Core.World.run.term(val1, ctx0.world, vars, _) // TODO
  case ctx0.term ctx1.term {
    word word:
      case U64.cmp(ctx0.term.numb, ctx1.term.numb) {
        ltn:
          Lit.Core.World.run.term(iflt, world, vars, _) // TODO
        eql:
          Lit.Core.World.run.term(ifeq, world, vars, _) // TODO
        gtn:
          Lit.Core.World.run.term(ifgt, world, vars, _) // TODO
      }
  } default
    //log("error: operands didn't reduce to words") {Lit.Core.Term.compare(val0, val1, iflt, ifeq, ifgt), world}
    _ // TODO


Lit.Core.World.run.term.match(
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
  name: String
  type: String
  expr: Lit.Core.Term
  cses: List<Lit.Core.Term.Case>
): Lit.Core.run.Context
  //let {expr, world} = Lit.Core.World.run.term(expr, world, vars, _) // TODO
  use ctx = Lit.Core.World.run.term(expr, world, vars, _) // TODO
  case ctx.term {
    create: case cses[ctx.term.ctor] as selected_case {
      some: 
        let {case_fields, case_body} = selected_case.value
        let vars = for subst in List.zip!!(case_fields, ctx.term.vals):
          let {field, value} = subst
          vars{field} <- value
        Lit.Core.World.run.term(case_body, ctx.world, vars, _) // TODO
    } default
      //{Lit.Core.Term.match(name, type, ctx.term, cses), world}
      _ // TODO
  } default
    //{Lit.Core.Term.match(name, type, ctx.term, cses), world}
    _ // TODO

Lit.Core.World.run.term.create(
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
  type: String
  ctor: Nat
  vals: List<Lit.Core.Term>
): Lit.Core.run.Context
  let {vals, world} = Lit.Core.World.run.terms(vals, world, vars, _) //TODO
  //{Lit.Core.Term.create(type, ctor, vals), world}
  _ // TODO

Lit.Core.World.run.term.var(
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
  name: String
): Lit.Core.run.Context
  case vars{name} as got {
    none:
      //{Lit.Core.Term.var(name), world}
      _ // TODO
    some:
      Lit.Core.World.run.term(got.value, world, vars, _) // TODO
  }

Lit.Core.World.run.term.operate(
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
  oper: Lit.Core.Operation
  val0: Lit.Core.Term
  val1: Lit.Core.Term
): Lit.Core.run.Context
  let {val0, world} = Lit.Core.World.run.term(val0, world, vars, _) // TODO
  let {val1, world} = Lit.Core.World.run.term(val1, world, vars, _) // TODO
  case val0 val1 {
    word word:
      case oper {
        add:
          //{Lit.Core.Term.word(val0.numb + val1.numb), world}
          _ // TODO
        sub:
          //{Lit.Core.Term.word(val0.numb - val1.numb), world}
          _ // TODO
        mul:
          //{Lit.Core.Term.word(val0.numb * val1.numb), world}
          _ // TODO
        div:
          //{Lit.Core.Term.word(val0.numb / val1.numb), world}
          _ // TODO
        mod:
          //{Lit.Core.Term.word(val0.numb % val1.numb), world}
          _ // TODO
        or:
          //{Lit.Core.Term.word(val0.numb || val1.numb), world}
          _ // TODO
        and:
          //{Lit.Core.Term.word(val0.numb && val1.numb), world}
          _ // TODO
        xor:
          //{Lit.Core.Term.word(U64.xor(val0.numb, val1.numb)), world}
          _ // TODO
      }
  } default
    //log("error: operand didn't reduce to word")
    //{Lit.Core.Term.operate(oper, val0, val1), world}
    _ // TODO

Lit.Core.World.run.term.bind(
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
  name: String
  main: Lit.Core.Term
  cont: Lit.Core.Term
): Lit.Core.run.Context
  case world{name} as got {
    none:
      //{Lit.Core.Term.bind(name, main, cont), world}
      _ // TODO
    some:
      case got.value as entry {
        bond:
          use func = entry.value
          //let {main, world} = Lit.Core.World.run.term(main, world, vars, _) // TODO
          use ctx = Lit.Core.World.run.term(main, world, vars, _) // TODO
          let world = ctx.world{name} <- Lit.Core.Entry.bond(func@main <- ctx.term)
          Lit.Core.World.run.term(cont, world, vars, _) // TODO
      } default
        //{Lit.Core.Term.bind(name, main, cont), world}
        _ // TODO
  }

Lit.Core.run.term.check_sanity(term: Lit.Core.Term): Bool
  case term {
    var:
      log("==> SANITY CHECK FAILED: found term: " | "'" | term.name | "'")
      false
    create:
      let valid = true
      for val in term.vals with valid:
        valid && Lit.Core.run.term.check_sanity(val)
      valid
    match:
      let valid = Lit.Core.run.term.check_sanity(term.expr)
      for cse in term.cses with valid:
        valid && Lit.Core.run.term.check_sanity(cse@body)
      valid
    word:
      true
    compare:
      Lit.Core.run.term.check_sanity(term.val0)
        && Lit.Core.run.term.check_sanity(term.val1)
        && Lit.Core.run.term.check_sanity(term.iflt)
        && Lit.Core.run.term.check_sanity(term.ifeq)
        && Lit.Core.run.term.check_sanity(term.ifgt)
    operate:
      Lit.Core.run.term.check_sanity(term.val0)
        && Lit.Core.run.term.check_sanity(term.val1)
    call:
      // TODO I don't know what I'm doing
      // should this return false (invalid) ?
      let valid = true
      for arg in term.args with valid:
        valid && Lit.Core.run.term.check_sanity(arg)
      valid && Lit.Core.run.term.check_sanity(term.cont)
    bind:
      Lit.Core.run.term.check_sanity(term.main)
        && Lit.Core.run.term.check_sanity(term.cont)
  }


//
// Tests
// -----

Lit.Core: _
  let world = {}

  let code = ""

  let code = code |
    Lit.Lang.Type
    | Lit.Lang.Cmp
    | Lit.Lang.Nat
    | Lit.Lang.Bits
    | Lit.Lang.BitsMap
    | Lit.Lang.Test

  let code = code |
  `
    GiveUnit(): Unit
      Unit/new

    TakeUnit(x: Unit): U64
      42

    do {
      call a1 = GiveUnit()
      call a2 = GiveUnit()
      call b = TakeUnit(a1)
      call c = TakeUnit(a2)
      (+ b c)
    }
  `

  // let code = code |
  // `
  //   //type Lit.Core.Operation {
  //   //  add ok!
  //   //  sub ok!
  //   //  mul ok!
  //   //  div ok!
  //   //  mod ok!
  //   //  or  ok!
  //   //  and ok!
  //   //  xor ok!
  //   //}
  //   WordTest(): U64
  //     cmp 2 3 {
  //       ltn: 
  //         0
  //       eql: 
  //         1
  //       gtn: 
  //         2
  //     }
  //   do {
  //     call b = WordTest()
  //     b
  //   }
  // `

  let page = Parser.run!(Lit.Lang.parser.page(world), code) abort IO.print("parse error")

  // log("PARSED:")   // DEBUG
  // log(Lit.Lang.show.page(page, world))   // DEBUG

  case Lit.Core.World.run.page(page, world) as result {
    none:
      IO.print("FAILURE")
    some:
      IO {
        // log("PAGE:")  // DEBUG
        // let new_world = result.value  // DEBUG
        // log(Lit.Lang.show.page(page, new_world))  // DEBUG
        IO.print("SUCCESS")
      }
  }
