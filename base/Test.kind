Ok: Nat
  2

MultiArg<A: Type>(n: Nat): Type
  case n {
    zero: A
    succ: A -> MultiArg<A>(n.pred)
  }

Kind.Term.Shorthand(name: Kind.Name, n: Nat): MultiArg<Kind.Term>(n)
  case n {
    zero: Kind.Term.ref(name)
    succ:
      (out_arg)
        let outer = (inn_arg) Kind.Term.app(inn_arg, out_arg)
        let ind = Kind.Term.Shorthand(name, n.pred)
        MultiArg.comp<Kind.Term, n.pred>(outer, ind)
  }!

MultiArg.comp<A: Type>(n: Nat, outer: A -> A, inner: MultiArg<A>(n)): MultiArg<A>(n)
  case n with inner {
    zero:
      let ret = outer(inner)
      ret
    succ:
      (x) MultiArg.comp<A, n.pred>(outer, inner(x))
  }!

Test: _
  let add = Kind.Term.Shorthand("Nat.add", 2)
  add(Kind.Term.nat(Ok), Kind.Term.nat(3))
