// Empty
. Empty : Type = $self {-P : {self : Empty} Type} (P self)

// Unit
. Unit : Type = $self {-P : {:Unit} Type} {:(P unit)} (P self)
. unit : Unit = @Unit [-P] [U] U

// Booleans
. Bool  : Type = $self {-P : {:Bool} Type} {:(P true)} {:(P false)} (P self)
. true  : Bool = @Bool [-P] [T] [F] T
. false : Bool = @Bool [-P] [T] [F] F

// Boolean induction
. Bool.induct
: {b : Bool} {P : {:Bool} Type} {:(P true)} {:(P false)} (P b)
= [b] [P] [T] [F] (~b -P T F)

// Boolean negation (fusible)
. Bool.not
: {b  : Bool} Bool
= [b] @Bool [-P] [T] [F] (~b -[b](P (Bool.not b)) F T)

// Boolean negation (non-fusible)
. Bool.slow_not
: {b : Bool} Bool
= [b] (~b -[b]Bool false true)

// Natural numbers (Scott, inductive)
. Nat            : Type = $self {-P : {:Nat} Type} {S : {n : Nat} (P (succ n))} {Z : (P zero)} (P self)
. succ [n : Nat] : Nat  = @Nat [-P] [S] [Z] (S n)
. zero           : Nat  = @Nat [-P] [S] [Z] Z

// Nat numbers
. Nat.0 Nat.zero
. Nat.1 (Nat.succ Nat.0)
. Nat.2 (Nat.succ Nat.1)
. Nat.3 (Nat.succ Nat.2)

// Natural numbers (Church, non-inductive)
. Cat                : Type = {-P : Type} {S : ! {:P} P} ! {Z : P} P
. Cat.succ [n : Cat] : Cat  = [-P] [S] [S = S] [A = (n -P #S)] # [Z] (S (A Z))
. Cat.zero           : Cat  = [-P] [S] [S = S] # [Z] Z

// Cat addition
. Cat.add
: {a : Cat} {b : Cat} Cat
= [a] [b] [-P] [s]
  [S = s]
  [A = (a -P #S)]
  [B = (b -P #S)]
# [z] (A (B z)) 

// Cat multiplication
. Cat.mul
: {a : Cat} {b : Cat} Cat
= [a] [b] [-P] [s]
  [S = s]
  (a -P (b -P #S))

// Cat numbers
. Cat.0  Cat.zero
. Cat.1  (Cat.succ Cat.0)
. Cat.2  (Cat.succ Cat.1)
. Cat.3  (Cat.succ Cat.2)
. Cat.4  (Cat.mul Cat.2 Cat.2)
. Cat.8  (Cat.mul Cat.4 Cat.2)
. Cat.16 (Cat.mul Cat.8 Cat.2)
. Cat.32 (Cat.mul Cat.16 Cat.2)
. Cat.64 (Cat.mul Cat.32 Cat.2)

// Natural numbers (Parigot, erased to Church, inductive)
. Rat                : Type = $self {-P : {:Rat} Type} {S : ! {-n : Rat} {h : (P n)} (P (Rat.succ n))} ! {Z : (P Rat.zero)} (P self)
. Rat.succ [n : Rat] : Rat  = @Rat [-P] [S] [S = S] [A = (~n -P #S)] # [Z] (S -n (A Z))
. Rat.zero           : Rat  = @Rat [-P] [S] [S = S] # [Z] Z

// Cat numbers
. Rat.0 Rat.zero
. Rat.1 (Rat.succ Rat.0)
. Rat.2 (Rat.succ Rat.1)
. Rat.3 (Rat.succ Rat.2)
. Rat.4 (Rat.succ Rat.3)

// Rat induction (but it increases a level)
. Rat.induct
: {n : Rat} {-P : {:Rat} Type} {:!{n : Rat}{:(P n)}(P (Rat.succ n))} !{:(P Rat.zero)} (P n)
= [a] [-P] [s] [S = s] [A = (~a -[n](P n) #S)] # [z] (A z)

// Rat identity (fusible)
. Rat.id
: {n : Rat} Rat
= [n] @Rat [-P] [S] [S = S] [F = (~n -[n] (P (Rat.id n)) #[-n] [h] (S -(Rat.id n) h))] # [Z] (F Z)

// Rat identity (non-fusible)
. Rat.slow_id
: {n : Rat} !Rat
= [n] [F = (~n -[s]Rat #[-n][h](Rat.succ h))] # (F Rat.zero)

// Rat double
. Rat.double
: {n : Rat} Rat
= [n] @Rat [-P] [S] [S = S]
  let motive [n] (P (Rat.double n))
  let case_s #[-n] [h] (S -(Rat.succ (Rat.double n)) (S -(Rat.double n) h))
  [F = (~n -motive case_s)]
  # [Z] (F Z)

// Rat addition
. Rat.add
: {a : Rat} {b : Rat} Rat
= [a] [b] @Rat [-P] [s]
  [S = s]
  [A = (~a -[a](P (Rat.add a b)) #[-n] [h] (S -(Rat.add n b) h))]
  [B = (~b -[b](P (Rat.add Rat.zero b)) #[-n] [h] (S -(Rat.add Rat.zero n) h))]
# [z] (A (B z)) 

// Rat multiplication
//. Rat.mul
//: {a : Rat} {b : Rat} Rat
//= [a] [b] @Rat [-P] [s] [S = s]
  //let A (~a -?)
  //let B (~b -? #[-n] [h] (S -(Rat.add b n) h))
  //(A B)

// Tests non-fusible id (72 rewrites)
. non_fusible_id_test (Rat.slow_id Rat.4)

// Tests fusible id (23 rewrites!)
. fusible_id_test (Rat.id Rat.4)

. main fusible_id_test
