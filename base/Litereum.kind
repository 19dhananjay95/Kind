// Litereum: a minimal decentralized computer
// ==========================================

// Types
// -----

// A Litereum program can:
// - Create algebraic datatypes
// - Perform pattern-matching
// - Call other programs
// - Store a local state
// It is a minimal calculus, with state, comms, and no lambdas.
// Pattern-matching is linear, to preserve the cost model.
type Litereum.Term {
  var(
    index: Nat
  )
  alloc(
    type: Nat
    form: Nat
    vals: List<Litereum.Term>
  )
  match(
    type: Nat
    name: String
    expr: Litereum.Term
    cses: List<Litereum.Term>
  )
  call(
    func: Nat
    argm: Litereum.Term
    cont: Litereum.Term
  )
  //store(
    //stat: Litereum.Term 
    //cont: Litereum.Term
  //)
}

// Litereum types are algebraic datatypes (ADTs)
type Litereum.Type {
  adt(
    name: String
    forms: List<Litereum.Form>
  )
}

// Litereum function
type Litereum.Func {
  new(
    term: Litereum.Term
    //stty: Litereum.Type
    inty: Nat
    outy: Nat
  )
}

// A constructor of an ADT
type Litereum.Form {
  new(
    name: String
    fields: List<Litereum.Field>
  )
}

// A field of an ADT's constructor
type Litereum.Field {
  new(
    name: String
    type: Nat
  )
}

// Litereum's global state
type Litereum.World {
  new(
    names: List<String>        // registered names
    types: List<Litereum.Type> // registered types
    funcs: List<Litereum.Func> // registered funcs
    state: Map<Litereum.Term>  // contract states
  )
}

// A private key is a set of 32 words
Litereum.Private: Type
  Vector<U256, 32>

// A public key is the hash^32 of the private key
Litereum.Public: Type
  Vector<U256, 32>

// An address is the hash of a public key
Litereum.Address: Type
  U256

// A hash is a 256-bit word
Litereum.Hash: Type
  U256

// A signature is a set of 32 words
// - 30 words sign the first 30 bytes of the message hash
// -  2 words sign the checksum
Litereum.Signature: Type
  Vector<U256, 32>

// The 32 bytes to be signed by a signature
Litereum.Summary: Type
  Vector<U8, 32>

// The body of a Litereum Post can hold up to 8 words
Litereum.Body: Type
  Vector<U256,8>

// Actions
// -------

Litereum.World.register_name(
  name: String
  world: Litereum.World
): Litereum.World
  world@names <- world@names ++ [name]

Litereum.World.register_type(
  type: Litereum.Type
  world: Litereum.World
): Litereum.World
  world@types <- world@types ++ [type]

Litereum.World.register_func(
  func: Litereum.Func
  world: Litereum.World
): Litereum.World
  world@funcs <- world@funcs ++ [func]

Litereum.World.set_state(
  term: Nat
  value: Litereum.Term
  world: Litereum.World
): Litereum.World
  world@state <- (world@state{Nat.show(term)} <- value)

// Utils
// -----

Litereum.World.find_type(name: String, world: Litereum.World): Maybe<Pair<Nat,Litereum.Type>>
  List.ifind!((i,t) String.eql(t@name,name), world@types)

Litereum.Type.find_form(name: String, type: Litereum.Type): Maybe<Pair<Nat,Litereum.Form>>
  List.ifind!((i,t) String.eql(t@name,name), type@forms)

// Type-Checking
// -------------

Litereum.World.check.fields(
  terms: List<Litereum.Term>
  fields: List<Litereum.Field>
  ctx: List<Litereum.Type>
  world: Litereum.World
): Bool
  open world
  case terms fields {
    cons cons:
      let type = world.types[fields.head@type] abort false
      let head = Litereum.World.check(terms.head, type, ctx, world)
      let tail = Litereum.World.check.fields(terms.tail, fields.tail, ctx, world)
      head && tail
    nil nil:
      true
  } default false

Litereum.World.check.cases(
  cases: List<Litereum.Term>
  type: Litereum.Type
  forms: List<Litereum.Form>
  ctx: List<Litereum.Type>
  world: Litereum.World
): Bool
  case cases forms {
    cons cons:
      let ext_ctx = Litereum.World.check.cases.extend(forms.head@fields, ctx, world) abort false
      let case_ok = Litereum.World.check(cases.head, type, ext_ctx, world)
      let rest_ok = Litereum.World.check.cases(cases.tail, type, forms.tail, ctx, world)
      case_ok && rest_ok
    nil nil:
      true
  } default false

Litereum.World.check.cases.extend(
  fields: List<Litereum.Field>
  ctx: List<Litereum.Type>
  world: Litereum.World
): Maybe<List<Litereum.Type>>
  open world
  case fields {
    nil: Maybe {
      return ctx
    }
    cons: Maybe {
      get type = world.types[fields.head@type]
      get tail = Litereum.World.check.cases.extend(fields.tail, ctx, world)
      return type & tail
    }
  }

Litereum.World.check(
  term: Litereum.Term
  type: Litereum.Type
  ctx: List<Litereum.Type>
  world: Litereum.World
): Bool
  log("- check " | Literity.show(term,world,[],0) | " : " | Litereum.Type.show(type))
  open world
  case term {
    var:
      let var_type = ctx[term.index] abort false
      //log("-- var " | Litereum.Type.show(var_type) | " " | Litereum.Type.show(type))
      Litereum.Type.equal(var_type, type)
    alloc: case type {
      adt:
        use term_type = world.types[term.type] abort false
        if Litereum.Type.equal(term_type, type) then
          use form = type.forms[term.form] abort false
          Litereum.World.check.fields(term.vals, form.fields, ctx, world)
        else
          false
    }
    match:
      use expr_type = world.types[term.type] abort false
      let expr = Litereum.World.check(term.expr, expr_type, ctx, world)
      expr && Litereum.World.check.cases(term.cses, type, expr_type.forms, ctx, world)
  } default false

Litereum.World.check.func(
  func: Nat
  world: Litereum.World
): Bool
  open world
  use func = world.funcs[func] abort false
  let inty = world.types[func.inty] abort false
  let outy = world.types[func.outy] abort false
  let ctx = [inty]
  Litereum.World.check(func.term, outy, ctx, world)

// Execution
// ---------

Litereum.World.run(term: Litereum.Term, world: Litereum.World, vars: List<Litereum.Term>): Maybe<Pair<Litereum.Term, Litereum.World>>
  log("- eval " | Literity.show(term, world, [], 0))
  open world
  case term {
    var: Maybe {
      get value = vars[term.index]
      Litereum.World.run(value, world, vars)
      //return {value,world}
    }
    match: Maybe {
      get expr_run = Litereum.World.run(term.expr, world, vars)
      let {expr, world} = expr_run
      case expr {
        alloc: Maybe {
          get body = term.cses[expr.form]
          let vars = List.reverse!(expr.vals) ++ vars
          Litereum.World.run(body, world, vars)
        }
      } default some({term,world})
    }
    alloc: Maybe {
      get run_vals = Litereum.World.run.many(term.vals, world, vars)
      let {vals, world} = run_vals
      return {Litereum.Term.alloc(term.type, term.form, vals), world}
    }
    call: Maybe {
      get func = world.funcs[term.func]
      Litereum.World.run(func@term, world, vars)
    }
  } default some({term,world})

Litereum.World.run.many(terms: List<Litereum.Term>, world: Litereum.World, vars: List<Litereum.Term>): Maybe<Pair<List<Litereum.Term>, Litereum.World>>
  case terms {
    nil: some({[], world})
    cons: Maybe {
      get run_head = Litereum.World.run(terms.head, world, vars)
      let {head, world} = run_head
      get run_tail = Litereum.World.run.many(terms.tail, world, vars)
      let {tail, world} = run_tail
      return {head & tail, world}
    }
  }

Litereum.World.run.func(func: Nat, input: Litereum.Term, world: Litereum.World): Maybe<Pair<Litereum.Term, Litereum.World>>
  open world
  Maybe {
    get func = world.funcs[func]
    let vars = [input]
    Litereum.World.run(func@term, world, vars)
  }

// Printing
// --------

Litereum.Type.show(type: Litereum.Type): String
  case type {
    adt: type.name
  }

Litereum.Type.equal(a: Litereum.Type, b: Litereum.Type): Bool
  case a b {
    adt adt: String.eql(a.name, b.name)
  } default false

// Serialization
// -------------

Litereum.Body.deserializer: Deserializer<Litereum.Body>
  Vector.deserializer!(8,U256.deserializer)

Litereum.Body.serializer: Serializer<Litereum.Body>
  Vector.serializer!(8,U256.serializer)

Litereum.Signature.deserializer: Deserializer<Litereum.Signature>
  Vector.deserializer!(32,U256.deserializer)

Litereum.Signature.serializer: Serializer<Litereum.Signature>
  Vector.serializer!(32,U256.serializer)

Litereum.Hash.serializer: Serializer<Litereum.Hash>
  U256.serializer

Litereum.Hash.deserializer: Deserializer<Litereum.Hash>
  U256.deserializer

// Signatures
// ----------

// Takes the Keccak hash of a list of words
Litereum.Hash.from_words(words: List<U256>): Litereum.Hash
  Crypto.Keccak.hash.words(words)

// Hashes a buffer into a 1024-byte signable string
Litereum.Summary.from_bytes(len_bytes: Pair<U32,Buffer8>): Litereum.Summary
  let vals = Buffer8.to_list(Crypto.Keccak.hash.bytes(len_bytes))
  let csum = 7650 :: U32
  let csum = for i from 2 to List.length!(vals): csum - U8.to_u32(vals[i] <> 0)
  let vals = vals[0] <- U32.to_u8(U32.div(csum, 256))
  let vals = vals[1] <- U32.to_u8(U32.mod(csum, 256))
  let vals = Vector.from_list.length!(32, 0, vals)
  vals

// Converts a list of words to a signable
Litereum.Summary.from_words(words: List<U256>): Litereum.Summary
  Litereum.Summary.from_bytes(Buffer8.from_list.256(words))

// Converts a UTF-8 string to a signable
Litereum.Summary.from_utf8(str: String): Litereum.Summary
  Litereum.Summary.from_bytes(Buffer8.from_hex(String.to_hex(str)))

// Converts a seed to a private key
Litereum.Private.from_seed(seed: U256): Litereum.Private
  Litereum.Private.from_seed.go(32, seed)

Litereum.Private.from_seed.go(len: Nat, seed: U256): Vector<U256,len>
  case len {
    zero:
      Vector.nil!
    succ:
      let head = Litereum.Hash.from_words([U256.add(seed, Nat.to_u256(len))])
      let tail = Litereum.Private.from_seed.go(len.pred, seed)
      Vector.cons<U256,len.pred>(head, tail)
  }!

// Coverts a private key to an address
Litereum.Public.from_private(pvt: Litereum.Private): Litereum.Private
  Litereum.Public.from_private.go(32, pvt)

Litereum.Public.from_private.go(len: Nat, pvt: Vector<U256,len>): Vector<U256,len>
  case len with pvt {
    zero: Vector.nil!
    succ: case pvt {
      cons:
        let hash = pvt.head
        let hash = for i from 0 to 256:
          Litereum.Hash.from_words([hash])
        Vector.cons<U256,len.pred>(hash, Litereum.Public.from_private.go(len.pred, pvt.tail))
    }
  }!

// Converts a public key to an address
Litereum.Address.from_public(pub: Litereum.Public): Litereum.Address
  let vals = Buffer8.from_list.256(Vector.to_list!(32, pub))
  let addr = Buffer8.to_u256(Crypto.Keccak.hash.bytes(vals)@snd)
  addr

// Signs a signable
Litereum.Signature.sign(msg: Litereum.Summary, pvt: Litereum.Private): Litereum.Signature
  Litereum.Signature.sign.go(32, msg, pvt)

Litereum.Signature.sign.go(len: Nat, msg: Vector<U8,len>, pvt: Vector<U256,len>): Vector<U256,len>
  case len with msg pvt {
    zero: case msg pvt {
      nil nil: Vector.nil!
    }
    succ: case msg pvt {
      cons cons:
        let hash = pvt.head
        let hash = for i from 0 to 256 - U8.to_nat(msg.head):
          Litereum.Hash.from_words([hash])
        Vector.cons<U256,len.pred>(hash, Litereum.Signature.sign.go(len.pred, msg.tail, pvt.tail))
    }
  }!

// Verifies if a signature is correct
Litereum.Signature.verify(msg: Litereum.Summary, addr: Litereum.Address, sig: Litereum.Signature): Bool
  let checksums = Litereum.Signature.checksum(msg)
  let sign_addr = Litereum.Signature.recover(msg, sig)
  checksums && U256.eql(addr, sign_addr)

// Checks if the signable checksum is correct
Litereum.Signature.checksum(msg: Litereum.Summary): Bool
  Litereum.Signature.checksum.go(32, msg)

Litereum.Signature.checksum.go(len: Nat, msg: Vector<U8,len>): Bool
  let vals = Vector.to_list<U8>(len, msg)
  let csum = 7650 :: U32
  let csum = for i from 2 to List.length!(vals):
    csum - U8.to_u32(vals[i] <> 0)
  let cs_0 = U8.to_u32(vals[0] <> 0)
  let cs_1 = U8.to_u32(vals[1] <> 0)
  U32.eql(csum, U32.add(U32.mul(cs_0, 256), cs_1))

// Returns the public key that signed a message
Litereum.Signature.recover(msg: Litereum.Summary, sig: Litereum.Signature): Litereum.Address
  Litereum.Address.from_public(Litereum.Signature.recover.go(32, msg, sig))

Litereum.Signature.recover.go(len: Nat, msg: Vector<U8,len>, sig: Vector<U256,len>): Vector<U256,len>
  case len with msg sig {
    zero: Vector.nil!
    succ: case msg sig {
      cons cons cons:
        let hash = sig.head
        let hash = for i from 0 to U8.to_nat(msg.head): Litereum.Hash.from_words([hash])
        Vector.cons<U256,len.pred>(hash, Litereum.Signature.recover.go(len.pred, msg.tail, sig.tail))
    }
  }!

// Tests
// -----

Litereum.read(code: String, world: Litereum.World): Litereum.Term
  Parser.run!(Literity.parser.func(world),code) <> Litereum.Term.var(0)

Litereum: _

  let world = Litereum.World.new([], [], [], {})
  let world = Litereum.World.register_type(Litereum.Type.adt("Bool", [Litereum.Form.new("true", []), Litereum.Form.new("false", [])]), world)
  let world = Litereum.World.register_type(Litereum.Type.adt("Nat", [Litereum.Form.new("zero", []), Litereum.Form.new("succ", [ Litereum.Field.new("pred", 1) ]) ]), world)
  let world = Litereum.World.register_type(Litereum.Type.adt("NatPair", [Litereum.Form.new("new", [Litereum.Field.new("fst", 1), Litereum.Field.new("snd", 1) ]) ]), world)

  let func  = Litereum.read("NatPair#case input as val { new: Nat#succ{pred: val.fst} }", world)
  let argm  = Litereum.read("NatPair#new{ fst: Nat#zero, snd: Nat#zero }", world)
  let world = Litereum.World.register_func(Litereum.Func.new(func, 2, 1), world)

  IO {
    IO.print("term: " | Literity.show(func, world, [], 0))
    IO.print("chck: " | Bool.show(Litereum.World.check.func(0, world)))
    IO.print("norm: " | case Litereum.World.run.func(0, argm, world) as norm {
      none: "error"
      some: Literity.show(norm.value@fst, norm.value@snd, [], 0)
    })
  }
