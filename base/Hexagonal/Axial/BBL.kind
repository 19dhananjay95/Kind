Hexagonal.Axial.BBL<A : Type> : Type
   BBL<Hexagonal.Axial, A>

Hexagonal.Axial.Cmp(
  x: Hexagonal.Axial,
  y: Hexagonal.Axial
): Cmp
  let c = I32.cmp(x@i, y@i)
  case c {
    eql: I32.cmp(x@j, y@j)
  } default c

Hexagonal.Axial.BBL.insert<A : Type>(key : Hexagonal.Axial, val : A, map : Hexagonal.Axial.BBL<A>) : Hexagonal.Axial.BBL<A>
    BBL.insert!!(Hexagonal.Axial.Cmp, key, val, map)

Hexagonal.Axial.BBL.get<A : Type>(key : Hexagonal.Axial, map : Hexagonal.Axial.BBL<A>) : Maybe<A>
    BBL.lookup!!(Hexagonal.Axial.Cmp, key map)

Hexagonal.Axial.BBL.delete<A : Type>(key : Hexagonal.Axial, map : Hexagonal.Axial.BBL<A>) : Hexagonal.Axial.BBL<A>
    BBL.delete!!(Hexagonal.Axial.Cmp, key, map)

Hexagonal.Axial.BBL.union<A : Type>(map : Hexagonal.Axial.BBL<A>) : Hexagonal.Axial.BBL<A> -> Hexagonal.Axial.BBL<A>
    BBL.union!!(Hexagonal.Axial.Cmp, map)

Hexagonal.Axial.BBL.keys<A : Type>(map : Hexagonal.Axial.BBL<A>) : List<Hexagonal.Axial>
    BBL.foldr_with_key!!!((key, value, list) key & list, [], map)

Hexagonal.Axial.BBL.values<A : Type>(map : Hexagonal.Axial.BBL<A>) : List<A>
    BBL.foldr_with_key!!!((key, value, list) value & list, [], map)

Hexagonal.Axial.BBL.values<A : Type, B : Type>(f : A -> B, map : Hexagonal.Axial.BBL<A>) : List<B>
    BBL.map!!(f, map)

Hexagonal.Axial.BBL.to_list<A: Type>(map: Hexagonal.Axial.BBL<A>): List<Pair<Hexagonal.Axial,A>>
    BBL.to_list!!(map)

Hexagonal.Axial.BBL.from_list<A: Type>(list: List<Pair<Hexagonal.Axial,A>>): Hexagonal.Axial.BBL<A>
  BBL.from_list!!(Hexagonal.Axial.Cmp, list)

Hexagonal.Axial.BBL.new<A : Type> : Hexagonal.Axial.BBL<A>
    BBL.tip!!

Hexagonal.Axial.BBL<A : Type> : Type
   BBL<Hexagonal.Axial, A>

