// Litereum: a minimal decentralized computer
// ==========================================

// TODO:
// - cost measure
// - check do call.cont
// - Lit.Core.Term.get_caller
// - tipo "Bits" nativo no bloco genesis
// - conseguir modificar o dono no Lit.Core.Term.bind
// - revisar e usar a função validate
// - block difficulty (nakamoto consensus)
// - owned types/constructors?
// - melhorar mensagens de erro
// - Lit.Lang:
//   - consertar parser para ir ate o final do arquivo?
//   - do blocks (um "with" anonimo, sem assinatura)
//   - open?
// - paper:
//   - use railroad diagrams for syntax

// Types
// -----

// A Litereum term
type Lit.Core.Term {
  // A variable
  var(
    name: String
  )
  // Creates a value
  create(
    type: String
    form: Nat
    vals: List<Lit.Core.Term>
  )
  // Pattern-matches a value
  match(
    type: String
    name: String
    expr: Lit.Core.Term
    cses: List<Pair<List<String>,Lit.Core.Term>>
  )
  // Calls an external program
  call(
    name: String
    func: String
    args: List<Lit.Core.Term>
    cont: Lit.Core.Term
  )
  // Binds an new program
  bind(
    name: String
    main: Lit.Core.Term
    cont: Lit.Core.Term
  )
}

// Lit.Core types are algebraic datatypes (ADTs)
type Lit.Core.Type {
  adt(
    name: String
    forms: List<Lit.Core.Type.Form>
  )
}

// A constructor of an ADT
type Lit.Core.Type.Form {
  new(
    name: String
    fields: List<Lit.Core.Type.Field>
  )
}

// A field of an ADT's constructor
type Lit.Core.Type.Field {
  new(
    name: String
    type: String
  )
}

// A user
type Lit.Core.User {
  new(
    name: String
    pkey: String
  )
}

// A function
type Lit.Core.Func {
  new(
    name: String
    ownr: List<String>
    main: Lit.Core.Term
    iarg: List<String>
    ityp: List<String>
    otyp: String
  )
}

// An external call
type Lit.Core.Exec {
  new(
    user: String
    sign: String
    expr: Lit.Core.Term
  )
}

// A paragraph in a Litereum page
type Lit.Core.Line {
  new_type(value: Lit.Core.Type)
  new_func(value: Lit.Core.Func)
  new_user(value: Lit.Core.User)
  ext_exec(value: Lit.Core.Exec)
}

// A page of the Litereum book
Lit.Core.Page: Type
  List<Lit.Core.Line>

// A Lit.Core global entry
type Lit.Core.Entry {
  type(value: Lit.Core.Type)
  func(value: Lit.Core.Func)
  user(value: Lit.Core.User)
}

// Lit.Core's global state
Lit.Core.World: Type
  Map<Lit.Core.Entry>

// Getters and Setters
// -------------------

Lit.Core.World.get_type(name: String, world: Lit.Core.World): Maybe<Lit.Core.Type>
  case world{name} as entry {
    some: case entry.value {
      type: some(entry.value.value)
    } default none
  } default none
  
Lit.Core.World.get_func(name: String, world: Lit.Core.World): Maybe<Lit.Core.Func>
  case world{name} as entry {
    some: case entry.value {
      func: some(entry.value.value)
    } default none
  } default none

Lit.Core.World.get_user(name: String, world: Lit.Core.World): Maybe<Lit.Core.User>
  case world{name} as entry {
    some: case entry.value {
      user: some(entry.value.value)
    } default none
  } default none

Lit.Core.Type.find_form(name: String, type: Lit.Core.Type): Maybe<Pair<Nat,Lit.Core.Type.Form>>
  case type {
    adt: List.ifind!((i,f) String.eql(f@name,name), type.forms)
  }

// Type-Checking
// -------------

Lit.Core.Type.equal(a: Lit.Core.Type, b: Lit.Core.Type): Bool
  case a b {
    adt adt: String.eql(a.name, b.name)
  } default false

Lit.Core.World.check.term(
  term: Lit.Core.Term
  type: Lit.Core.Type
  ctx: Map<Lit.Core.Type>
  world: Lit.Core.World
): Bool
  //log("- chk " | Lit.Lang.show.term(term,world) | " : " | Lit.Lang.show.type.short(type))
  //log("- ctx " | String.join(", ", List.map!!((a) a@fst|":"|Lit.Lang.show.type.short(a@snd), Map.to_list!(ctx))))
  //log("")
  open world
  case term {
    var:
      let var_type = ctx{term.name} abort false
      //log("-- var " | Lit.Core.Type.show(var_type) | " " | Lit.Core.Type.show(type))
      Lit.Core.Type.equal(var_type, type)
    create: case type {
      adt:
        use term_type = Lit.Core.World.get_type(term.type,world) abort false
        if Lit.Core.Type.equal(term_type, type) then
          use form = type.forms[term.form] abort false
          Lit.Core.World.check.many(term.vals, List.mapped!(form.fields)!((x) x@type), ctx, world)
        else
          false
    }
    call:
      use func = Lit.Core.World.get_func(term.func,world) abort false
      use otyp = Lit.Core.World.get_type(func.otyp,world) abort false
      let ctx2 = ctx{term.name} <- otyp
      let args = Lit.Core.World.check.many(term.args, func.ityp, ctx, world)
      let cont = Lit.Core.World.check.term(term.cont, type, ctx2, world)
      args && cont
    match:
      let expr_type = Lit.Core.World.get_type(term.type,world) abort false
      case expr_type {
        adt:
          let expr = Lit.Core.World.check.term(term.expr, expr_type, ctx, world)
          let cses = List.mapped!(term.cses)!((x) x@snd)
          let cses = Lit.Core.World.check.match.cases(cses, type, expr_type.forms, term.name, ctx, world)
          expr && cses
      }
    bind:
      // TODO: check access
      use func = Lit.Core.World.get_func(term.name,world) abort false
      use otyp = Lit.Core.World.get_type(func.otyp,world) abort false
      let nofn = List.is_empty!(func.iarg) // should we allow binds with functions?
      let main = Lit.Core.World.check.term(term.main, otyp, ctx, world)
      // should the ctx change?
      let cont = Lit.Core.World.check.term(term.cont, type, ctx, world)
      nofn && main && cont
  } default false

Lit.Core.World.check.many(
  terms: List<Lit.Core.Term>
  types: List<String>
  ctx: Map<Lit.Core.Type>
  world: Lit.Core.World
): Bool
  open world
  case terms types {
    cons cons:
      let type = Lit.Core.World.get_type(types.head, world) abort false
      let head = Lit.Core.World.check.term(terms.head, type, ctx, world)
      let tail = Lit.Core.World.check.many(terms.tail, types.tail, ctx, world)
      head && tail
    nil nil:
      true
  } default false

Lit.Core.World.check.match.cases(
  cases: List<Lit.Core.Term>
  type: Lit.Core.Type
  forms: List<Lit.Core.Type.Form>
  name: String
  ctx: Map<Lit.Core.Type>
  world: Lit.Core.World
): Bool
  case cases forms {
    cons cons:
      let ext_ctx = ctx
      for field in forms.head@fields with ext_ctx:
        let type = Lit.Core.World.get_type(field@type, world) <> Lit.Core.Type.adt("Empty", [])
        ext_ctx{name | "." | field@name} <- type
      let case_ok = Lit.Core.World.check.term(cases.head, type, ext_ctx, world)
      let rest_ok = Lit.Core.World.check.match.cases(cases.tail, type, forms.tail, name, ctx, world)
      case_ok && rest_ok
    nil nil:
      true
  } default false

// Validation
// ----------

// Checks if:
// - no global binders with the same name
// - variables are used at most once
Lit.Core.World.validate(
  term: Lit.Core.Term
  used: Map<Bool>
): Pair<Map<Bool>,Bool>
  //log("- vld " | String.join(", ", List.map!!((a) a@fst|":"|Bool.show(a@snd), Map.to_list!(used)))) // DEBUG
  //log("") // DEBUG
  case term {
    var:
      //log("var") // DEBUG
      //log(term.name)
      case used{term.name} as was_used {
        none:
          // undefined variable
          {used, false}
        some: 
          if was_used.value then
            //log("here")
            // variable already used
            {used, false}
          else
            //log("there")
            // first use of the variable
            {used{term.name} <- true, true}
      }
    create:
      //log("create") // DEBUG
      let state = {used, true}
      let state = for val in term.vals:
        let {used, res0} = state
        let {used, res1} = Lit.Core.World.validate(val, used)
        {used, res0 && res1}
      state
    match:
      //log("match") // DEBUG
      let state = Lit.Core.World.validate(term.expr, used)
      let valid = true
      let valid = for cse in term.cses:
        //log("cse")
        let {fields, body} = cse
        let field_state = state
        let field_state = for field in fields:
          //log("field: "|field)
          let {used, resx} = field_state
          case used{field} as got {
            some:
              //log("some")
              {used, false} // same name used more than once
            none:
              //log("none")
              {used{field} <- false, resx}
          }
        field_state@snd
      {state@fst, valid}
    call:
      //log("call") // DEBUG
      let state = {used, true}
      let state = for arg in term.args:
        let {used, res0} = state
        let {used, res1} = Lit.Core.World.validate(arg, used)
        {used, res0 && res1}
      state
    bind:
      //log("bind") // DEBUG
      let used = used{term.name} <- false
      let {used, res0} = Lit.Core.World.validate(term.main, used)
      let {used, res1} = Lit.Core.World.validate(term.cont, used)
      {used, res0 && res1}
  }

// Execution
// ---------

Lit.Core.World.run.page(
  page: Lit.Core.Page
  world: Lit.Core.World
): Maybe<Lit.Core.World>
  case page {
    nil: some(world)
    cons: case Lit.Core.World.run.line(page.head, world) as new_world {
      none: none
      some: Lit.Core.World.run.page(page.tail, new_world.value)
    }
  }


Lit.Core.World.run.line(
  line: Lit.Core.Line
  world: Lit.Core.World
): Maybe<Lit.Core.World>
  case line {
    new_type:
      // TODO: check something?
      let type = line.value
      case type {
        adt: 
          log("- new_type: " | type.name)
          case world{type.name} as got_type {
            none: some(world{type.name} <- Lit.Core.Entry.type(type))
          } default log("error: type redefinition: " | type.name) none
      }
    new_func:
      use func = line.value
      log("- new_func: " | func.name | List.show!(Function.id!, func.ownr))
      case world{func.name} as got {
        none:
          let new_world = world{func.name} <- Lit.Core.Entry.func(func)
          let ctx = some({})
          let ctx = for arg in List.zip!!(func.iarg, func.ityp): Maybe {
            let {arg_name, arg_type} = arg
            get ctx = ctx
            get typ = Lit.Core.World.get_type(arg_type, world)
            return ctx{arg_name} <- typ
          }
          let vld = {}
          let vld = for iarg in func.iarg:
            vld{iarg} <- false
          case ctx {
            none:
              log("error: func input type undefined: " | func.name) none
            some:
              let otyp = Lit.Core.World.get_type(func.otyp, world) abort log("error: func otyp not found: " | func.name) none
              if Lit.Core.World.check.term(func.main, otyp, ctx.value, new_world) then
                let {ah, ok} = Lit.Core.World.validate(func.main, vld)
                if ok then
                  //log("here")
                  some(new_world)
                else
                  //log("there")
                  log("error: func invalid: " | func.name) none
              else
                log("error: func ill-typed: " | func.name) none
          }
      } default log("error: func redefinition: " | func.name) none
    new_user:
      use user = line.value
      log("- new_user: " | user.name)
      case world{user.name} as got {
        none: some(world{user.name} <- Lit.Core.Entry.user(user))
      } default log("error: user redefinition: " | user.name) none
    ext_exec:
      use exec = line.value
      case world{exec.user} as got_entry {
        some: case got_entry.value as entry {
          user: 
            use user = entry.value
            let {result, world} = Lit.Core.World.run.term(exec.expr, exec.user, world, {})
            log("- ext_exec: " | Lit.Lang.show.term(result, world))
            some(world)
        } default log("error: exec user not a user") none
      } default log("error: exec user undefined") none
  }

Lit.Core.World.run.term(
  term: Lit.Core.Term
  self: String
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
): Pair<Lit.Core.Term, Lit.Core.World>
  //log("- run " | Lit.Lang.show.term(term,world)) // DEBUG
  //log("- var " | String.join(", ", List.map!!((x) x@fst|":"|Lit.Lang.show.term(x@snd,world), Map.to_list!(vars)))) // DEBUG
  //log("")
  case term {
    var: 
      //log("var") // DEBUG
      case vars{term.name} as got {
        none: {term, world}
        some: Lit.Core.World.run.term(got.value, self, world, vars)
      }
    match: Maybe {
      //log("match") // DEBUG
      let {expr, world} = Lit.Core.World.run.term(term.expr, self, world, vars)
      case expr {
        create: case term.cses[expr.form] as selected_case {
          some: 
            let {case_fields, case_body} = selected_case.value
            let vars = for subst in List.zip!!(case_fields, expr.vals):
              let {field, value} = subst
              vars{field} <- value
            Lit.Core.World.run.term(case_body, self, world, vars)
        } default {term, world}
      } default {term,world}
    }
    create:
      //log("create") // DEBUG
      let {vals, world} = Lit.Core.World.run.terms(term.vals, self, world, vars)
      {Lit.Core.Term.create(term.type, term.form, vals), world}
    call:
      //log("call") // DEBUG
      case world{term.func} as got {
      none:
        {term, world}
      some: case got.value as entry {
        func:
          use func = entry.value
          let main_vars = vars
          let state = {main_vars, world}
          let state = for arg in List.zip!!(func.iarg, term.args):
            let {main_vars, world} = state
            let {arg_name, arg_term} = arg
            let {arg_term, world} = Lit.Core.World.run.term(arg_term, self, world, main_vars)
            let main_vars = main_vars{arg_name} <- arg_term
            {main_vars, world}
          let {main_vars, world} = state
          let {done, world} = Lit.Core.World.run.term(func.main, term.func, world, main_vars)
          let vars = vars{term.name} <- done
          Lit.Core.World.run.term(term.cont, self, world, vars)
      } default {term,world}
    }
    bind:
      //log("bind") // DEBUG
      case world{term.name} as got {
      none:
        {term, world}
      some: case got.value as entry {
        func:
          use func = entry.value
          let {main, world} = Lit.Core.World.run.term(term.main, self, world, vars)
          let world = world{term.name} <- Lit.Core.Entry.func(func@main <- main)
          Lit.Core.World.run.term(term.cont, self, world, vars)
      } default {term, world}
    }
  } default {term,world}

Lit.Core.World.run.terms(
  terms: List<Lit.Core.Term>
  self: String
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
): Pair<List<Lit.Core.Term>, Lit.Core.World>
  case terms {
    nil:
      {[], world}
    cons:
      let {head, world} = Lit.Core.World.run.term(terms.head, self, world, vars)
      let {tail, world} = Lit.Core.World.run.terms(terms.tail, self, world, vars)
      {head & tail, world}
  }

// Tests
// -----
Lit.Core: _
  let world = {}
  let code = Lit.Lang.Type|Lit.Lang.Cmp|Lit.Lang.Nat|Lit.Lang.Bits|Lit.Lang.BitsMap|`
type BoolList {
  nil
  cons{
    head: Bool
    tail: NatList
  }
}

type NatList {
  nil
  cons{
    head: Nat
    tail: BoolList
  }
}

Count(): Bits
  Bits/o{pred: Bits/e}

Count.inc(): Unit
  call c = Count();
  call d = Bits.inc(c);
  bind Count = d;
  Unit/new

user MrDog {
  01234
}

with MrDog {
  call ret = Count.inc()
  call c = Count()
  call ret = Bits.add(Bits/i{pred:Bits/i{pred: Bits/e}}, Bits/i{pred: Bits/e})
  call dupped = Bits.dup(ret)
  dupped
} signed {
  confia
}
`
//  let code = `
//    user MrDog {
//      0123456789abcdef
//    }
//
//    type Unit {
//      new
//    }
//
//    type Bool {
//      true
//      false
//    }
//
//    type Nat {
//      zero
//      succ{pred: Nat}
//    }
//
//    type NatBool {
//      new{
//        x: Nat
//        y: Bool
//      }
//    }
//
//    not(x: Bool): Bool
//      case x : Bool {
//        true: Bool/false
//        false: Bool/true
//      }
//
//    double(x: Nat): Nat
//      case x : Nat {
//        zero:
//          Nat/zero
//        succ:
//          call rest = double(x.pred)
//          Nat/succ{pred: Nat/succ{pred: rest}}
//      }
//
//    Nat.pred(x: Nat): Nat
//      case x : Nat {
//        zero: Nat/zero
//        succ: x.pred
//      }
//
//    with MrDog {
//      call n = double(Nat/succ{pred: Nat/succ{pred: Nat/succ{pred: Nat/zero}}})
//      call b = not(Bool/true)
//      NatBool/new{x: n, y: b}
//    } signed { 0123abcd }
//
//    Count.dec, Count.inc @ COUNT(): Nat
//      Nat/zero
//
//    Count.inc(): Unit
//      call count = COUNT()
//      bind COUNT = Nat/succ{pred: count}
//      Unit/new
//
//    Count.dec(): Unit
//      Unit/new
//
////    with MrDog {
////      call x = Count.inc()
////      call x = Count.inc()
////      call x = Count.inc()
////      call x = COUNT()
////      x
////    } signed { 0123abcd }
//  `
  let page = Parser.run!(Lit.Lang.parser.page(world), code) abort IO.print("parse error")
  case Lit.Core.World.run.page(page, world) as result {
    none:
      IO.print("failure")
    some:
      IO.print("success")
  }
