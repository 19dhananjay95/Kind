Kind.Comp.Target.scheme.shape_of(prim: Kind.Comp.Prim): Kind.Comp.Prim.Shape
  case prim {
    unit: Kind.Comp.Prim.Shape.new(
      // Inst
      [
        // Unit.new
        {0, "#t"}
      ]
      // Elim
      {"#t", [
        // case new
        {"#t", []}
      ]})
    bool: Kind.Comp.Prim.Shape.new(
      // Inst
      [
        // Bool.true
        {0, "#t"}
        // Bool.false
        {0, "#f"}
      ]
      // Elim
      {"$0", [
        // case true
        {"#t", []}
        // case false
        {"#f", []}
      ]})
    nat: Kind.Comp.Prim.Shape.new(
      // Inst
      [
        // Nat.zero
        {0, "0"}
        // Nat.succ
        {1, "(+ $0 1)"}
      ]
      // Elim
      {"(= $0 0)", [
        // case zero
        {"#t", []}
        // case succ
        {"#f", [
          // x.pred
          "(- $0 1)"
        ]}
      ]})
    u16: Kind.Comp.Prim.Shape.new(
      // Inst
      [
        // U16.new
        {1, "(word-to-u16 $0)"}
      ]
      // Elim
      {"#t", [
        // case new
        {"#t", [
          "(u16-to-word $0)" // x.value
        ]}
      ]})
    string: Kind.Comp.Prim.Shape.new(
      // Inst
      [
        // String.nil
        {0, "\"\""}
        // String.cons
        {2, "(string-append (make-string 1 (integer->char $0)) $1)"}
      ]
      // Elim
      {"(= (string-length $0) 0)", [
        // case nil
        {"#f", []}
        // case cons
        {"#t", [
          // x.head
          "(char->integer (string-ref $0 0))",
          // x.tail
          "(let ((_str_ $0)) (substring _str_ 1 (string-length _str_)))",
        ]}
      ]})
    data: Kind.Comp.Prim.Shape.new(
      // Inst
      List.fold!(prim.ctrs)!([], (ctr, result)
        let {ctr_name, ctr_fields} = ctr
        let fields_size = List.length!(ctr_fields)
        let fields_vars = String.join(" ", List.create!(3, (x) "$"|Nat.show(x)))
        {fields_size, "(vector '"|ctr_name|" "|fields_vars|")"} & result),
      // Elim
      {"(get $0 0)", List.fold!(prim.ctrs)!([], (ctr, result)
        let {ctr_name, ctr_fields} = ctr
        let fields_size = List.length!(ctr_fields)
        let fields_gets = List.create!(fields_size, (i) "(get $0 "|Nat.show(i)|")")
        {"'"|ctr_name, fields_gets} & result)
      })
  }

Kind.Comp.Target.scheme.instantiation(term: Kind.Comp): Maybe(String)
  case term {
    ins:
      let shape = Kind.Comp.Target.scheme.shape_of(term.prim)
      Kind.Comp.Prim.inst(shape, term.expr, Kind.Comp.Target.scheme.term)
  } default none

//function adt_type(adt) {
  //var inst = [];
  //var elim = {
    //ctag: x => x+"._",
    //ctor: [],
  //};
  //var cnam = [];
  //for (let i = 0; i < adt.length; ++i) {
    //inst.push([adt[i].flds.length, (function go(j, ctx) {
      //if (j < adt[i].flds.length) {
        //return x => go(j + 1, ctx.concat([x]));
      //} else {
        //var res = "({_:'"+adt[i].name+"'";
        //for (var k = 0; k < j; ++k) {
          //res += ",'"+adt[i].flds[k]+"':"+ctx[k];
        //};
        //res += "})";
        //return res;
      //};
    //})(0, [])]);
    //elim.ctor.push(adt[i].flds.map((n,j) => (x => x+"."+adt[i].flds[j])));
    //cnam.push(adt[i].name);
  //};
  //var cnam = {mode: "switch", nams: cnam};
  //return {inst, elim, cnam};
//};

Kind.Comp.Target.scheme(defs: Kind.Comp.Defs): String
  let defs = Kind.Map.to_list!(defs)
  let code = String.join("\n", [
    "(define-syntax def (syntax-rules () (($ name body) (define name (memo 'body)))))",
    "(define-syntax λ (syntax-rules () ((λ var bod) (lambda (var) bod))))",
    "(define (memo val) ((lambda (R) (lambda () (if (eq? R '_) (begin (set! R (eval val)) R) R))) '_))",
    "(define (print x) (begin (display x) (display \"\\n\")))",
    "(define get vector-ref)",
    "(define (print x)",
    "  (begin",
    "    (display x)",
    "    (display \"\\n\")))",
    "(define (word-to-u16 w)",
    "  (word-to-u16-go 0 w 0))",
    "(define (word-to-u16-go i w x)",
    "  (cond",
    "    ((= 16 i) x)",
    "    ((eq? 'Word.e (get w 0)) (word-to-u16-go (+ i 1) (vector 'Word.e) x))",
    "    ((eq? 'Word.o (get w 0)) (word-to-u16-go (+ i 1) (get w 1) x))",
    "    ((eq? 'Word.i (get w 0)) (word-to-u16-go (+ i 1) (get w 1) (fxior x (fxarithmetic-shift-left 1 i))))))",
    "(define (u16-to-word x)",
    "  (u16-to-word-go 0 x (vector 'Word.e)))",
    "(define (u16-to-word-go i x w)",
    "  (if (= 16 i) w",
    "    (u16-to-word-go (+ i 1) x",
    "      (if (= (fxand (fxarithmetic-shift-right x (- 15 i)) 1) 0)",
    "          (vector 'Word.o w)",
    "          (vector 'Word.i w)))))",
    "(define (Nat-inst n)",
    "  ((n 0) (lambda (n.pred) (+ 1 n.pred))))",
    "(define (Nat-elim n)",
    "  (if (= n 0)",
    "    (lambda (z) (lambda (s) z))",
    "    (lambda (z) (lambda (s) (s (- n 1))))))",
    "(define (U16-inst u)",
    "  (u (lambda (x) (word-to-u16 x))))",
    "(define (U16-elim u)",
    "  (lambda (t) (t (u16-to-word u))))",
    "(define (String-inst x)",
    "  ((x \"\") (lambda (h) (lambda (t) (string-append (make-string 1 (integer->char h)) t)))))",
    "(define (String-elim x)",
    "  (lambda (nil-case) (lambda (cons-case)",
    "    (if (= (string-length x) 0)",
    "      nil-case",
    "      ((cons-case",
    "        (char->integer (string-ref x 0)))",
    "        (substring x 1 (string-length x)))))))",
  ]) | "\n"
  for defn in defs with code:
    let {name, comp} = defn
    code
    | "(define (" | name | " x) "
      | Kind.Comp.Target.scheme.term(comp)
      | ")\n"
  code
  | "(display \"hello\")\n"
  | "(display \"\\n\")"


Kind.Comp.Target.scheme.term(comp: Kind.Comp): String
  let go = Kind.Comp.Target.scheme.term
  case comp {
    nil:
      "'()"
    var: // TODO: generate safe Scheme name
      comp.name
    ref: // TODO: generate safe Scheme name
      "(" | comp.name | ")"
    lam:
      "(lambda (" | comp.name | ") " | go(comp.body) | ")"
    app:
      "(" | go(comp.func) | " " | go(comp.argm) | ")"
    let:
      "(let ((" | comp.name | " " | go(comp.expr) | ")) " | go(comp.body) | ")"
    eli: case comp.prim {
      unit: "(Unit-elim " | go(comp.expr) | ")"
      bool: "(Bool-elim " | go(comp.expr) | ")"
      nat: "(Nat-elim " | go(comp.expr) | ")"
      u16: "(U16-inst " | go(comp.expr) | ")"
      string: "(String-elim " | go(comp.expr) | ")"
      data: go(comp.expr)
    }
    ins: case comp.prim {
      unit: "(Unit-inst " | go(comp.expr) | ")"
      bool: "(Bool-inst " | go(comp.expr) | ")"
      nat: "(Nat-inst " | go(comp.expr) | ")"
      u16: "(U16-inst " | go(comp.expr) | ")"
      string: "(String-inst " | go(comp.expr) | ")"
      data: go(comp.expr)
    }
    nat:
      Nat.show(comp.natx)
    chr:
      "#\\x" | Nat.to_string_base(16, U16.to_nat(comp.chrx))
    str:
      "\"" | comp.strx | "\""
  }
