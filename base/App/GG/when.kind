// Event handler
App.GG.when: App.When<App.GG.State>
  (event, state)
  let local = state@local
  let phase = local@phase
  case event {
    // init: 
      // log(U64.show(event.time))
      // let grid = local@grid
      // let slime = App.GG.Slime.find_coord(grid)
      // without slime: App.pass<App.GG.State>
      // let new_grid = App.GG.Creature.modify_at(App.GG.Creature.shuffle_folder(10000), slime@snd, grid) // U64.to_nat(event.time % 10000)
      // let new_local = local@grid <- new_grid
      // App.set_local<App.GG.State>(new_local)
    frame:
      case phase {
        setup:
          App.pass<App.GG.State>
        game:
          let new_grid  = App.GG.when.update_grid(local@grid)
          let new_phase = App.GG.when.update_phase(phase)
          let new_local = local@grid <- new_grid
          let new_local = new_local@phase <- new_phase
          App.set_local<App.GG.State>(new_local)
      }
      
    key_down:
      log("Key pressed: " |U16.show(event.code))
      case phase {
        setup:
          let table = phase.table
          switch U16.eql(event.code) {
            13#16:  App.GG.when.setup_to_game(local)
            37#16:  App.GG.when.move.chip_selection(local, App.GG.Arrow.left)
            38#16:  App.GG.when.move.chip_selection(local, App.GG.Arrow.up)
            39#16:  App.GG.when.move.chip_selection(local, App.GG.Arrow.right)
            40#16:  App.GG.when.move.chip_selection(local, App.GG.Arrow.down)
            27#16:  App.GG.when.return_chip(local)
            32#16:  App.GG.when.select_chip.space(local)
          }default  App.pass<App.GG.State> 
        game: 
          switch U16.eql(event.code) {
            37#16:  App.GG.when.move(local, App.GG.Arrow.left)
            38#16:  App.GG.when.move(local, App.GG.Arrow.up)
            39#16:  App.GG.when.move(local, App.GG.Arrow.right)
            40#16:  App.GG.when.move(local, App.GG.Arrow.down)
            // X 
            88#16:
              let new_grid = App.GG.when.basic_attack(local@grid)
              let new_local = local@grid <- new_grid
              App.set_local<App.GG.State>(new_local)
            // Spacebar
            32#16: 
              let new_grid = App.GG.when.use_chip(local@grid)
              let new_local = local@grid <- new_grid
              App.set_local<App.GG.State>(new_local)
            // Return
            13#16: App.GG.when.game_to_setup(local)
          }default App.pass<App.GG.State> 
      }
    mouse_move:
      // log("x: " | U32.show(event.mouse_pos@fst) | "  y: " | U32.show(event.mouse_pos@snd))
      let new_local = local@mouse <- event.mouse_pos
      App.set_local<App.GG.State>(new_local)
    mouse_down:
      App.GG.when.click_element(local, local@mouse)      
  }default App.pass<App.GG.State>

App.GG.when.update_grid(grid: App.GG.Grid): App.GG.Grid
  let new_grid = grid 
  for coord:tile in grid with new_grid:
    App.GG.when.update_tile(coord, new_grid)
  new_grid

App.GG.when.setup_to_game(local: App.GG.State.local): IO<Maybe<App.State.local<App.GG.State>>>
  let grid = local@grid
  case local@phase as phase {
    setup: 
      let new_grid = Maybe {
        get pair = App.GG.Slime.find_coord(grid)
        let {creature, coord} = pair
        get slime = 
          case creature@category as monster {
            minion: none
            slime: 
              let data = monster.data
              let hand = List.reverse!(phase.hand)
              let fold = List.somes!(List.map!!((x: App.GG.Table.Slot) x@chip, phase.table@slots)) ++ monster.folder
              let enrg = phase.energy
              some(App.GG.Monster.slime(data, hand, fold, enrg))
          }
        let new_grid = App.GG.Creature.modify_at((c: App.GG.Creature) c@category <- slime , coord, grid)
        return new_grid
      } <> grid
      let new_phase = App.GG.Phase.game(0#64)
      let new_local = local@grid <- new_grid
      let new_local = new_local@phase <- new_phase
      App.set_local<App.GG.State>(new_local)

    game: App.pass<App.GG.State>
  }

App.GG.when.game_to_setup(local: App.GG.State.local): IO<Maybe<App.State.local<App.GG.State>>>
  let grid = local@grid
  case local@phase as phase {
    setup: App.pass<App.GG.State>
    game:
      if U64.gte(phase.turn_bar, 1200) then
        let slime = App.GG.Slime.find_coord(grid)
        without slime: App.pass<App.GG.State>
        let {creature, coord} = slime
        case creature@category as monster {
          minion: App.pass<App.GG.State>
          slime:
            let table_size = 10
            let mod   = App.GG.Creature.sub_folder(table_size)
            let slots = App.GG.Table.from_folder(table_size, monster.folder)
            let hand = [] :: App.GG.Chips
            let energy = I32.min(monster.energy + monster.data@dna@attributes@energy, 100)
            let phase = App.GG.Phase.setup({slots, none}, hand, energy)
            let new_grid  = App.GG.Creature.modify_at(mod, coord, grid)
            let new_local = local@phase <- phase
            let new_local = new_local@grid <- new_grid
            App.set_local<App.GG.State>(new_local)
        }
      else
        App.pass<App.GG.State>
  }

// when users press space
// get the selected chip 
App.GG.when.select_chip.space(
  local: App.GG.State.local
): IO<Maybe<App.State.local<App.GG.State>>>
  open local
  case local.phase as phase {
    // only works if in setup phase
    setup:
      Maybe {
        let table = phase.table
        get selected_chip = table@selected
        let index = (selected_chip@snd * 5) + selected_chip@fst
        let index = U32.to_nat(index)
        // new_hand with the chip
        // new_table without the chip
        let new_local = local@phase <- App.GG.when.get_chip(index, phase)
        
        return App.set_local<App.GG.State>(new_local)
      } <> App.pass<App.GG.State>
  } default App.pass<App.GG.State>

// when user press the arrows buttons
// move the chip selection
App.GG.when.move.chip_selection(
  local: App.GG.State.local 
  arrow: App.GG.Arrow
): IO<Maybe<App.State.local<App.GG.State>>>
  open local
  case local.phase as phase {
    // only work in setup phase
    setup:
      let table = phase.table
      let new_table = case table@selected as selected {
        none:
          // case no chip was selected before
          // initialize in 0,0 
          table@selected <- some({0, 0})
        some:
          let selected  = selected.value
          // moving
          let new_value = case arrow {
            up:    selected@fst <- selected@fst - 1
            down:  selected@fst <- selected@fst + 1
            left:  selected@snd <- selected@snd - 1
            right: selected@snd <- selected@snd + 1
          }
          // checking bounds
          let new_value = {U32.mod(new_value@fst, 5), U32.mod(new_value@snd, 2)}
          table@selected <- some(new_value)
      }
      let new_local = local@phase <- App.GG.Phase.setup(new_table, phase.hand, phase.energy)
      App.set_local!(new_local)
  } default App.pass!

App.GG.when.move(local: App.GG.State.local, arrow: App.GG.Arrow): IO<Maybe<App.State.local<App.GG.State>>>
  let grid            = local@grid
  let slime_coord     = App.GG.Slime.find_coord(grid)
  without slime_coord : App.pass<App.GG.State>
  let {slime, coord}  = slime_coord
  let move_action     = App.GG.Actions.movement(arrow)
  let mod_creature    = App.GG.when.add_action(move_action)
  let new_grid        = App.GG.Creature.modify_at(mod_creature, coord, grid)
  let new_local       = local@grid <- new_grid
  App.set_local<App.GG.State>(new_local)

App.GG.when.click_element(local: App.GG.State.local, mouse: Pair<U32, U32>): IO<Maybe<App.State.local<App.GG.State>>>
  //log("x: " | U32.show(event.mouse_pos@fst) | "  y: " | U32.show(event.mouse_pos@snd))
  let phase = local@phase
  case phase {
    setup:
      let {x, y} = {mouse@fst / 4, mouse@snd / 4}
      let point = V2.new(U32.to_f64(x), U32.to_f64(y))
      switch Shape.Point.collision.rectangle(point) {
        App.GG.when.table:
          let x = x - (App.GG.Constants.chips_starting_position@fst - (App.GG.Constants.chip_size@fst/2))
          let y = y - (App.GG.Constants.chips_starting_position@snd - (App.GG.Constants.chip_size@snd/2))
          Maybe {
            get index = App.GG.when.chip({x, y})
            let updated_phase = App.GG.when.get_chip(index, phase)
            let new_local = local@phase <- updated_phase
            return App.set_local<App.GG.State>(new_local)
          } <> App.pass<App.GG.State>
      }default App.pass<App.GG.State>
    game: App.pass<App.GG.State>
  }

// function used to get a chip
// puts the chip on hand
// removes the chip from table
App.GG.when.get_chip(
  index: Nat // index of 'removed' slot
  phase: App.GG.Phase
): App.GG.Phase
  case phase {
    setup:
      let table  = phase.table
      let hand   = phase.hand
      let energy = phase.energy
      Maybe {
        get item = table@slots[index]
        get chip = item@chip
        get new_energy = App.GG.when.get_new_energy(chip@energy, energy)
        let new_item   = item@chip <- none
        let new_table  = table@slots[index] <- new_item
        let new_hand   = chip & hand
        let new_phase  = App.GG.Phase.setup(new_table, new_hand, new_energy)
        return new_phase
      } <> phase
    game:
      phase
  }

App.GG.when.get_new_energy(chip: I32, table: I32): Maybe<I32>
  if chip >? table then
    none
  else
    some(table - chip)

App.GG.when.return_chip(local: App.GG.State.local): IO<Maybe<App.State.local<App.GG.State>>>
  let new_phase = App.GG.when.return_chip.phase(local@phase)
  let new_local = local@phase <- new_phase
  App.set_local<App.GG.State>(new_local)

// function used to return a chip
// puts the chip on table
// removes the chip from hand
App.GG.when.return_chip.phase(
  phase: App.GG.Phase
): App.GG.Phase
  case phase {
    setup:
      let hand  = phase.hand
      let table = phase.table
      case hand {
        nil: phase
        cons:
          let chip = hand.head
          let slots = App.GG.when.return_chip.go(chip, table@slots)
          let new_energy = chip@energy + phase.energy
          let new_table = table@slots <- slots
          let new_hand = hand.tail
          let new_phase = App.GG.Phase.setup(new_table, new_hand, new_energy)
          new_phase
      }
    game:
      phase
  }
  

App.GG.when.return_chip.go(chip: App.GG.Chip, slots: List<App.GG.Table.Slot>): List<App.GG.Table.Slot>
  case slots {
    nil: []
    cons: 
      let table_chip = slots.head@chip
      without table_chip: App.GG.Table.Slot.new(some(chip)) & slots.tail
      slots.head & App.GG.when.return_chip.go(chip, slots.tail)
  }
  // Maybe {
  //   get item = table@slots[index]
  //   get chip = item@chip
  //   let new_hand  = chip & hand
  //   let new_item  = item@chip <- none
  //   let new_table = table@slots[index] <- new_item
  //   return { new_hand, new_table }
  // } <> { hand, table }

App.GG.when.update_phase(phase: App.GG.Phase): App.GG.Phase
  case phase {
    setup: phase
    game: App.GG.Phase.game(phase.turn_bar + 2)
  }



App.GG.when.table: Shape.Rectangle
  let {x1, y1} = {(App.GG.Constants.chips_starting_position@fst - (App.GG.Constants.chip_size@fst/2)) (App.GG.Constants.chips_starting_position@snd - (App.GG.Constants.chip_size@snd/2))}
  let {vx, vy} = App.GG.Constants.chips_space_between
  let {cx, cy} = App.GG.Constants.chip_size
  let {r,  c } = App.GG.Constants.chips_array
  let {x2, y2} = {x1 + ((cx + vx) * r), y1 + ((cy + vy) * c)}
  log(U32.show(x1) | " " | U32.show(x2) | " " | U32.show(y1) | " " | U32.show(y2))
  Shape.Rectangle.new(U32.to_f64(x1), U32.to_f64(x2), U32.to_f64(y1), U32.to_f64(y2))


App.GG.when.chip(mouse_pos: Pair<U32, U32>): Maybe<Nat>
  let {r,   c  } = App.GG.Constants.chips_array
  let {x,   y  } = mouse_pos
  let {v_x, v_y} = App.GG.Constants.chips_space_between              // Space between Chips
  let {c_x, c_y} = App.GG.Constants.chip_size                    // Chips size
  let {t_x, t_y} = {c_x + v_x, c_y + v_y}
  let {s_x, s_y} = {x % t_x, y % t_y}
  let row        = x / t_x
  let column     = y / t_y
  if ((x % (c_x + v_x)) <? c_x) && ((y % (c_y + v_y)) <? c_y) then 
    some(U32.to_nat(column + (row * c)))
  else
    none


App.GG.when.update_tile(coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  let new_grid = 
    Maybe {
      get creature = App.GG.Creature.get(coord, grid)
      let mod = (x) App.GG.when.update_frame(App.GG.when.update_action(x))
      let new_grid = App.GG.Creature.modify_at(mod, coord, grid)
      return new_grid
    } <> grid

  let new_grid = 
    Maybe {
      get creature = App.GG.Creature.get(coord, new_grid)
      get action = creature@actions@current 
      get hasnt_acted = if creature@actions@has_acted then none else some(unit)
      let origin = App.GG.Effect.Origin.creature
      let result = action@effect(coord, origin, new_grid) 
      get new_grid = case result {err: none, new: some(result.grid)}
      return new_grid
    } <> new_grid

  let new_grid =
    Maybe {
      get projectiles = App.GG.Projectile.get_list(coord, new_grid)
      let pair = {0, new_grid}
      for projectile in projectiles with pair:
        let {idx, new_grid} = pair
        let origin = App.GG.Effect.Origin.projectile(idx)
        let result = projectile@effect(coord, origin, new_grid)
        let new_grid = case result {err: new_grid, new: result.grid}
        {idx +1, new_grid}
      return pair@snd
    } <> new_grid

  new_grid

App.GG.when.basic_attack(grid: App.GG.Grid): App.GG.Grid
  let pair = App.GG.Slime.find_coord(grid)
  case pair {
    none: grid
    some:
      let {creature, coord} = pair.value
      case creature@category as category {
        minion: grid
        slime:
          let action = App.GG.Actions.basic_attack
          App.GG.Creature.modify_at(App.GG.when.add_action(action), coord, grid)
      }
  }


App.GG.when.use_chip(grid: App.GG.Grid): App.GG.Grid
  let pair = App.GG.Slime.find_coord(grid)
  case pair {
    none: grid
    some:
      let {creature, coord} = pair.value
      case creature@category as category {
        minion: grid
        slime:
          case category.hand {
            nil: grid
            cons: 
              let action = App.GG.Actions.Data.new(0, category.hand.head@effect, App.GG.Actions.Category.chip)
              App.GG.Creature.modify_at(App.GG.when.add_action(action), coord, grid)
          }
      }
  }

App.GG.when.update_frame(creature: App.GG.Creature): App.GG.Creature
  let new_creature = creature@animation <- {creature@animation@fst, creature@animation@snd + 1}
  new_creature

App.GG.when.update_action(creature: App.GG.Creature): App.GG.Creature
  let as = creature@actions
  let na = as@next
  let a  = as@current
  if as@has_acted then creature else 
    case a {
      none:
        case na {
          none: creature
          some:
            //log("22") 
            let new_actions = as@current <- some(na.value)
            let new_actions = new_actions@next <- none
            let new_creature = creature@actions <- new_actions
            new_creature
        }
      some:
        creature
    }


App.GG.when.add_action(action: App.GG.Actions.Data, creature: App.GG.Creature): App.GG.Creature
  let actions = creature@actions
  
  let new_actions = actions@next <- some(action)
  creature@actions <- new_actions

