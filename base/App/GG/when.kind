// Event handler
App.GG.when: App.When<App.GG.State>
  (event, state)
  let local = state@local
  case event {
    // init: IO {
    //   App.watch!(App.room_zero)
    //   App.new_post!(App.room_zero, "")
    // }
    frame:
      let new_grid = App.GG.when.update_grid(local@grid)
      let new_local = local@grid <- new_grid
      App.set_local<App.GG.State>(new_local)
    key_down:
      log(U16.show(event.code))
      let grid = local@grid
      if (event.code <? 41#16) && (event.code >? 36) then
        let coord = App.GG.Slime.find_coord(grid)
        without coord: App.pass!
        let new_grid = App.GG.Creature.modify_at(App.GG.when.add_action(App.GG.Actions.movement(event.code)), coord@snd, grid)
        let new_local = local@grid <- new_grid
        App.set_local<App.GG.State>(new_local)
      else
        switch U16.eql(event.code) {
          // Spacebar
          32#16: 
            let new_grid = App.GG.when.use_chip(local@grid)
            let new_local = local@grid <- new_grid
            App.set_local<App.GG.State>(new_local)
        }default App.pass<App.GG.State>
  } default App.pass<App.GG.State>

App.GG.when.update_grid(grid: App.GG.Grid): App.GG.Grid
  let new_grid = grid 
  for coord:tile in grid with new_grid:
    App.GG.when.update_tile(coord, new_grid)
  new_grid
    

App.GG.when.update_tile(coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  let new_grid = 
    Maybe {
      get creature = App.GG.Creature.get(coord, grid)
      let mod = (x) App.GG.when.update_frame(App.GG.when.update_action(x))
      let new_grid = App.GG.Creature.modify_at(mod, coord, grid)
      return new_grid
    } <> grid

  let new_grid = 
    Maybe {
      get creature = App.GG.Creature.get(coord, new_grid)
      get action = creature@actions@current 
      get hasnt_acted = if creature@actions@has_acted then none else some(unit)
      let origin = App.GG.Effect.Origin.creature
      let result = action@effect(coord, origin, new_grid) 
      get new_grid = case result {err: none, new: some(result.grid)}
      return new_grid
    } <> new_grid

  let new_grid =
    Maybe {
      get projectiles = App.GG.Projectile.get_list(coord, new_grid)
      let pair = {0, new_grid}
      for projectile in projectiles with pair:
        let {idx, new_grid} = pair
        let origin = App.GG.Effect.Origin.projectile(idx)
        let result = projectile@effect(coord, origin, new_grid)
        let new_grid = case result {err: new_grid, new: result.grid}
        {idx +1, new_grid}
      return pair@snd
    } <> new_grid


  new_grid

App.GG.when.use_chip(grid: App.GG.Grid): App.GG.Grid
  let pair = App.GG.Slime.find_coord(grid)
  case pair {
    none: grid
    some:
      let {creature, coord} = pair.value
      case creature@category as category {
        minion: grid
        slime:
          case category.chips {
            nil: grid
            cons: 
              open category.chips.head
              let action = App.GG.Actions.Data.new(0, category.chips.head.effect, App.GG.Actions.Category.chip)
              App.GG.Creature.modify_at(App.GG.when.add_action(action), coord, grid)
          }
      }
  }

App.GG.when.update_frame(creature: App.GG.Creature): App.GG.Creature
  let new_creature = creature@animation <- {creature@animation@fst, creature@animation@snd + 1}
  new_creature

App.GG.when.update_action(creature: App.GG.Creature): App.GG.Creature
  let as = creature@actions
  let na = as@next
  let a  = as@current
  if as@has_acted then creature else 
    case a {
      none:
        case na {
          none: creature
          some:
            //log("22") 
            let new_actions = as@current <- some(na.value)
            let new_actions = new_actions@next <- none
            let new_creature = creature@actions <- new_actions
            new_creature
        }
      some:
        creature
    }


App.GG.when.add_action(action: App.GG.Actions.Data, creature: App.GG.Creature): App.GG.Creature
  let actions = creature@actions
  
  let new_actions = actions@next <- some(action)
  creature@actions <- new_actions

