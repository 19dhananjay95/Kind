Kind.Parser.comprehension: Parser<Kind.term>
  Parser.first_of!([
    Kind.Parser.comprehension_with_where,
    Kind.Parser.comprehension_without_where      
  ])
  
  
Kind.Parser.comprehension_without_where: Parser<Kind.Term>
  Parser {
    Kind.Parser.text("[")
    get loop = Kind.Parser.term
    Kind.parser.text("for")
    get elem = Kind.Parser.name1
    Kind.parser.text("in")
    get list = Kind.Parser.term
    Kind.Parser.text("]")

    let term = Kind.Term.ref("List.map")
    let term = Kind.Term.app(term, Kind.Term.hol(Bits.e))
    let term = Kind.Term.app(term, Kind.Term.hol(Bits.e))
    let lamb = Kind.Term.lam(elem, (i) loop)
    let term = Kind.Term.app(term, lamb)
    let term = Kind.Term.app(term, list)
    
    return term
  }


Kind.Parser.comprehension_with_where: Parser<Kind.Term>
  Parser {
    Kind.Parser.text("[")
    get loop = Kind.Parser.term
    Kind.parser.text("for")
    get elem = Kind.Parser.name1
    Kind.parser.text("in")
    get list = Kind.Parser.term
    Kind.Parser.text("where")
    get filters = Kind.Parser.term
    Kind.Parser.text("]")

    let term = Kind.Term.ref("List.map")
    let term = Kind.Term.app(term, Kind.Term.hol(Bits.e))
    let term = Kind.Term.app(term, Kind.Term.hol(Bits.e))
    let lamb = Kind.Term.lam(elem, (i) loop)
    let term = Kind.Term.app(term, lamb)
    let term = Kind.Term.app(term, list)
    
    let filter_fun = Kind.Term.ref("List.filter")
    let filter_fun = Kind.Term.app(filter_fun, Kind.Term.hol(Bits.e))
    let filter_fun = Kind.Term.app(filter_fun, filters)
    let filter_fun = Kind.Term.app(filter_fun, term)
    
    return filter_fun
  }