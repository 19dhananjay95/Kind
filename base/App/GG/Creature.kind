type App.GG.Creature { 
  new(
    category: App.GG.Monster
    team: App.GG.Team
    status: List<App.GG.Creature.Status>
    hp: I32
  )
}

type App.GG.Creature.Dna {
  new(
    alteration: String //TODO
    attributes: App.GG.Creature.Attributes
  )
}

type App.GG.Creature.Attributes {
  new(
    hp:I32
    energy:I32
    damage:I32
    corruption: I32
  )
}

type App.GG.Creature.Status {
  stun(duration: I32)
}

//===========================================================
//Effect functions

type App.GG.Creature.Effect.Result<A: Type> {
  new(
    value: A,
    center: Pair<U32, U32>
    cast_data: Pair<Char,String>
    grid: App.GG.Grid
    energy_cost: I32 
    description: String
  )
}


App.GG.Creature.Effect(A: Type): Type
  ((center: Pair<U32, U32>) ->
   (targets: List<Pair<U32, U32>>) ->
   (cast_data: Pair<Char,String>) ->
   (grid: App.GG.Grid) ->
   App.GG.Creature.Effect.Result(A))

App.GG.Creature.Effect.bind<A: Type, B: Type>(
  effect: App.GG.Creature.Effect<A>
  next: A -> App.GG.Creature.Effect<B>
): App.GG.Creature.Effect<B>

  (center, targets, cast_data, grid)
  case effect(center, targets, cast_data, grid) as result_a {
    new: case next(result_a.value)(result_a.center, targets, result_a.cast_data, result_a.grid) as result_b {
      new: 
        let center      = result_b.center
        let value       = result_b.value
        let cast_data   = result_b.cast_data
        let grid        = result_b.grid
        let energy_used = result_a.energy_cost + result_b.energy_cost
        let description = result_b.description
        App.GG.Creature.Effect.Result.new<B>(value, center, cast_data, grid, energy_used, description)
    }
  }
  
//===========================================================
//Creature Management

App.GG.Creature.get(
  place: App.GG.Coord
  grid: App.GG.Grid
): Maybe<App.GG.Creature>

  let tile = App.GG.Creature.get_tile(place, grid)
  case tile { 
    none:
      none
    some:
      tile.value@creature
  }


App.GG.Creature.change_hp_at(
  mod: App.GG.Creature -> App.GG.Creature
  pos: App.GG.Coord
  grid: App.GG.Grid
): App.GG.Grid
  
  let result = Maybe { 
    get tile = App.GG.Creature.get_tile(pos, grid)
    get creature = tile@creature
    let new_creature = mod(creature)
    let new_tile = App.GG.Tile.new(tile@img, some(creature), tile@owner)
    let new_map = App.GG.Creature.grid_set(pos, new_tile, grid)
    return new_map
  }
  result <> grid


