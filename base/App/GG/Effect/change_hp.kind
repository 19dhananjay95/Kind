// App.GG.Effect.change_hp(dmg: I32, flinch: Bool, pos: App.GG.Coord): App.GG.Effect<I32>
//   (center, origin, local)
//   let grid = local@grid
//   let {real_dmg, new_grid} =
//     Maybe {
//       get tile = App.GG.Grid.get(pos, grid)
//       get creature = tile@creature
//       let hp = creature@hp
//       let new_hp = I32.max(hp + dmg, 0)
//       let new_creature = creature@hp <- new_hp
//       let new_tile = tile@creature <- some(new_creature)
//       let real_dmg = new_hp - hp
//       let new_grid = App.GG.Grid.set(pos, new_tile, grid)
//       let new_grid = 
//         if flinch then
//           let stun = App.GG.Actions.stun(App.GG.Creature.Status.Stun.flinch, App.GG.Animation.damage, 24)
//           App.GG.Actions.new_actions(pos, new_grid, stun)
//         else
//           new_grid
//       let new_grid = 
//         if new_hp =? 0 then
//           let vbox = App.GG.Monster.to_vbox(creature@category)
//           let vbox = vbox(App.GG.Animation.death)
//           let target = App.GG.Creature.get(pos, new_grid)
//           without target: new_grid 
//           App.GG.Effect.creature.del_at
//           App.GG.Effect.projectile.add_at(pos, App.GG.Projectile.death(vbox, 23#64, target@team), new_grid)
//           new_grid
//         else
//           new_grid 

//       return {real_dmg, new_grid}
//     } <> {+0#32, grid}
//     let new_local = local@grid <- new_grid
//   App.GG.Effect.Result.new!(real_dmg, center, origin, new_local, (enemy, img) img, 0, "")

App.GG.Effect.change_hp(dmg: I32, flinch: Bool, pos: App.GG.Coord): App.GG.Effect<I32>
  App.GG.Effect {
    get creature = App.GG.Effect.creature.get
    without creature: App.GG.Effect { return +0#32 }
    App.GG.Effect {
      let {new_creature, new_dmg} = App.GG.Effect.change_hp.barrier(creature, dmg)
      let old_hp = creature@hp
      let new_hp = I32.max(new_creature@hp + new_dmg, 0)
      let real_dmg = new_hp - old_hp
      let new_creature = new_creature@hp <- new_hp
      let new_creature = App.GG.Effect.change_hp.flinch(real_dmg, flinch, creature)
      App.GG.Effect.creature.modify_at((creature) new_creature, pos)
      if new_hp =? 0 then
        App.GG.Effect {
          let vbox = App.GG.Monster.to_vbox(creature@category)
          let vbox = vbox(App.GG.Animation.death)
          App.GG.Effect.creature.del_at(pos)
          App.GG.Effect.projectile.add_at(pos, App.GG.Projectile.death(vbox, 23#64, creature@team))
        }
      else
        App.GG.Effect.pass
      return real_dmg
    }
  }

App.GG.Effect.change_hp.flinch(dmg: I32, flinch: Bool, creature: App.GG.Creature): App.GG.Creature
  if not(dmg =? 0) && flinch then 
    let stun = App.GG.Actions.stun(App.GG.Creature.Status.Stun.flinch, App.GG.Animation.damage, 24)
    App.GG.Actions.add(stun, creature)
  else
    creature


App.GG.Effect.change_hp.barrier(creature: App.GG.Creature, dmg: I32): Pair<App.GG.Creature, I32>
  let statuses = creature@statuses
  let barrier = App.GG.Creature.Status.get_from_nat(2, statuses)
  without barrier: {creature, dmg}
  let {new_barrier, remaining_dmg} = App.GG.Effect.change_hp.barrier.aux(barrier, dmg)
  let new_creature = 
    case new_barrier {
      none: App.GG.Creature.Status.del_from_nat(2, creature)
      some: App.GG.Creature.Status.add(new_barrier.value, creature)
    }
  {new_creature, remaining_dmg}
  

App.GG.Effect.change_hp.barrier.aux(barrier: Maybe<App.GG.Creature.Status>, dmg: I32): Pair<Maybe<App.GG.Creature.Status>, I32>
  let no_barrier = {none, dmg}
  case barrier {
    none: no_barrier
    some:
      case barrier.value {
        barrier: 
          let duration = barrier.value.duration
          let health = I32.min(barrier.value.health + dmg, 0)
          if health =? 0 then
            {none, dmg + barrier.value.health}
          else
            let new_barrier = App.GG.Creature.Status.barrier(duration, health)
            {some(new_barrier), +0#32}
      }default no_barrier
  }