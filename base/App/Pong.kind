App.Pong.State: App.State
  App.State.new(App.Pong.State.local, Unit)

App.Pong.width: U32
  256

App.Pong.height: U32
  256

App.Pong.paddle_width: U32
  10

App.Pong.ball_diameter: U32
  8

App.Pong.Ball.init_speed: Pair<Dyadic, Dyadic>
  {15, 10}

type App.Pong.Player {
  new(
    h: Dyadic // height
    p: Dyadic // vertical position of the top of the paddle
    v: Dyadic // speed
  )
}

type App.Pong.Ball {
  new(
    p: Pair<Dyadic, Dyadic> // position
    v: Pair<Dyadic, Dyadic> // speed
  )
}

type App.Pong.State.local {
  new(
    left: App.Pong.Player
    right: App.Pong.Player
    ball: App.Pong.Ball
  )
}

App.Pong.init: App.Init<App.Pong.State>
  let initial_player = App.Pong.Player.new(50, 0, 0)
  let initial_ball = App.Pong.Ball.new({128, 128}, App.Pong.Ball.init_speed)
  let initial_state = App.Pong.State.local.new(initial_player, initial_player, initial_ball)
  App.Store.new!(initial_state, unit)

App.Pong.draw(img: VoxBox): App.Draw<App.Pong.State>
  (state)
    let st = state@local
    let img = VoxBox.Draw.rect(
      1
      Dyadic.to_u32(st@left@p)
      0
      App.Pong.paddle_width
      Dyadic.to_u32(st@left@h)
      Col32.new(0, 0, 0, 255)
      img)
    let img = VoxBox.Draw.rect(
      App.Pong.width - App.Pong.paddle_width - 1
      Dyadic.to_u32(st@right@p)
      0
      App.Pong.paddle_width
      Dyadic.to_u32(st@right@h)
      Col32.new(0, 0, 0, 255)
      img)
    let img = VoxBox.Draw.moving_rect(
      Dyadic.to_i32(st@ball@p@fst)
      Dyadic.to_i32(st@ball@p@snd)
      (Dyadic.to_i32(st@ball@v@fst)*3)/2
      (Dyadic.to_i32(st@ball@v@snd)*3)/2
      U32.to_i32(App.Pong.ball_diameter)
      U32.to_i32(App.Pong.ball_diameter)
      0
      Col32.new(0, 0, 0, 255)
      img)
    <div style={
      "display": "flex"
      "width": "100%"
      "justify-content": "space-evenly"
    }>{
      DOM.vbox({"id": "game_screen", "width": "500px", "height": "500px", "scale": "1"}, {}, img)
    }</div>

App.Pong.when.ball(b: App.Pong.Ball): App.Pong.Ball
  let w = U32.to_dyadic(App.Pong.width)
  let h = U32.to_dyadic(App.Pong.height)
  let d = U32.to_dyadic(App.Pong.ball_diameter)
  // collisions
  let v_x =
    if ((b@p@fst <? 0) && (b@v@fst <? 0)) || (((b@p@fst + d) >? w) && (b@v@fst >? 0)) then
      Dyadic.neg(b@v@fst)
    else
      b@v@fst
  let v_y =
    if ((b@p@snd <? 0) && (b@v@snd <? 0)) || (((b@p@snd + d) >? h) && (b@v@snd >? 0)) then
      Dyadic.neg(b@v@snd)
    else
      b@v@snd
  App.Pong.Ball.new({b@p@fst + v_x, b@p@snd + v_y}, {v_x, v_y})

App.Pong.when: App.When<App.Pong.State>
  (event, state)
    let st = state@local
    case event {
      frame: IO {
        let st = st@ball <- App.Pong.when.ball(st@ball)
        log("frame")
        return some(st)
      }
      mouse_move: IO { // TODO modify speed to
        let pos = U32.to_dyadic(event.mouse_pos@snd) - (st@left@h/2)
        let left = st@left@p <- pos
        let st = st@left <- left
        return some(st)
      }
    } default IO { return some(st) }


App.Pong.tick: App.Tick<App.Pong.State>
  App.no_tick<App.Pong.State>

App.Pong.post: App.Post<App.Pong.State>
  App.no_post<App.Pong.State>

App.Pong: App<App.Pong.State>
  let img = VoxBox.alloc_capacity(65536*8)
  let init = App.Pong.init 
  let draw = App.Pong.draw(img)
  let when = App.Pong.when
  let tick = App.Pong.tick
  let post = App.Pong.post
  App.new!(init, draw, when, tick, post)
