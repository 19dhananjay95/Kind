App.KL.Game.Coord.eql(
  a:App.KL.Game.Coord,
  b:App.KL.Game.Coord
): Bool
  open a
  open b
  Bool.and(I32.eql(a.i,b.i), I32.eql(a.j, b.j))


App.KL.Game.Coord.axial_to_nat(coord: App.KL.Game.Coord): Nat
  open coord
  i = coord.i + 100 //  I32
  i = i * 1000
  i = I32.to_u32(i)
  j = coord.j + 100
  j = I32.to_u32(j)
  sum = i + j   //U32
  U32.to_nat(sum)

// Checks if a coord is inside map boundaries
App.KL.Game.Coord.fit(coord: App.KL.Game.Coord): Bool
  board_size = App.KL.Constants.board_size
  coord      = App.KL.Game.Coord.axial_to_cubic(coord)
  open coord

  x = I32.abs(coord.x)
  y = I32.abs(coord.y)
  z = I32.abs(coord.z)
  greater = I32.max(x, I32.max(y, z))
  I32.lte(greater, board_size)

// CONVERSIONS
// ==============================

// convert axial coordinates to cubic coordinates 
App.KL.Game.Coord.axial_to_cubic(coord: App.KL.Game.Coord): App.KL.Game.Coord.Cubic
    open coord
    x = coord.i
    z = coord.j
    y = (I32.neg(x) - z)

    App.KL.Game.Coord.Cubic.new(x, y, z)

// convert axial coordinate to canvas coordinate
App.KL.Game.Coord.to_screen_xy(coord: App.KL.Game.Coord): Pair<U32,U32> // TODO add alias
  open coord
  i   = coord.i
  j   = coord.j
  
  i = I32.to_f64(i)
  j = I32.to_f64(j)
  int_rad = U32.to_f64(App.KL.Constants.hexagon_radius)
  hlf = F64.div(int_rad, 2.0#64)
  int_screen_center_x = U32.to_f64(App.KL.Constants.center_x)
  int_screen_center_y = U32.to_f64(App.KL.Constants.center_y)
  
  cx = int_screen_center_x + j * int_rad  // screen_center + j * rad
  cx = cx + i * int_rad * 2 // screen_center + j * rad + i * 2rad
  cy = int_screen_center_y + j * hlf * 3 // screen_center + j * (3rad/2)
  // let cy = F64.add(cy, j)
  cx = F64.to_u32(cx)
  y = cy + 0.5 // to round correctly
  cy = F64.to_u32(cy)
  {cx, cy}

// transform screen coordinate into hexagon axial coordinates
App.KL.Game.Coord.to_axial(
  coord: Pair(U32, U32) // TODO add alias
): App.KL.Game.Coord

  {x, y} = coord

  f = U32.to_f64
  i = F64.to_i32
  float_hex_rad = F64.div(f(App.KL.Constants.hexagon_radius), 2)
  center_x = App.KL.Constants.center_x
  center_y = App.KL.Constants.center_y

  float_x = F64.div(F64.sub(f(x), f(center_x)), float_hex_rad)
  float_y = F64.div(F64.sub(f(y), f(center_y)), float_hex_rad)
  

  fourth = 0.25
  sixth = F64.div(1, 6)
  third = F64.div(1, 3)
  half = 0.5

  axial_x = F64.sub( F64.mul(float_x, fourth), F64.mul(float_y, sixth) )
  axial_y = F64.mul(float_y, third)
  {i, j}  = App.KL.Game.Coord.round(axial_x, axial_y)
  App.KL.Game.Coord.new(i, j)

// ROUND AXIAL
// ==========================

// round a axial coordinate
App.KL.Game.Coord.round(
  axial_x: F64,
  axial_y: F64
): Pair(I32, I32) // TODO change return to Coord

  f = U32.to_f64
  i = F64.to_i32
  axial_z = F64.sub(F64.sub(f(0u), axial_x), axial_y)

  round_x = App.KL.Game.Coord.round_F64(axial_x)
  round_y = App.KL.Game.Coord.round_F64(axial_y)
  round_z = App.KL.Game.Coord.round_F64(axial_z)

  diff_x = App.KL.Game.Coord.round.diff(axial_x, round_x)
  diff_y = App.KL.Game.Coord.round.diff(axial_y, round_y)
  diff_z = App.KL.Game.Coord.round.diff(axial_z, round_z)
  
  result = case F64.gtn(diff_x, diff_z) {
    true:
      case F64.gtn(diff_y, diff_x){
        true: 
          new_y = F64.sub(F64.sub(f(0u), round_x), round_z)
          {i(round_x), i(new_y)}
        false:
          new_x = F64.sub(F64.sub(f(0u), round_y), round_z)
          {i(new_x), i(round_y)}
      }
    false:
      case F64.gtn(diff_y, diff_z) {
        true:
          new_y = F64.sub(F64.sub(f(0u), round_x), round_z)
          {i(round_x), i(new_y)}
        false:
          {i(round_x), i(round_y)}
      }
  }
  result

// round a number
// TODO verify if a general function exists
App.KL.Game.Coord.round_F64(n: F64): F64
  half = 0.5 //F64
  big_number = 1000.0// TODO while F64.gtn, cmp and ltn is broken
  n = n + big_number //F64
  result = App.KL.Game.Coord.round.floor(n + half) //F64
  result - big_number //F64

// floor a number
// TODO verify if a general function exists
App.KL.Game.Coord.round.floor(n: F64): F64
  I32.to_f64(F64.to_i32(n))

// get absolute diference
// TODO verify if a general function exists
App.KL.Game.Coord.round.diff(x: F64,y: F64): F64 // TODO while F64.abs doesnt exist

  big_number = 1000.0 // while F64.gtn, cmp and ltn is broken
  x = x + big_number
  y = y + big_number

  case F64.gtn(x, y) {
    true: x - y
    false: y - x
  }
