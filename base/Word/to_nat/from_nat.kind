Word.size.zero(w: Word(0)): w((w, w.size) Type, Unit, (size, pred) Empty, (size, pred) Empty)
  let contra = refl :: 0 == 0
  (case w {
    e:
      (contra)
        unit
    o:
      (contra)
        Empty.absurd!(Nat.succ_neq_zero(w.size, contra))
    i:
      (contra)
        Empty.absurd!(Nat.succ_neq_zero(w.size, contra))
  }: (h: w.size == 0) -> w((k, k.size) Type, Unit, (size, pred) Empty, (size, pred) Empty))(contra)

Word.size.succ(n: Nat, w: Word(Nat.succ(n))): w((w, w.size) Type, Empty, (size, pred) Unit, (size, pred) Unit)
  let contra = refl :: Nat.succ(n) == Nat.succ(n)
  (case w {
    e:
      (contra)
        Empty.absurd!(Nat.succ_neq_zero(n, contra))
    o:
      (contra)
        unit
    i:
      (contra)
        unit
  }: (h: Nat.succ(n) == w.size) -> w((k, k.size) Type, Empty, (size, pred) Unit, (size, pred) Unit))(contra)

Word.to_nat.from_nat<size: Nat>(
  n: Nat
): Word.to_nat(size, Nat.to_word(size, n)) == Nat.mod(n, Nat.pow(2, size))
  case size {
    zero:
      let case_elim = Word.size.zero(Nat.to_word(0, n))
      let qed =
        case Nat.to_word(0, n) {
          e:
            (case_elim)
              case refl :: 1 == Nat.pow(2, 0) {
                refl:
                  case Nat.mod.one(n) {
                    refl:
                      refl
                  }: Equal(Nat, self.b, Nat.mod(n, 1))
              }: Equal(Nat, 0, Nat.mod(n, self.b))
          i:
            (case_elim)
              Empty.absurd!(case_elim)
          o:
            (case_elim)
              Empty.absurd!(case_elim)
        }: (case_elim: self((w, w.size) Type, Unit, (size, pred) Empty, (size, pred) Empty)) -> (Word.to_nat(self.size, self) == Nat.mod(n, Nat.pow(2, 0)))
      qed(case_elim)
    succ:
      case n {
        zero:
          let lemma_right =
            let contra = Nat.pow.lte(1, Nat.succ(size.pred))
            (case Nat.pow(2,Nat.succ(size.pred)) {
              zero:
                (contra)
                  Empty.absurd!(Bool.true_neq_false(contra))
              succ:
                (contra)
                  refl
            }: (contra: Nat.lte(self,0) == Bool.false) -> (0 == Nat.mod(0,self)))(contra)
          let lemma_left = mirror(Word.to_nat.zero(Nat.succ(size.pred)))
          chain(lemma_left, lemma_right)
        succ:
          let lemma = refl :: Word.inc(Nat.succ(size.pred),Nat.to_word(Nat.succ(size.pred),n.pred)) == Nat.to_word(Nat.succ(size.pred),Nat.succ(n.pred))
          case lemma {
            refl:
              let ind = mirror(Word.to_nat.from_nat(Nat.succ(size.pred), n.pred))
              (case Nat.to_word(Nat.succ(size.pred),n.pred) {
                e:
                  (ind)
                    case (refl :: 1 == Nat.pow(2, 0)) {
                      refl:
                        mirror(Nat.mod.one(Nat.succ(n.pred)))
                    }: 0 == Nat.mod(Nat.succ(n.pred), self.b)
                o:
                  (ind)
                    case ind {
                      refl:
                        let right_small = ?todo :: Nat.lte(Nat.succ(Nat.succ(n.pred)), Nat.pow(2,Nat.succ(self.size))) == true
                        let right_ok = mirror(Nat.mod.le_mod(Nat.succ(n.pred),Nat.pow(2,Nat.succ(self.size)), right_small))
                        let left_small = Nat.lte.succ_left(Nat.succ(n.pred), Nat.pow(2,Nat.succ(self.size)), right_small)
                        let left_ok = mirror(Nat.mod.le_mod(n.pred,Nat.pow(2,Nat.succ(self.size)), left_small))
                        case right_ok {
                          refl:
                            case left_ok {
                              refl:
                                ?refl
                            }: Nat.succ(left_ok.b) == Nat.succ(n.pred)
                        }: Nat.succ(Nat.mod(n.pred,Nat.pow(2,Nat.succ(size.pred)))) == right_ok.b
                    }: Nat.succ(ind.b) == Nat.mod(Nat.succ(n.pred),Nat.pow(2,Nat.succ(self.size)))
                    //?oooo-38-18
                i:
                  (ind)
                    ?iiii
              }: (ind: Nat.mod(n.pred,Nat.pow(2,Nat.succ(size.pred))) == Word.to_nat(self.size,self)) -> Word.to_nat(self.size, Word.inc(self.size, self)) == Nat.mod(Nat.succ(n.pred),Nat.pow(2,self.size)))(ind)
              // Nat.succ(Nat.mul(2,Word.to_nat(self.size,self.pred))) == Nat.mod(Nat.succ(n.pred),Nat.pow(2,Nat.succ(self.size)))
              // Nat.mod(n.pred,Nat.pow(2,self.size)) == Word.to_nat(self.size,Nat.to_word(self.size,n.pred))
              // Word.to_nat(Nat.succ(size.pred), Word.inc(size.pred, Nat.to_word(Nat.succ(size.pred),n.pred))) == Nat.mod(Nat.succ(n.pred),Nat.pow(2,self.size))
          }: Word.to_nat(Nat.succ(size.pred), lemma.b) == Nat.mod(Nat.succ(n.pred),Nat.pow(2,Nat.succ(size.pred)))
      }!
  }!
//  to_nat(to_word(succ(size.pred), succ(n.pred))) == succ(n.pred) % 2^succ(size.pred)
//  to_nat(inc(to_word(succ(size.pred), n.pred))) == succ(n.pred) % 2^succ(size.pred)
//    - to_nat(2*self) == succ(self.size) % 2^succ(self.size)

Word.to_nat.zero(size: Nat): 0 == Word.to_nat(size, Word.zero(size))
  case size {
    zero:
      refl
    succ:
      case Word.to_nat.zero(size.pred) {
        refl:
          refl
      }: 0 == Nat.mul(2, self.b)
  }!
