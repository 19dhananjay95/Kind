type Kind.Comp.Prim {
  bool,
  nat,
  string,
  data(ctrs: Kind.Comp.Prim.ADT),
}

Kind.Comp.Prim.ADT: Type
  List(Pair(String, List(String)))

Kind.Comp.as_adt.get_fields(term: Kind.Term): List(String)
  case term {
    all:
      let head = term.name
      let tail = Kind.Comp.as_adt.get_fields(term.body(Kind.Term.var("",0),Kind.Term.var("",0)))
      head & tail
  } default []

Kind.Comp.as_adt.get_constructors(term: Kind.Term): Kind.Comp.Prim.ADT
  case term {
    all:
      let tail = Kind.Comp.as_adt.get_constructors(term.body(Kind.Term.var("",0), Kind.Term.var("",0)))
      let name = term.name
      let flds = Kind.Comp.as_adt.get_fields(term.xtyp)
      {name,flds} & tail
  } default []

Kind.Comp.as_adt(term: Kind.Term, defs: Kind.Defs): Maybe(Kind.Comp.Prim.ADT)
  let term = Kind.Term.reduce(term, defs)
  case term {
    all:
      if String.ends_with(term.self, ".Self") then
        some(Kind.Comp.as_adt.get_constructors(term.body(Kind.Term.var("",0),Kind.Term.var("",0))))
      else
        none
  } default none

Kind.Comp.prims: List(Pair(String, Kind.Comp.Prim))
  [
    {"Bool", Kind.Comp.Prim.bool}
    {"Nat", Kind.Comp.Prim.nat}
    //"Bits"
    //"U8"
    //"U16"
    //"U32"
    //"U64"
    //"U256"
    //"F64"
    //"String"
    //"Buffer32"
  ]
  

Kind.Comp.prim_of(type: Kind.Term, defs: Kind.Defs): Maybe(String)
  let result = none
  for prim_name in Kind.Comp.prim_names with result:
    case result {
      none:
        if Kind.Term.equal(type, Kind.Term.ref(prim_name), defs) then
          some(prim_name)
        else
          none
      some: result
    }
  result


//var is_prim = {
  //Unit     : 1,
  //Bool     : 1,
  //Nat      : 1,
  //Bits     : 1,
  //U8       : 1,
  //U16      : 1,
  //U32      : 1,
  //U64      : 1,
  //U256     : 1,
  //F64      : 1,
  //String   : 1,
  //Buffer32 : 1,
//};

Kind.Comp.from_core.go(term: Kind.Term, type: Maybe(Kind.Term), defs: Kind.Defs): Pair(Kind.Comp, Kind.Term)
  // Compilation assumes the term has been type checked already and thus has all
  // holes filled. Because of that and for simplicity, if there is any problem,
  // it will just return undefined references instead of proper error types.
  let error = {
    Kind.Comp.var("undefined")
    Kind.Term.var("undefined", 0)
  }
  case term {
    var: {
      Kind.Comp.var(term.name | "$" | Nat.show(term.indx))
      Kind.Term.var(term.name, term.indx)
    }
    ref:
      let got = defs{term.name}
      without got: error
      {
        Kind.Comp.ref(term.name)
        open got; got.type
      }
    typ: {
      Kind.Comp.nil
      Kind.Term.typ
    }
    app:
      let {func_cmp, func_typ} = Kind.Comp.from_core.go(term.func, none, defs)
      case Kind.Term.reduce(func_typ, defs) as func_typ {
        all:
          let argm_cmp = Kind.Comp.from_core.go(term.argm, some(func_typ.xtyp), defs)
          let term_typ = func_typ.body(term.func, term.argm)
          let func_typ_adt = Kind.Comp.as_adt(func_typ)
          let func_typ_pri = Kind.Comp.prim_of(func_typ)
          case Kind.Comp.as_adt(func_typ) as got_adt {
            some: Kind.Term.eli(Kind.Comp.Prim.data(got_adt.value))
            none: ?b
          } default error
      }
  } default error
    //case "App":
      //var func_cmp = infer(term.func, defs, ctx);
      //var func_typ = fmc.reduce(func_cmp.type, defs);
      //switch (func_typ.ctor) {
        //case "All":
          //var self_var = fmc.Ann(true, term.func, func_typ);
          //var name_var = fmc.Ann(true, term.argm, func_typ.bind);
          //var argm_cmp = check(term.argm, func_typ.bind, defs, ctx);
          //var term_typ = func_typ.body(self_var, name_var);
          //var comp = func_cmp.comp;
          //var func_typ_adt = as_adt(func_typ, defs);
          //var func_typ_prim = prim_of(func_typ, defs);
          //if (func_typ_prim) {
            //comp = Eli(func_typ_prim, comp);
          //} else if (func_typ_adt) {
            //comp = Eli(func_typ_adt, comp);
          //};
          //if (!func_typ.eras) {
            //comp = App(comp, argm_cmp.comp);
          //}
          //return {comp, type: term_typ};
        //default:
          //throw "Non-function application.";
      //};
    //case "Let":
      //var expr_cmp = infer(term.expr, defs, ctx);
      //var expr_var = fmc.Ann(true, fmc.Var("_"+term.name, ctx.size+1), expr_cmp.type);
      //var body_ctx = fmc.Ext({name:term.name,type:expr_var.type}, ctx);
      //var body_cmp = infer(term.body(expr_var), defs, body_ctx);
      //return {
        //comp: Let("_"+term.name+"$"+(ctx.size+1), expr_cmp.comp, body_cmp.comp),
        //type: body_cmp.type,
      //};
    //case "Def":
      //return infer(term.body(term.expr), defs, ctx);
    //case "All":
      //return {
        //comp: Nul(),
        //type: fmc.Typ(),
      //};
    //case "Ann":
      //return check(term.expr, term.type, defs, ctx);
    //case "Loc":
      //return infer(term.expr, defs, ctx);
    //case "Nat":
      //return {
        //comp: Nat(term.natx),
        //type: fmc.Ref("Nat"),
      //};
    //case "Chr":
      //return {
        //comp: Chr(term.chrx),
        //type: fmc.Ref("Char"),
      //};
    //case "Str":
      //return {
        //comp: Str(term.strx),
        //type: fmc.Ref("String"),
      //};
  //}
//};

////function check(term, type, defs, ctx = fmc.Nil()) {
  ////var typv = fmc.reduce(type, defs);

  ////if (typv.ctor === "Typ") {
    ////var comp = Nul();
    ////var type = fmc.Typ();
    ////return {comp, type};
  ////};

  ////var comp = null;
  ////switch (term.ctor) {
    ////case "Lam":
      ////if (typv.ctor === "All") {
        ////var self_var = fmc.Ann(true, term, type);
        ////var name_var = fmc.Ann(true, fmc.Var("_"+term.name, ctx.size+1), typv.bind);
        ////var body_typ = typv.body(self_var, name_var);
        ////var body_ctx = fmc.Ext({name:term.name,type:name_var.type}, ctx);
        ////var body_cmp = check(term.body(name_var), body_typ, defs, body_ctx);
        ////if (typv.eras) {
          ////comp = body_cmp.comp;
        ////} else {
          ////comp = Lam("_"+term.name+"$"+(ctx.size+1), body_cmp.comp);
        ////}
        ////var type_adt = as_adt(type, defs);
        ////var type_prim = prim_of(type, defs);
        ////if (type_prim) {
          ////comp = Ins(type_prim, comp);
        ////} else if (type_adt) {
          ////comp = Ins(type_adt, comp);
        ////}
      ////} else {
        ////throw "Lambda has non-function type.";
      ////}
      ////return {comp, type};
    ////case "Let":
      ////var expr_cmp = infer(term.expr, defs, ctx);
      ////var expr_var = fmc.Ann(true, fmc.Var("_"+term.name, ctx.size+1), expr_cmp.type);
      ////var body_ctx = fmc.Ext({name:term.name,type:expr_var.type}, ctx);
      ////var body_cmp = check(term.body(expr_var), type, defs, body_ctx);
      ////return {
        ////comp: Let("_"+term.name+"$"+(ctx.size+1), expr_cmp.comp, body_cmp.comp),
        ////type: body_cmp.type,
      ////};
    ////case "Loc":
      ////return check(term.expr, type, defs);
    ////default:
      ////var term_cmp = infer(term, defs, ctx);
      ////var comp = term_cmp.comp;
      ////return {comp, type};
  ////};
////}

////function infer(term, defs, ctx = fmc.Nil()) {
  ////switch (term.ctor) {
    ////case "Var":
      ////return {
        ////comp: Var(term.name+"$"+term.indx),
        ////type: fmc.Var(term.name,term.indx),
      ////};
    ////case "Ref":
      ////var got_def = defs[term.name];
      ////return {
        ////comp: Ref(term.name),
        ////type: got_def.type,
      ////};
    ////case "Typ":
      ////return {
        ////comp: Nul(),
        ////type: fmc.Typ(),
      ////};
    ////case "App":
      ////var func_cmp = infer(term.func, defs, ctx);
      ////var func_typ = fmc.reduce(func_cmp.type, defs);
      ////switch (func_typ.ctor) {
        ////case "All":
          ////var self_var = fmc.Ann(true, term.func, func_typ);
          ////var name_var = fmc.Ann(true, term.argm, func_typ.bind);
          ////var argm_cmp = check(term.argm, func_typ.bind, defs, ctx);
          ////var term_typ = func_typ.body(self_var, name_var);
          ////var comp = func_cmp.comp;
          ////var func_typ_adt = as_adt(func_typ, defs);
          ////var func_typ_prim = prim_of(func_typ, defs);
          ////if (func_typ_prim) {
            ////comp = Eli(func_typ_prim, comp);
          ////} else if (func_typ_adt) {
            ////comp = Eli(func_typ_adt, comp);
          ////};
          ////if (!func_typ.eras) {
            ////comp = App(comp, argm_cmp.comp);
          ////}
          ////return {comp, type: term_typ};
        ////default:
          ////throw "Non-function application.";
      ////};
    ////case "Let":
      ////var expr_cmp = infer(term.expr, defs, ctx);
      ////var expr_var = fmc.Ann(true, fmc.Var("_"+term.name, ctx.size+1), expr_cmp.type);
      ////var body_ctx = fmc.Ext({name:term.name,type:expr_var.type}, ctx);
      ////var body_cmp = infer(term.body(expr_var), defs, body_ctx);
      ////return {
        ////comp: Let("_"+term.name+"$"+(ctx.size+1), expr_cmp.comp, body_cmp.comp),
        ////type: body_cmp.type,
      ////};
    ////case "Def":
      ////return infer(term.body(term.expr), defs, ctx);
    ////case "All":
      ////return {
        ////comp: Nul(),
        ////type: fmc.Typ(),
      ////};
    ////case "Ann":
      ////return check(term.expr, term.type, defs, ctx);
    ////case "Loc":
      ////return infer(term.expr, defs, ctx);
    ////case "Nat":
      ////return {
        ////comp: Nat(term.natx),
        ////type: fmc.Ref("Nat"),
      ////};
    ////case "Chr":
      ////return {
        ////comp: Chr(term.chrx),
        ////type: fmc.Ref("Char"),
      ////};
    ////case "Str":
      ////return {
        ////comp: Str(term.strx),
        ////type: fmc.Ref("String"),
      ////};
  ////}
////};

////function check(term, type, defs, ctx = fmc.Nil()) {
  ////var typv = fmc.reduce(type, defs);

  ////if (typv.ctor === "Typ") {
    ////var comp = Nul();
    ////var type = fmc.Typ();
    ////return {comp, type};
  ////};

  ////var comp = null;
  ////switch (term.ctor) {
    ////case "Lam":
      ////if (typv.ctor === "All") {
        ////var self_var = fmc.Ann(true, term, type);
        ////var name_var = fmc.Ann(true, fmc.Var("_"+term.name, ctx.size+1), typv.bind);
        ////var body_typ = typv.body(self_var, name_var);
        ////var body_ctx = fmc.Ext({name:term.name,type:name_var.type}, ctx);
        ////var body_cmp = check(term.body(name_var), body_typ, defs, body_ctx);
        ////if (typv.eras) {
          ////comp = body_cmp.comp;
        ////} else {
          ////comp = Lam("_"+term.name+"$"+(ctx.size+1), body_cmp.comp);
        ////}
        ////var type_adt = as_adt(type, defs);
        ////var type_prim = prim_of(type, defs);
        ////if (type_prim) {
          ////comp = Ins(type_prim, comp);
        ////} else if (type_adt) {
          ////comp = Ins(type_adt, comp);
        ////}
      ////} else {
        ////throw "Lambda has non-function type.";
      ////}
      ////return {comp, type};
    ////case "Let":
      ////var expr_cmp = infer(term.expr, defs, ctx);
      ////var expr_var = fmc.Ann(true, fmc.Var("_"+term.name, ctx.size+1), expr_cmp.type);
      ////var body_ctx = fmc.Ext({name:term.name,type:expr_var.type}, ctx);
      ////var body_cmp = check(term.body(expr_var), type, defs, body_ctx);
      ////return {
        ////comp: Let("_"+term.name+"$"+(ctx.size+1), expr_cmp.comp, body_cmp.comp),
        ////type: body_cmp.type,
      ////};
    ////case "Loc":
      ////return check(term.expr, type, defs);
    ////default:
      ////var term_cmp = infer(term, defs, ctx);
      ////var comp = term_cmp.comp;
      ////return {comp, type};
  ////};
////};
  
