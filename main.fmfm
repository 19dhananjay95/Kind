type Empty {
}

type Unit {
  new
}

type Bool {
  true,
  false,
}

type Bit {
  0,
  1,
}

type Cmp {
  ltn,
  eql,
  gtn,
}

type Bits {
  nil,
  0(pred: Bits),
  1(pred: Bits),
}

type Nat {
  zero,
  succ(pred: Nat),
}

type Word ~ (size: Nat) {
  nil                            ~ (size: Nat.zero),
  0<size: Nat>(pred: Word(size)) ~ (size: Nat.succ(size)),
  1<size: Nat>(pred: Word(size)) ~ (size: Nat.succ(size)),
}

type Maybe <A: Type> {
  none,
  some(value: A),
}

type Either <A: Type, B: Type> {
  left(value: A),
  right(value: B),
}

type Pair <A: Type, B: Type> {
  new(fst: A, snd: B)
}

type List <A: Type> {
  nil,
  cons(head: A, tail: List(A)),
}

type Map <A: Type> {
  new,
  tie(val: Maybe(A), lft: Map(A), rgt: Map(A)),
}

Set: Type
  Map(Unit)

type U16 {
  new(value: Word(16))
}

Char: Type
  U16

type String {
  nil,
  cons(head: Char, tail: String),
}

type Monad <M: Type -> Type> {
  new(
    bind: (A: Type, B: Type) (m: M(A)) (f: (x:A) M(B)) M(B),
    pure: (A: Type) (x: A) M(A),
  )
}

type Parser.Reply <V: Type> {
  error(code: String, err: String),
  value(code: String, val: V),
}

type IO <A: Type> {
  end(value: A),
  ask(query: String, param: String, then: (response: String) IO(A)),
}

// Prereqs
// =======

// If we have an element of the empty type, then we can prove anything.
Empty.absurd<P: Type>(x: Empty): P
  case x {}

Bool.not(a: Bool):  Bool
  case a {
    true: Bool.false,
    false: Bool.true,
  }

Bool.and(a: Bool, b: Bool): Bool
  case a {
    true: b,
    false: Bool.false,
  }

Bool.or(a: Bool, b: Bool): Bool
  case a {
    true: Bool.true,
    false: b,
  }

// n == m
Cmp.as_eql(cmp: Cmp): Bool
  case cmp {
    ltn: Bool.false,
    eql: Bool.true,
    gtn: Bool.false,
  }

// n >= m
Cmp.as_gte(cmp: Cmp): Bool
  case cmp {
    ltn: Bool.false,
    eql: Bool.true,
    gtn: Bool.true,
  }

// n > m
Cmp.as_gtn(cmp: Cmp): Bool
  case cmp {
    ltn: Bool.false,
    eql: Bool.false,
    gtn: Bool.true,
  }

// n <= m
Cmp.as_lte(cmp: Cmp): Bool
  case cmp {
    ltn: Bool.true,
    eql: Bool.true,
    gtn: Bool.false,
  }

// n < m
Cmp.as_ltn(cmp: Cmp): Bool
  case cmp {
    ltn: Bool.true,
    eql: Bool.false,
    gtn: Bool.false,
  }

Nat.pred(n: Nat): Nat
  case n {
    zero: Nat.zero,
    succ: n.pred
  }

Nat.apply<A: Type>(n: Nat, f: (x:A) A, x: A): A
  case n {
    zero: x,
    succ: Nat.apply<A>(n.pred, f, f(x)),
  }

Nat.to_base(base: Nat, nat: Nat): List(Nat)
  Nat.to_base.go(base, nat, List.nil<Nat>)

Nat.to_base.go(base: Nat, nat: Nat, res: List(Nat)): List(Nat)
  case Nat.div_mod(nat, base) as div_mod {
    new: case div_mod.fst {
      zero: List.cons<_>(div_mod.snd, res),
      succ: Nat.to_base.go(base, div_mod.fst, List.cons<_>(div_mod.snd, res))
    } 
  }

Nat.from_base(base: Nat, ds: List(Nat)) : Nat
  Nat.from_base.go(base, List.reverse<_>(ds),1,0)

Nat.from_base.go(b: Nat, ds: List(Nat), p: Nat, res: Nat) : Nat
  case ds {
    nil: res,
    cons: Nat.from_base.go(b,ds.tail,Nat.mul(b,p), Nat.add(Nat.mul(ds.head,p),res))
  }

Nat.to_bits(n: Nat): Bits
  case n {
    zero: Bits.nil,
    succ: Bits.inc(Nat.to_bits(n.pred))
  }

Nat.to_string_base(base: Nat, nat: Nat): String
  List.fold<_>(Nat.to_base(base, nat))<_>(
    String.nil,
    (n, str) String.cons(Nat.show_digit(base,n), str))

Nat.to_bits(n: Nat): Bits
  case n {
    zero: Bits.nil,
    succ: Bits.inc(Nat.to_bits(n.pred))
  }

Nat.add(n: Nat, m: Nat): Nat
  case n {
    zero: m,
    succ: Nat.succ(Nat.add(n.pred, m)),
  }

Nat.sub(n: Nat, m: Nat): Nat
  case n {
    zero: 0,
    succ: case m {
      zero: n,
      succ: Nat.sub(n.pred, m.pred)
    }
  }

Nat.cmp(a: Nat, b: Nat): Cmp
  case a {
    zero: case b {
      zero: Cmp.eql,
      succ: Cmp.ltn,
    },
    succ: case b {
      zero: Cmp.gtn,
      succ: Nat.cmp(a.pred, b.pred),
    },
  }

Nat.mul(n: Nat, m: Nat): Nat
  case n {
    zero: Nat.zero,
    succ: Nat.add(m, Nat.mul(n.pred, m))
  }

Nat.sub_rem(n: Nat, m: Nat): Either(Nat, Nat)
  case m {
    zero: Either.left<_,_>(n),
    succ: case n {
      zero: Either.right<_,_>(Nat.succ(m.pred)),
      succ: Nat.sub_rem(n.pred, m.pred),
    }
  }

Nat.div_mod(n: Nat, m: Nat): Pair(Nat, Nat)
  Nat.div_mod.go(n, m, Nat.zero)

Nat.div_mod.go(n: Nat, m: Nat, d: Nat): Pair(Nat, Nat)
  case Nat.sub_rem(n, m) as p {
    left: Nat.div_mod.go(p.value, m, Nat.succ(d)),
    right: Pair.new<_,_>(d, n),
  }

Nat.div(n: Nat, m: Nat): Nat
  Pair.fst<_,_>(Nat.div_mod(n, m))

Nat.mod(n: Nat, m: Nat): Nat
  Pair.snd<_,_>(Nat.div_mod(n, m))

Nat.double(n: Nat): Nat
  case n {
    zero: Nat.zero,
    succ: Nat.succ(Nat.double(n.pred)),
  }

// n >= m
Nat.gte(n: Nat, m: Nat): Bool
  Cmp.as_gte(Nat.cmp(n, m))

// n > m
Nat.gtn(n: Nat, m: Nat): Bool
  Cmp.as_gtn(Nat.cmp(n, m))

// n == m
Nat.eql(n: Nat, m: Nat): Bool
  Cmp.as_eql(Nat.cmp(n, m))

// n <= m
Nat.lte(n: Nat, m: Nat): Bool
  Cmp.as_lte(Nat.cmp(n, m))

// n < m
Nat.ltn(n: Nat, m: Nat): Bool
  Cmp.as_ltn(Nat.cmp(n, m))

Nat.show(n: Nat): String
  Nat.to_string_base(10,n)

Nat.show_digit(base: Nat, n: Nat) : Char
  let m = Nat.mod(n,base);
  let base64 =
    ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
    ,'G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V'
    ,'W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l'
    ,'m','n','o','p','q','r','s','t','u','v','w','x','y','z','+','/'];
  if Bool.and(Nat.gtn(base,0),Nat.lte(base,64)) then 
    case List.at<_>(m,base64) as c {
      none: '#',
      some: c.value,
    }
  else '#'

Nat.to_u16(n: Nat): U16
  Nat.apply<U16>(n, U16.inc, U16.zero)

Bits.inc(a: Bits): Bits
  case a {
    nil: Bits.1(Bits.nil),
    0: Bits.1(a.pred),
    1: Bits.0(Bits.inc(a.pred)),
  }

Bits.add(a: Bits, b: Bits): Bits
  case b {
    nil: a,
    0: case a {
      nil: b,
      0: Bits.0(Bits.add(a.pred, b.pred)),
      1: Bits.1(Bits.add(a.pred, b.pred)),
    },
    1: case a {
      nil: b,
      0: Bits.1(Bits.add(a.pred, b.pred)),
      1: Bits.0(Bits.add(Bits.inc(a.pred), b.pred))
    }
  }

Bits.eql(a: Bits, b: Bits): Bool
  case a {
    nil: case b {
      nil: Bool.true,
       0 : Bool.false,
       1 : Bool.false,
    },
    0: case b {
      nil: Bool.false,
       0 : Bits.eql(a.pred, b.pred),
       1 : Bool.false,
    },
    1: case b {
      nil: Bool.false,
       0 : Bool.false,
       1 : Bits.eql(a.pred, b.pred),
    }
  }

Bits.tail(a: Bits): Bits
  case a {
    nil: Bits.nil,
    0: a.pred,
    1: a.pred,
  }

Bits.show(a: Bits): String
  case a {
    nil: "",
    0: String.cons('0', Bits.show(a.pred)),
    1: String.cons('1', Bits.show(a.pred)),
  }

Bits.reverse(a: Bits): Bits
  Bits.reverse.tco(a, Bits.nil)

Bits.reverse.tco(a: Bits, r: Bits): Bits
  case a {
    nil: r,
    0: Bits.reverse.tco(a.pred, Bits.0(r)),
    1: Bits.reverse.tco(a.pred, Bits.1(r))
  }

Bits.concat(a: Bits, b: Bits): Bits
  case a {
    nil: b,
    0: Bits.0(Bits.concat(a.pred, b)),
    1: Bits.1(Bits.concat(a.pred, b))
  }

Bits.chunks_of.go(
  len   : Nat,  // length of each chunk
  bits  : Bits, // bits to be split
  need  : Nat,  // number of vals to complete chunk
  chunk : Bits  // current chunk
) : List(Bits)
  case bits {
    nil: List.cons<_>(Bits.reverse(chunk), List.nil<_>),
    0: case need {
      zero: 
        let head = Bits.reverse(chunk);
        let tail = Bits.chunks_of.go(len, bits, len, Bits.nil);
        List.cons<_>(head, tail),
      succ:
        let chunk = Bits.0(chunk);
        Bits.chunks_of.go(len, bits.pred, need.pred, chunk)
    },
    1: case need {
      zero:
        let head = Bits.reverse(chunk);
        let tail = Bits.chunks_of.go(len, bits, len, Bits.nil);
        List.cons<_>(head, tail),
      succ:
        let chunk = Bits.1(chunk);
        Bits.chunks_of.go(len, bits.pred, need.pred, chunk)
    }
  }

Bits.chunks_of(len: Nat, bits: Bits): List(Bits)
  Bits.chunks_of.go(len, bits, len, Bits.nil)

Bits.to_nat(b: Bits): Nat
  case b {
    nil: 0,
     0 : Nat.mul(2, Bits.to_nat(b.pred)),
     1 : Nat.succ(Nat.mul(2, Bits.to_nat(b.pred)))
  }

Word.to_bits<size: Nat>(a: Word(size)): Bits
  case a {
    nil: Bits.nil,
    0: Bits.0(Word.to_bits<a.size>(a.pred)),
    1: Bits.1(Word.to_bits<a.size>(a.pred)),
  }

Word.from_bits(size: Nat, bits: Bits): Word(size)
  case size {
    zero: Word.nil,
    succ: case bits {
      nil: Word.0<size.pred>(Word.from_bits(size.pred, Bits.nil)),
       0 : Word.0<size.pred>(Word.from_bits(size.pred, bits.pred)),
       1 : Word.1<size.pred>(Word.from_bits(size.pred, bits.pred))
    } : Word(Nat.succ(size.pred))
  } : Word(size.self)

Word.zero(size: Nat): Word(size)
  case size {
    zero: Word.nil,
    succ: Word.0<size.pred>(Word.zero(size.pred))
  } : Word(size.self)

Word.adder<size: Nat>(a: Word(size), b: Word(size), c: Bool): Word(size)
  case a with b: Word(a.size) = b {
    nil: Word.nil,
    0 : case b with a.pred: Word(Nat.pred(b.size)) = a.pred {
      nil: Word.nil,
      0: case c {
        true : Word.1<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.false)),
        false: Word.0<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.false)),
      },
      1: case c {
        true:  Word.0<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.true)),
        false: Word.1<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.false)),
      }
    } : Word(b.size),
    1: case b with a.pred: Word(Nat.pred(b.size)) = a.pred {
      nil: Word.nil,
      0: case c {
        true : Word.0<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.true)),
        false: Word.1<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.false)),
      },
      1: case c {
        true : Word.1<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.true)),
        false: Word.0<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.true)),
      }
    } : Word(b.size)
  } : Word(a.size)

Word.cmp.go<size: Nat>(a: Word(size), b: Word(size), c: Cmp): Cmp
  case a with b : Word(a.size) = b {
    nil: c,
    0 : case b with a.pred : Word(Nat.pred(b.size)) = a.pred {
      nil: c,
      0  : Word.cmp.go<b.size>(a.pred, b.pred, c),
      1  : Word.cmp.go<b.size>(a.pred, b.pred, Cmp.ltn)
    },
    1: case b with a.pred : Word(Nat.pred(b.size)) = a.pred {
      nil: c,
      0  : Word.cmp.go<b.size>(a.pred, b.pred, Cmp.gtn),
      1  : Word.cmp.go<b.size>(a.pred, b.pred, c)
    }
  }

// ++a
Word.inc<size: Nat>(word: Word(size)): Word(size)
  case word {
    nil: Word.nil,
     0 : Word.1<word.size>(word.pred),
     1 : Word.0<word.size>(Word.inc<word.size>(word.pred))
  } : Word(word.size)

U16.zero: U16
  U16.new(Word.zero(16))

U16.inc(a: U16): U16
  case a {
    new: U16.new(Word.inc<_>(a.value))
  }

Pair.fst<A: Type, B: Type>(pair: Pair(A, B)): A
  case pair {
    new: pair.fst
  }

Pair.snd<A: Type, B: Type>(pair: Pair(A, B)): B
  case pair {
    new: pair.snd
  }

List.fold<A: Type>(list: List(A)): <P: Type> -> P -> (A -> P -> P) -> P
  <P> (nil, cons)
  case list {
    nil : nil,
    cons: cons(list.head, List.fold<A>(list.tail)<P>(nil, cons))
  }

List.for<A: Type>(xs: List(A))<B: Type>(b: B, f: A -> B -> B): B
  case xs {
    nil : b,
    cons: List.for<A>(xs.tail)<B>(f(xs.head,b),f)
  }

List.map<A: Type, B: Type>(f: A -> B, as: List(A)): List(B)
  case as {
    nil: List.nil<_>,
    cons: List.cons<_>(f(as.head), List.map<_,_>(f,as.tail)),
  }

List.reverse<A: Type>(xs: List(A)) : List(A)
  List.reverse.go<_>(xs,List.nil<_>)

List.reverse.go<A: Type>(xs: List(A), res: List(A)): List(A)
  case xs {
    nil: res,
    cons: List.reverse.go<_>(xs.tail,List.cons<_>(xs.head,res))
  }

List.concat<A: Type>(as: List(A), bs: List(A)): List(A)
  case as {
    nil: bs,
    cons: List.cons<_>(as.head, List.concat<_>(as.tail,bs))
  }

List.flatten<A: Type>(xs: List(List(A))): List(A)
  case xs {
    nil: List.nil<_>,
    cons: List.concat<_>(xs.head, List.flatten<_>(xs.tail))
  }

List.length<A: Type>(xs: List(A)): Nat
  List.length.go<_>(xs, 0)

List.length.go<A: Type>(xs: List(A), n: Nat): Nat
  case xs {
    nil : n,
    cons: List.length.go<A>(xs.tail, Nat.succ(n))
  }

List.eql<A: Type>(eql: A -> A -> Bool, a: List(A), b: List(A)): Bool
  case a {
    nil: case b {
      nil: Bool.true,
      cons: Bool.false,
    },
    cons: case b {
      nil: Bool.false,
      cons: Bool.and(eql(a.head, b.head), List.eql<A>(eql, a.tail, b.tail)),
    },
  }

List.mapped<A: Type>(as: List(A))<B: Type>(f: A -> B): List(B)
  case as {
    nil: List.nil<_>,
    cons: List.cons<_>(f(as.head),List.mapped<A>(as.tail)<B>(f))
  }

List.at<A: Type>(index: Nat, list: List(A)): Maybe(A)
  case list {
    nil: Maybe.none<_>,
    cons: case index {
      zero: Maybe.some<_>(list.head),
      succ: List.at<_>(index.pred, list.tail),
    }
  }

List.at_last<A: Type>(index: Nat, list: List(A)): Maybe(A)
  List.at<A>(index, List.reverse<_>(list))

Map.fold<A: Type>(map: Map(A)): <P: Type> -> P -> (Maybe(A) -> P -> P -> P) -> P
  <P> (new, tie)
  case map {
    new: new,
    tie: 
      tie(
        map.val,
        Map.fold<A>(map.lft)<P>(new, tie),
        Map.fold<A>(map.rgt)<P>(new, tie)),
  }

Map.get<A: Type>(bits: Bits, map: Map(A)): Maybe(A)
  case bits {
    nil: case map {
      new: Maybe.none<_>,
      tie: map.val
    }, 
    0: case map {
      new: Maybe.none<_>,
      tie: Map.get<_>(bits.pred, map.lft)
    },
    1: case map {
      new: Maybe.none<_>,
      tie: Map.get<_>(bits.pred, map.rgt)
    }
  }

Map.set<A: Type>(bits: Bits, val: A, map: Map(A)): Map(A)
  case bits {
    nil: case map {
      new: Map.tie<_>(Maybe.some<_>(val), Map.new<_>, Map.new<_>),
      tie: Map.tie<_>(Maybe.some<_>(val), map.lft, map.rgt)
    },
    0: case map {
      new: Map.tie<_>(Maybe.none<_>, Map.set<_>(bits.pred, val, Map.new<_>), Map.new<_>),
      tie: Map.tie<_>(map.val, Map.set<_>(bits.pred, val, map.lft), map.rgt)
    },
    1: case map {
      new: Map.tie<_>(Maybe.none<_>, Map.new<_>, Map.set<_>(bits.pred, val, Map.new<_>)),
      tie: Map.tie<_>(map.val, map.lft, Map.set<_>(bits.pred, val, map.rgt))
    }
  }

Map.delete<A: Type>(key: Bits, map: Map(A)) : Map(A)
  case map {
    new: Map.new<_>,
    tie: case key {
      nil: Map.tie<_>(Maybe.none<_>, map.lft, map.rgt),
       0 : Map.delete<_>(key.pred, map.lft),
       1 : Map.delete<_>(key.pred, map.rgt)
    }
  }

Map.from_list<A: Type, B: Type>(f: A -> Bits, xs: List(Pair(A,B))): Map(B)
  case xs {
    nil : Map.new<_>,
    cons: case xs.head as p {
      new: Map.set<_>(f(p.fst), p.snd, Map.from_list<_,_>(f, xs.tail))
    }
  }

Map.to_list.go<A: Type>(xs: Map(A), key: Bits, list: List(Pair(Bits,A))): List(Pair(Bits,A))
  case xs {
    new: list,
    tie: 
      let list0 = case xs.val {
        none: list,
        some: List.cons<_>(Pair.new<_,_>(Bits.reverse(key), xs.val.value), list),
      };
      let list1 = Map.to_list.go<_>(xs.lft, Bits.0(key), list0);
      let list2 = Map.to_list.go<_>(xs.rgt, Bits.1(key), list1);
      list2
  }

Set.new: Set
  Map.new<Unit>

Set.del<A: Type>(key: Bits, set: Set): Set
  Map.delete<Unit>(key, set)

Set.set(bits: Bits, set: Set): Set
  Map.set<Unit>(bits, Unit.new, set)

Set.has(bits: Bits, set: Set): Bool
  case Map.get<Unit>(bits, set) {
    none: Bool.false,
    some: Bool.true,
  }

String.is_empty(str: String): Bool
  case str {
    nil: Bool.true,
    cons: Bool.false,
  }

String.concat(as: String, bs: String): String
  case as {
    nil: bs,
    cons: String.cons(as.head, String.concat(as.tail,bs)),
  }

//String.join.go(sep: String, list: List(String), fst: Bool): String
  //case list {
    //nil: "",
    //cons: String.flatten([
      //if fst then "" else sep,
      //list.head, 
      //String.join.go(sep, list.tail, Bool.false),
    //]),
  //}
  
//String.join(sep: String, list: List(String)): String
  //String.join.go(sep, list, Bool.true)

//String.flatten.go(xs: List(String), res: String): String
  //case xs {
    //nil: res,
    //cons: String.flatten.go(xs.tail, String.concat(res, xs.head)),
  //}

//String.flatten(xs: List(String)): String
  //String.flatten.go(xs, "")


//main: Nat
  //(((x) x) :: _ -> _)(Nat.zero)

main: List(Nat)
  [1, 2, 3]
  //U16.new(Word.from_bits(16))
