Lit.Lang.Coin: String
`
String.concat(a: String, b: String): String
  ...

HelloWorld(): String
  let result = String.concat("Hello", ", World")
  result

Lit.state(): BitsMap
  BitsMap.new

Lit.send(amount: Nat, to: Bits): Bool
  BitsMap.transact(amount, #caller, to)

Kelvin.pub(): String
  "7a6fd576fad57adf"

extract_next_pub(extra: String): String
  ...
  return next_pub

get_all_code(): IO<String>
  call size:  U64= $call_size()
  call code_chunk: U64 = $code_chunk(0)
  ...
  return code

(Term.bind
  "code_chunk" 
  "U64"
  (Term.run
    (Getter.code_chunk (Term.word 0)) :: IO<U64>
  )
  ...
)

get_all_extra(): IO<String>
  call size = $extra_size()
  call extra_chunk = $extra(0)
  ...
  return signature

Kelvin(cmd_expr: IO<U64>): IO<U64>
  call call_code: String = get_all_code()
  call extra: String = get_all_extra()

  call signature: String = extract_signature(extra)
  call new_pub: String = extract_next_pub(extra)

  if WOTS.verify(Kelvin.pub, call_code, signature) then
    store Kelvin.pub = new_pub
    call _ : U64 = cmd_expr
    return 1
  else
    return 0

// (Term.bind
//   "extra"
//   "String"
//   (Term.run
//     (Term.call
//       "get_all_extra"
//       []
//     ) :: IO<String>
//   )
//   ...
// )

// (Term.bind
//   "_" :: U64
//   "U64"
//   (Term.run
//     (Term.var "cmd_expr") :: IO<U64>
//   )
//   ...
// )

do {
  Lit.send(100, $miner)
} extra {
  "6d5as76d4a67s4d8a6s46d"
}

// do {
//   call result = 
//     Kelvin(
//       "5d3af2543d2f5a3fda32fa5", 
//       cmd {
//         Lit.send(100, #miner)
//       }
//     )
// }

// do {
//   Lit.send(100, #miner)
// }

`
