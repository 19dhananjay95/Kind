App.GG.Coord: Type
  Pair<U32, U32>

App.GG.Coord.to_xy(coord: App.GG.Coord): Pair<U32, U32>
  let start = App.GG.Constants.map_starting_position
  let x = (start@fst + (32#32 * coord@fst)) - 128#32
  let y = (start@snd + (32#32 * coord@snd)) - 128#32
  {x, y}

App.GG.Coord.front(coord: App.GG.Coord, team: App.GG.Team): App.GG.Coord
  let new_coord = 
    case team {
      blue: {coord@fst + 1, coord@snd}
      red:  {coord@fst - 1, coord@snd}
      neutral: coord
    }
  new_coord


App.GG.Coord.front_sized(coord: App.GG.Coord, team: App.GG.Team, grid: App.GG.Grid, size: Nat): List<App.GG.Coord>
  App.GG.Coord.front_sized.go(coord, [], team, grid, size)

App.GG.Coord.front_sized.go(coord: App.GG.Coord, coords: List<App.GG.Coord>, team: App.GG.Team, grid: App.GG.Grid, size: Nat): List<App.GG.Coord>
  let next_coord = 
    case team {
      blue: {coord@fst + 1, coord@snd}
      red:  {coord@fst - 1, coord@snd}
      neutral: coord
    }
  let tile = App.GG.Grid.get(next_coord, grid)
  case size tile { 
    succ some:
      let new_list = next_coord & coords
      let new_size = size - 1
      App.GG.Coord.front_sized.go(next_coord, new_list, team, grid, new_size)
    } default coords

App.GG.Coord.can_walk(from: App.GG.Coord, destination: App.GG.Coord, grid: App.GG.Grid): Bool
  let f_tile = App.GG.Grid.get(from, grid)
  let d_tile = App.GG.Grid.get(destination, grid)
  Maybe {
    get f = f_tile
    get d = d_tile
    get f_creature = f@creature
    let result = case d@creature {
      none: 
        if App.GG.Team.eql(f_creature@team, d@owner) then
          true
        else
          false
      some: false
    }
    return result
  } <> false

App.GG.Coord.adjacent_all(
  center: App.GG.Coord
  grid: App.GG.Grid
): List<App.GG.Coord>
  
    let above = App.GG.Coord.above(center)
    let below = App.GG.Coord.below(center)
    let {top_right, top_left} = {{above@fst + 1 , above@snd} , {above@fst - 1, above@snd}}
    let {bot_right, bot_left} = {{below@fst + 1 , below@snd} , {below@fst - 1, below@snd}}
    let {ctr_left, ctr_right} = {{center@fst + 1, center@snd}, {center@fst - 1, center@snd}}
    [
    top_left,   above   ,top_right
    ctr_left,            ctr_right
    bot_left,   below   ,bot_right
    ]


App.GG.Coord.front_all.go(
  coord: App.GG.Coord,
  coords: List<App.GG.Coord>
  team: App.GG.Team,
  grid: App.GG.Grid
): List<App.GG.Coord>
  let next_coord = 
    case team {
      blue: {coord@fst + 1, coord@snd}
      red:  {coord@fst - 1, coord@snd}
      neutral: coord
    }
  let tile = App.GG.Grid.get(next_coord, grid)
  case tile { 
    none: 
      coords
    some:
      let new_list = next_coord & coords
      App.GG.Coord.front_all.go(next_coord, new_list, team, grid)
  }

App.GG.Coord.front_all(
  coord: App.GG.Coord,
  team: App.GG.Team,
  grid: App.GG.Grid
): List<App.GG.Coord>
  App.GG.Coord.front_all.go(coord, [], team, grid)

App.GG.Coord.has_enemy(
  coord: App.GG.Coord
  team: App.GG.Team
  grid: App.GG.Grid
): Bool

  let coords = App.GG.Coord.front_all(coord, team, grid)
  let enemy = false
  for target in coords with enemy:
    let any_creature = App.GG.Creature.get(target, grid)
    case any_creature {
      none:
        enemy
      some:
        let same_team = App.GG.Team.eql(team, any_creature.value@team)
        if same_team then
          enemy
        else
          true
    }
  enemy


App.GG.Coord.above(coord: App.GG.Coord): App.GG.Coord
  let new_coord = {coord@fst, coord@snd -1}
  new_coord

App.GG.Coord.below(coord: App.GG.Coord): App.GG.Coord
  let new_coord = {coord@fst, coord@snd +1}
  new_coord

App.GG.Coord.first_enemy_in_front(team: App.GG.Team, grid: App.GG.Grid, coord: App.GG.Coord): Maybe<App.GG.Coord>
  let next = App.GG.Coord.first_enemy_in_front(team, grid)
  let new_coord = App.GG.Coord.front(coord, team)
  let tile = App.GG.Grid.get(new_coord, grid)
  without tile: none
  let creature = tile@creature
  without creature: next(new_coord)
  if App.GG.Team.eql(creature@team, team) then 
    next(new_coord)
  else
    some(new_coord)

App.GG.Coord.first_enemy_tile(coord: App.GG.Coord, team: App.GG.Team, grid: App.GG.Grid): Maybe<App.GG.Coord>
  let front_coord = App.GG.Coord.front(coord, team)
  let front_tile  = App.GG.Grid.get(front_coord, grid)
  without front_tile: none
  if App.GG.Team.eql(team, front_tile@owner) then
    App.GG.Coord.first_enemy_tile(front_coord, team, grid)
  else
    some(front_coord)

// returns all the coords in a coord's column, and all the columns ahead of it
App.GG.Coord.self_and_front_columns(coord: App.GG.Coord, grid: App.GG.Grid): List<App.GG.Coord>
  let tile = App.GG.Grid.get(coord, grid)
  without tile: []
  let team = tile@owner
  App.GG.Coord.self_and_front_columns.go(coord, team, grid)

App.GG.Coord.self_and_front_columns.go(coord: App.GG.Coord, team: App.GG.Team, grid: App.GG.Grid): List<App.GG.Coord>
  let list = 
    [{coord@fst, 0#32}, {coord@fst, 1#32}, {coord@fst, 2#32}]
  let exists = true
    for c in list with exists:
      let tile = App.GG.Grid.get(c, grid)
      without tile: false
      exists
  if exists then 
    App.GG.Coord.self_and_front_columns.go(App.GG.Coord.front(coord, team), team, grid) ++ list
  else
    []

