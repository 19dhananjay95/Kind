type Kind.Comp {
  nil,
  var(name: Kind.Name),
  ref(name: Kind.Name),
  lam(name: Kind.Name, body: Kind.Comp),
  app(func: Kind.Comp, argm: Kind.Comp),
  let(name: Kind.Name, expr: Kind.Comp, body: Kind.Comp),
  eli(prim: Kind.Comp.Prim, expr: Kind.Comp),
  ins(prim: Kind.Comp.Prim, expr: Kind.Comp),
  nat(natx: Nat),
  chr(chrx: Char),
  str(strx: String),
}

type Kind.Comp.Prim {
  bool,
  nat,
  string,
  data(ctrs: Kind.Comp.Prim.ADT),
}

Kind.Comp.Prim.ADT: Type
  List(Pair(String, List(String)))

Kind.Comp.as_adt.get_fields(term: Kind.Term): List(String)
  case term {
    all:
      let head = term.name
      let tail = Kind.Comp.as_adt.get_fields(term.body(Kind.Term.var("",0),Kind.Term.var("",0)))
      head & tail
  } default []

Kind.Comp.as_adt.get_constructors(term: Kind.Term): Kind.Comp.Prim.ADT
  case term {
    all:
      let tail = Kind.Comp.as_adt.get_constructors(term.body(Kind.Term.var("",0), Kind.Term.var("",0)))
      let name = term.name
      let flds = Kind.Comp.as_adt.get_fields(term.xtyp)
      {name,flds} & tail
  } default []

Kind.Comp.as_adt(term: Kind.Term, defs: Kind.Defs): Maybe(Kind.Comp.Prim)
  let term = Kind.Term.reduce(term, defs)
  case term {
    all:
      if String.ends_with(term.self, ".Self") then
        let body = term.body(Kind.Term.var("",0),Kind.Term.var("",0))
        let data = Kind.Comp.as_adt.get_constructors(body)
        some(Kind.Comp.Prim.data(data))
      else
        none
  } default none

Kind.Comp.prims: List(Pair(String, Kind.Comp.Prim))
  [
    {"Bool", Kind.Comp.Prim.bool}
    {"Nat", Kind.Comp.Prim.nat}
    //"Bits"
    //"U8"
    //"U16"
    //"U32"
    //"U64"
    //"U256"
    //"F64"
    //"String"
    //"Buffer32"
  ]

Kind.Comp.prim_names: List(String)
  List.map!!(Pair.fst!!, Kind.Comp.prims)

Kind.Comp.prim_of(type: Kind.Term, defs: Kind.Defs): Maybe(Kind.Comp.Prim)
  let result = none
  for prim in Kind.Comp.prims with result:
    open prim
    case result {
      none:
        if Kind.Term.equal(type, Kind.Term.ref(prim.fst), defs) then
          some(prim.snd)
        else
          none
      some: result
    }
  result

//var is_prim = {
  //Unit     : 1,
  //Bool     : 1,
  //Nat      : 1,
  //Bits     : 1,
  //U8       : 1,
  //U16      : 1,
  //U32      : 1,
  //U64      : 1,
  //U256     : 1,
  //F64      : 1,
  //String   : 1,
  //Buffer32 : 1,
//};




Kind.Comp.compile(term: Kind.Term, type: Maybe(Kind.Term), defs: Kind.Defs, size: Nat): Pair(Kind.Comp, Kind.Term)
  case type {
    some:
      let typv = Kind.Term.reduce(type.value, defs)
      case term {
        lam: case typv {
          all:
            let self_var = Kind.Term.ann(true, term, type.value)
            let name_var = Kind.Term.ann(true, Kind.Term.var("_" | term.name, size + 1), typv.xtyp)
            let body_typ = typv.body(self_var, name_var)
            let {body_cmp,body_typ} = Kind.Comp.compile(term.body(name_var), some(body_typ), defs, size + 1)
            let term_cmp = if typv.eras
              then body_cmp
              else Kind.Comp.lam("_" | term.name | "$" | Nat.show(size + 1), body_cmp)
            let term_cmp = case Kind.Comp.as_adt(type.value, defs) as got_adt {
              some: Kind.Comp.ins(got_adt.value, term_cmp)
              none: case Kind.Comp.prim_of(type.value, defs) as got_prim {
                some: Kind.Comp.ins(got_prim.value, term_cmp)
                none: term_cmp
              }
            }
            {term_cmp, type.value}
        } default {Kind.Comp.nil, Kind.Term.typ}
        let:
          let {expr_cmp,expr_typ} = Kind.Comp.compile(term.expr, none, defs, size)
          let expr_var = Kind.Term.ann(true, Kind.Term.var("_" | term.name, size + 1), expr_typ)
          let {body_cmp,body_typ} = Kind.Comp.compile(term.body(expr_var), type, defs, size + 1)
          let term_cmp = Kind.Comp.let("_" | term.name | "$" | Nat.show(size + 1), expr_cmp, body_cmp)
          let term_typ = body_typ
          {term_cmp, term_typ}
        ori:
          Kind.Comp.compile(term.expr, type, defs, size)
      } default case typv {
        typ: {Kind.Comp.nil, Kind.Term.typ}
      } default {Pair.fst!!(Kind.Comp.compile(term,none,defs,size)), type.value}
    none: case term {
      var: {
        Kind.Comp.var(term.name | "$" | Nat.show(term.indx))
        Kind.Term.var(term.name, term.indx)
      }
      ref:
        let got = defs{term.name}
        without got: {Kind.Comp.nil, Kind.Term.typ}
        {
          Kind.Comp.ref(term.name)
          open got; got.type
        }
      typ: {
        Kind.Comp.nil
        Kind.Term.typ
      }
      app:
        let {func_cmp, func_typ} = Kind.Comp.compile(term.func, none, defs, size)
        case Kind.Term.reduce(func_typ, defs) as func_typ {
          all:
            let {argm_cmp, argm_typ} = Kind.Comp.compile(term.argm, some(func_typ.xtyp), defs, size)
            let term_typ = func_typ.body(term.func, term.argm)
            let term_cmp = case Kind.Comp.as_adt(func_typ, defs) as ftyp_adt {
              some: Kind.Comp.eli(ftyp_adt.value, func_cmp)
              none: case Kind.Comp.prim_of(func_typ, defs) as ftyp_pri {
                some: Kind.Comp.eli(ftyp_pri.value, func_cmp)
                none: func_cmp
              }
            }
            let term_cmp = if func_typ.eras
              then term_cmp
              else Kind.Comp.app(term_cmp, argm_cmp)
            {term_cmp, term_typ}
        } default {Kind.Comp.nil, Kind.Term.typ}
        let:
          let {expr_cmp, expr_typ} = Kind.Comp.compile(term.expr, none, defs, size)
          let expr_var = Kind.Term.ann(true, Kind.Term.var("_" | term.name, size + 1), expr_typ)
          let {body_cmp, body_typ} = Kind.Comp.compile(term.body(expr_var), none, defs, size + 1)
          {Kind.Comp.let("_" | term.name | "$" | Nat.show(size + 1), expr_cmp, body_cmp), body_typ}
        def:
          Kind.Comp.compile(term.body(term.expr), none, defs, size)
        all:
          {Kind.Comp.nil, Kind.Term.typ}
        ann:
          Kind.Comp.compile(term.term, some(term.type), defs, size)
        loc:
          Kind.Comp.compile(term.term, none, defs, size)
        nat:
          {Kind.Comp.nat(term.natx), Kind.Term.ref("Nat")}
        chr:
          {Kind.Comp.chr(term.chrx), Kind.Term.ref("Char")}
        str:
          {Kind.Comp.str(term.strx), Kind.Term.ref("String")}
    } default {Kind.Comp.nil, Kind.Term.typ}
  }

Kind.Comp.Prim.show(prim: Kind.Comp.Prim): String
  case prim {
    bool: "Bool"
    nat: "Nat"
    string: "String"
    data: "data{" | String.join("|", List.mapped!(prim.ctrs)!((x) {c,f} = x; c | String.join(",", f))) | "}"
  }

Kind.Comp.show(comp: Kind.Comp): String
  case comp {
    nil: "?"
    var: comp.name // name: Kind.Name),
    ref: comp.name // name: Kind.Name),
    lam: "Î»" | comp.name | "." | Kind.Comp.show(comp.body) // name: Kind.Name, body: Kind.Comp),
    app: "(" | Kind.Comp.show(comp.func) | " " | Kind.Comp.show(comp.argm) | ")" // func: Kind.Comp, argm: Kind.Comp),
    let: "$" | comp.name | "=" | Kind.Comp.show(comp.expr) | ";" | Kind.Comp.show(comp.body)
    eli: "(" | Kind.Comp.Prim.show(comp.prim) | " " | Kind.Comp.show(comp.expr) | ")" // prim: Kind.Comp.Prim, expr: Kind.Comp),
    ins: "(" | Kind.Comp.Prim.show(comp.prim) | " " | Kind.Comp.show(comp.expr) | ")" // prim: Kind.Comp.Prim, expr: Kind.Comp),
    nat: Nat.show(comp.natx) // natx: Nat),
    chr: "'" | String.cons(comp.chrx, String.nil) | "'" // chrx: Char),
    str: "\"" | comp.strx | "\"" // strx: String),
  }
