type V3 {
  new(x: F64, y: F64, z: F64)
}

V3.map(fn: F64 -> F64, v: V3): V3
  open v
  V3.new(fn(v.x), fn(v.y), fn(v.z))

V3.add(a: V3, b: V3): V3
  open a; open b; {F64.add(a.x,b.x), F64.add(a.y,b.y), F64.add(a.z,b.z)}


V3.sub(a: V3, b: V3): V3
  open a; open b; {F64.sub(a.x,b.x), F64.sub(a.y,b.y), F64.sub(a.z,b.z)}

V3.mul(a: V3, b: V3): V3
  open a; open b; {F64.mul(a.x,b.x), F64.mul(a.y,b.y), F64.mul(a.z,b.z)}

V3.len(a: V3, b: V3): F64
  open a
  F64.pow(F64.add(F64.mul(a.x,a.x), F64.add(F64.mul(a.y,a.y), F64.mul(a.z,a.z))), 0.5#64)

V3.rot90(a: V3): V3
  open a
  {a.y, F64.sub(0.0#64, a.y), 0.0#64}

V3.eql(a: V3, b: V3): Bool
  open a; open b; F64.eql(a.x,b.x) && F64.eql(a.y,b.y) && F64.eql(a.z,b.z)

V3.norm(a: V3): V3
  open a
  let len = F64.pow(F64.add(F64.mul(a.x,a.x), F64.add(F64.mul(a.y,a.y), F64.mul(a.z,a.z))), 0.5#64)
  {F64.div(a.x,len), F64.div(a.y,len), F64.div(a.z,len)}

V3.scale(x: F64, a: V3): V3
  open a
  {F64.mul(a.x,x), F64.mul(a.y,x), F64.mul(a.z,x)}

V3.dot(a: V3, b: V3): F64
  open a
  open b
  F64.add(F64.mul(a.x,b.x), F64.add(F64.mul(a.y,b.y), F64.mul(a.z,b.z)))

V3.look_at(a: V3, b: V3): V3
  if V3.eql(a, b) then
    {0.0#64, 0.0#64, 0.0#64}
  else
    V3.norm(V3.sub(b, a))

V3.sqrdist(a: V3, b: V3): F64
  open a
  open b
  F64.add( F64.pow(F64.sub(a.x,b.x), 2.0#64),
  F64.add( F64.pow(F64.sub(a.y,b.y), 2.0#64),
           F64.pow(F64.sub(a.z,b.z), 2.0#64)))

V3.dist(a: V3, b: V3): F64
  F64.pow(V3.sqrdist(a, b), 0.5#64)

// Rotates a vector around an arbitrary point
// - theta : the angle (in degrees) to rotate, 
//           positive values rotate clockwise,
//           while negative rotate counterclockwise
// - v     : the vector you want to rotate
// - p     : pivot to be used, if p = v3(0,0,0) 
//           it rotates a vector around the origin
//           center of the screen 
V3.rotate(theta: F64, v: V3, p: V3) : V3 
  open v
  open p
  let rad = F64.mul(theta, F64.div(F64.pi, 180.0#64))
  let s   = F64.sin(rad)
  let c   = F64.cos(rad)
  let x   = F64.sub(F64.add(p.x, F64.mul(F64.sub(v.x, p.x), c)), F64.mul(F64.sub(v.y, p.y), s))
  let y   = F64.add(F64.add(p.y, F64.mul(F64.sub(v.x, p.x), s)), F64.mul(F64.sub(v.y, p.y), c))
  let z   = 0.0#64
  {x, y, z}

//// A finite line segment between two points
//T Segment
//| segment(a: V3, b: V3)

//// An infinite line
//T Line
//| line(pos: V3, dir: V3)

//// A circle/sphere
//T Circle
//| circle(pos: V3, rad: Number)

//// The boundary of a polygon
//T Boundary
//| boundary(points: List(V3))

//// Squared distance between a point and a segment
//point_segment_sqrdist(p: V3, s: Segment) : Number
  //case s |segment
  //case s.a as a |v3
  //case s.b as b |v3
  //case p |v3
  //let l = 0
  //let l = l + ((a.x - b.x) ** 2)
  //let l = l + ((a.y - b.y) ** 2)
  //let t = 0
  //let t = t + ((p.x - a.x) * (b.x - a.x))
  //let t = t + ((p.y - a.y) * (b.y - a.y))
  //let t = t \ l
  //let t = max(0, min(1, t))
  //let d = 0
  //let k = (p.x - (a.x + (t * (b.x - a.x)))) ** 2
  //let d = d + k
  //let k = (p.y - (a.y + (t * (b.y - a.y)))) ** 2
  //let d = d + k
  //d

//// Distance between a point and a segment
//point_segment_dist(p: V3, s: Segment): Number
  //point_segment_sqrdist(p, s) ** 0.5

//// The two intersection points of a circle and a line
//circle_line_intersection(circle: Circle, line: Line)
//: Maybe(Pair(V3,V3))
  //case circle |circle
  //case line |line
  //case circle.pos |v3
  //case line.pos |v3
  //case line.dir |v3
  //let cx = circle.pos.x
  //let cy = circle.pos.y
  //let dx = line.dir.x
  //let dy = line.dir.y
  //let x1 = line.pos.x - cx
  //let y1 = line.pos.y - cy
  //let x2 = (line.pos.x + dx) - cx
  //let y2 = (line.pos.y + dy) - cy
  //let dd = (x1 * y2) - (x2 * y1)
  //let de = (circle.rad * circle.rad) - (dd * dd) 
  //if (de < 0) || (de === 0) then
    //none(_)
  //else
    //let sx = if dy < 0 then 0 - dx else dx
    //let sy = if dy < 0 then 0 - dy else dy
    //let px = sx * (de ** 0.5)
    //let py = sy * (de ** 0.5)
    //let qx = dd * dy
    //let qy = (0 - dd) * dx
    //let ax = qx - px
    //let ay = qy - py
    //let bx = qx + px
    //let by = qy + py
    //let ux = ax + cx
    //let uy = ay + cy
    //let vx = bx + cx
    //let vy = by + cy
    //some(_ pair(__ v3(ux,uy,0), v3(vx,vy,0)))

//circle_to_circle_hit_dist(a: Circle, d: V3, b: Circle)
//: Maybe(Number)
  //case a |circle
  //case b |circle
  //let r = a.rad
  //let c = circle(b.pos, a.rad + b.rad)
  //let l = line(a.pos, norm_v3(d))
  //let p = circle_line_intersection(c, l)
  //case p
  //| none => none(_)
  //| some =>
    //case p.value as p |pair
    //let d0 = sqrdist_v3(a.pos, p.fst)
    //let d1 = sqrdist_v3(a.pos, p.snd)
    //let hp = if d0 < d1 then p.fst else p.snd
    //let dt = dot_v3(d, sub_v3(hp, a.pos))
    //let ds = sqrdist_v3(hp, a.pos)
    //if dt > 0 then
      //some(_ ds ** 0.5)
    //else
      //none(_)

//// Circle-boundary intersection test
//circle_boundary_intersects(c: Circle, b: Boundary): Number
  //case b |boundary
  //case c |circle
  //case b.points as l0
  //| nil => 0
  //| cons => case l0.tail as l1
    //| nil => 0
    //| cons => 
      //let p0 = l0.head
      //let p1 = l1.head
      //let sg = segment(p0, p1)
      //let cd = point_segment_sqrdist(c.pos, sg)
      //if cd < (c.rad * c.rad) then
        //1
      //else
        //let boun = boundary(cons(_ l1.head, l1.tail))
        //circle_boundary_intersects(c, boun)

//// Polygon to segments
//polygon_to_segments(pos: V3, dir: V3, pts: List(V3)) : List(Segment)
  //let transform = (pnt: V3) =>
    //case pnt |v3
    //case dir |v3
    //let a = atan(dir.y, dir.x)
    //let x = (pnt.x * cos(a)) - (pnt.y * sin(a))
    //let y = (pnt.x * sin(a)) + (pnt.y * cos(a))
    //let z = pnt.z
    //add_v3(pos, v3(x,y,z))
  //let nil = (pt_a, pt_0) =>
    //case pt_0
    //|none => nil(_)
    //|some => case pt_a
      //|none => nil(_)
      //|some =>
        //let p0 = transform(pt_a.value)
        //let p1 = transform(pt_0.value)
        //let sg = segment(p0, p1)
        //cons(_ sg, nil(_))
  //let cons = (pt_b, segs, pt_a, pt_0) =>
    //case pt_a
    //with pt_b : V3
    //with pt_0 : Maybe(V3)
    //|none =>
      //segs(some(_ pt_b), some(_ pt_b))
    //|some =>
      //let pt_0 = case pt_0 |none some(_ pt_b) |some pt_0
      //let p0 = transform(pt_a.value)
      //let p1 = transform(pt_b)
      //let sg = segment(p0, p1)
      //cons(_ sg, segs(some(_ pt_b), pt_0))
  //fold(V3; Maybe(V3) -> Maybe(V3) -> List(Segment);
    //nil, cons, pts, none(_), none(_))
