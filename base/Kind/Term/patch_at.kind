Kind.Term.patch_at(path: Kind.Path, term: Kind.Term, fn: Kind.Term -> Kind.Term): Kind.Term
  case term {
    all: case path {
      e: fn(term)
      o: Kind.Term.all(term.eras, term.self, term.name, Kind.Term.patch_at(path.pred,term.xtyp,fn), term.body)
      i: Kind.Term.all(term.eras, term.self, term.name, term.xtyp, (s,x) Kind.Term.patch_at(path.pred,term.body(s,x),fn))
    }
    lam: case path {
      e: fn(term),
      o: Kind.Term.lam(term.name, (x) Kind.Term.patch_at(Bits.tail(path), term.body(x), fn))
      i: Kind.Term.lam(term.name, (x) Kind.Term.patch_at(Bits.tail(path), term.body(x), fn))
    }
    app: case path {
      e: fn(term)
      o: Kind.Term.app(Kind.Term.patch_at(path.pred,term.func,fn), term.argm)
      i: Kind.Term.app(term.func, Kind.Term.patch_at(path.pred,term.argm,fn))
    }
    let: case path {
      e: fn(term)
      o: Kind.Term.let(term.name, Kind.Term.patch_at(path.pred,term.expr,fn), term.body)
      i: Kind.Term.let(term.name, term.expr, (x) Kind.Term.patch_at(path.pred,term.body(x),fn))
    }
    ann: case path {
      e: fn(term)
      o: Kind.Term.ann(term.done, Kind.Term.patch_at(path.pred,term.term,fn), term.type)
      i: Kind.Term.ann(term.done, term.term, Kind.Term.patch_at(path.pred,term.type,fn))
    }
    cse: case path {
      e: fn(term)
      o: case path.pred {
        e: fn(term)
        o: Kind.Term.cse(term.path, Kind.Term.patch_at(path.pred.pred,term.expr,fn), term.name, term.with, term.cses, term.moti)
        i: 
          let term.with = Kind.Path.patch_at.list!(path.pred.pred, term.with, (ann_path, ann)
            open ann
            case ann_path {
              e: ann
              o: Kind.Ann.new(ann.name, Kind.Term.patch_at(ann_path.pred, ann.term, fn), ann.type)
              i: Kind.Ann.new(ann.name, ann.term, case ann.type { none: none, some: some(Kind.Term.patch_at(ann_path.pred, ann.type.value, fn)) })
            })
          Kind.Term.cse(term.path, term.expr, term.name, term.with, term.cses, term.moti)
      }
      i: case path.pred {
        e: fn(term)
        o: 
          let term.cses = Kind.Path.patch_at.bitsmap!(path.pred.pred, term.cses, (cse_path, cse_term) Kind.Term.patch_at(cse_path, cse_term, fn))
          Kind.Term.cse(term.path, term.expr, term.name, term.with, term.cses, term.moti)
        i:
          let term.moti = case term.moti {
            none: none
            some: some(Kind.Term.patch_at(path.pred.pred, term.moti.value, fn))
          }
          Kind.Term.cse(term.path, term.expr, term.name, term.with, term.cses, term.moti)
      }
    }
    new: Kind.Term.new(Kind.Path.patch_at.list!(path, term.args, (arg_path, arg) Kind.Term.patch_at(arg_path, arg, fn)))
    get: case path {
      e: fn(term)
      o: Kind.Term.get(Kind.Term.patch_at(path.pred,term.expr,fn), term.fkey)
      i: Kind.Term.get(Kind.Term.patch_at(path.pred,term.expr,fn), term.fkey)
    }
    set: case path {
      e: fn(term)
      o: Kind.Term.set(Kind.Term.patch_at(path.pred,term.expr,fn), term.fkey, term.fval)
      i: Kind.Term.set(term.expr, term.fkey, Kind.Term.patch_at(path.pred,term.fval,fn))
    }
    ope: case path {
      e: fn(term),
      o: Kind.Term.ope(term.name, Kind.Term.patch_at(path.pred,term.arg0,fn), term.arg1),
      i: Kind.Term.ope(term.name, term.arg0, Kind.Term.patch_at(path.pred,term.arg1,fn)),
    }
    ori: Kind.Term.ori(term.orig, Kind.Term.patch_at(path, term.expr, fn))
    _: case path {
      e: fn(term),
      o: term,
      i: term,
    }
  }
