// Event handler
App.GG.when: App.When<App.GG.State>
  (event, state)
  let local = state@local
  case event {
    // init: IO {
    //   App.watch!(App.room_zero)
    //   App.new_post!(App.room_zero, "")
    // }
    frame:
      let new_grid = App.GG.when.update_grid(local@grid)
      let new_local = local@grid <- new_grid
      App.set_local!(new_local)
    key_down:
      log(U16.show(event.code))
      if (event.code <? 41#16) && (event.code >? 36) then  
        let new_grid = App.GG.when.movement_keys(event.code, local@grid)
        let new_local = local@grid <- new_grid
        App.set_local!(new_local)
      else
        switch U16.eql(event.code) {
          // Spacebar
          32#16: 
            let new_grid = App.GG.when.use_chip(local@grid)
            let new_local = local@grid <- new_grid
            App.set_local!(new_local)
        }default App.pass!
  } default App.pass!

App.GG.when.update_grid(grid: App.GG.Grid): App.GG.Grid
  let new_grid = grid 
  for coord:tile in grid with new_grid:
    App.GG.when.update_tile(coord, new_grid)
  new_grid
    

App.GG.when.update_tile(coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  let new_grid = 
    Maybe {
      get creature = App.GG.Creature.get(coord, grid)
      let mod = App.GG.when.update_action
      let new_grid = App.GG.Creature.modify_at(mod, coord, grid)
      return new_grid
    } <> grid

  let new_grid = 
    Maybe {
      get creature = App.GG.Creature.get(coord, new_grid)
      get action = creature@actions@current 
      get hasnt_acted = if creature@actions@has_acted then none else some(unit)
      let origin = App.GG.Effect.Origin.creature
      let result = action@effect(coord, origin, new_grid) 
      get new_grid = case result {err: none, new: some(result.grid)}
      return new_grid
    } <> new_grid

  let new_grid =
    Maybe {
      get projectiles = App.GG.Projectile.get_list(coord, new_grid)
      let pair = {0, new_grid}
      for projectile in projectiles with pair:
        let {idx, new_grid} = pair
        let origin = App.GG.Effect.Origin.projectile(idx)
        let result = projectile@effect(coord, origin, new_grid)
        let new_grid = case result {err: new_grid, new: result.grid}
        {idx +1, new_grid}
      return pair@snd
    } <> new_grid


  new_grid

App.GG.when.use_chip(grid: App.GG.Grid): App.GG.Grid
  let pair = App.GG.Slime.find_coord(grid)
  case pair {
    none: grid
    some:
      let {creature, coord} = pair.value
      case creature@category as category {
        minion: grid
        slime:
          case category.chips {
            nil: grid
            cons: 
              open category.chips.head
              let action = App.GG.Actions.Data.new(0, category.chips.head.effect, App.GG.Actions.Category.chip)
              App.GG.Creature.modify_at(App.GG.when.add_action(action), coord, grid)
          }
      }
  }

App.GG.when.update_action(creature: App.GG.Creature): App.GG.Creature
  let as = creature@actions
  let na = as@next
  let a  = as@current
  if as@has_acted then creature else 
    case a {
      none:
        case na {
          none: creature
          some:
            //log("22") 
            let new_actions = as@current <- some(na.value)
            let new_actions = new_actions@next <- none
            let new_creature = creature@actions <- new_actions
            new_creature
        }
      some:
        creature
    }


App.GG.when.add_action(action: App.GG.Actions.Data, creature: App.GG.Creature): App.GG.Creature
  let actions = creature@actions
  
  let new_actions = actions@next <- some(action)
  creature@actions <- new_actions

App.GG.when.movement_keys(key: U16, grid: App.GG.Grid): App.GG.Grid
  let char_tile = App.GG.Slime.find_coord(grid)
  Maybe {
    get pair = char_tile // creature + coord
    let ori = pair@snd
    get d_c = // Destination Coord 
      switch U16.eql(key) {
        // left
        37#16: some({ori@fst - 1, ori@snd})
        // up
        38#16: some({ori@fst, ori@snd - 1})
        // right
        39#16: some({ori@fst + 1, ori@snd})
        // down
        40#16: some({ori@fst, ori@snd + 1})
      }default none
    get d_t = BBT.lookup!!(App.GG.Grid.cmp, d_c, grid)
    return App.GG.Grid.move_creature(ori, d_c, grid)
  } <> grid

