// Bool
// ====

Bool: Type
  self<P: Bool -> Type> ->
  P(true) ->
  P(false) ->
  P(self)

true: Bool
  <> (t) (f) t

false: Bool
  <> (t) (f) f

_bool : (b: Bool) -> <P: Bool -> Type> -> P(true) -> P(false) -> P(b)
  (b) <P> (t) (f) b<P>(t)(f)

not: Bool -> Bool
  (a)
  a<() Bool>
  | false;
  | true;

or: Bool -> Bool -> Bool
  (a) (b)
  a<() Bool>
  | b<() Bool>
    | true;
    | true;;
  | b<() Bool>
    | true;
    | false;;

and: Bool -> Bool -> Bool
  (a) (b)
  a<() Bool>
  | b<() Bool>
    | true;
    | false;;
  | b<() Bool>
    | false;
    | false;;

// Cmp

Cmp : Type
  self<P: Cmp -> Type> ->
  P(ltn) ->
  P(eql) ->
  P(gtn) ->
  P(self)

ltn: Cmp
  <> (ltn) (eql) (gtn) ltn

eql: Cmp
  <> (ltn) (eql) (gtn) eql

gtn: Cmp
  <> (ltn) (eql) (gtn) gtn

// Bit
// ===

Bit : Type
  self<P: Bit -> Type> ->
  P(t0) ->
  P(t1) ->
  P(self)

t0: Bit
  <> (t0) (t1) t0

t1: Bit
  <> (t0) (t1) t1

// Nat
// ===

Nat: Type
  self<P: (x: Nat) -> Type> ->
  (zero: P(zero)) ->
  (succ: (pred: Nat) -> P(succ(pred))) ->
  P(self)

zero: Nat
  <> (z) (s) z

succ: Nat -> Nat
  (n)
  <> (z) (s) s(n)

pred: Nat -> Nat
  (n)
  n<() Nat>
  | zero;
  | (n.pred) n.pred;

fold_nat : (n: Nat) -> <P: Nat -> Type> -> P(zero) -> ((n:Nat) -> P(n) -> P(succ(n))) -> P(n)
  (n) <P> (z) (s)
  n<P>(z)((pred) s(pred)(fold_nat(pred)<P>(z)(s)))

double: Nat -> Nat
  (n)
  n<() Nat>
  | zero;
  | (n.pred) succ(succ(double(n.pred)));

add: Nat -> Nat -> Nat
  (n) (m)
  n<() Nat>
  | m;
  | (n.pred) succ(add(n.pred)(m));

sub: Nat -> Nat -> Nat
  (n) (m)
  m<() Nat>
  | n;
  | (m.pred) sub(pred(n))(m.pred);

nat_cmp: Nat -> Nat -> Cmp
  (a) (b)
  a<() Cmp>
  | b<() Cmp>
    | eql;
    | (b.pred) ltn;;
  | (a.pred)
    b<() Cmp>
    | gtn;
    | (b.pred) nat_cmp(a.pred)(b.pred);;

nat_ltn: Nat -> Nat -> Bool
  (a) (b) nat_cmp(a)(b)<() Bool>(true)(false)(false)

nat_lte: Nat -> Nat -> Bool
  (a) (b) nat_cmp(a)(b)<() Bool>(true)(true)(false)

nat_eql: Nat -> Nat -> Bool
  (a) (b) nat_cmp(a)(b)<() Bool>(false)(true)(false)

nat_gte: Nat -> Nat -> Bool
  (a) (b) nat_cmp(a)(b)<() Bool>(false)(true)(true)

nat_gtn: Nat -> Nat -> Bool
  (a) (b) nat_cmp(a)(b)<() Bool>(false)(false)(true)

n0: Nat
  zero

n1: Nat
  succ(n0)

n2: Nat
  succ(n1)

n3: Nat
  succ(n2)

n4: Nat
  succ(n3)

n5: Nat
  succ(n4)

n6: Nat
  succ(n5)

n7: Nat
  succ(n6)

n8: Nat
  succ(n7)

n9: Nat
  succ(n8)

n9: Nat
  succ(n8)

n10: Nat
  succ(n9)

n11: Nat
  succ(n10)

n12: Nat
  succ(n11)

n13: Nat
  succ(n12)

n14: Nat
  succ(n13)

n15: Nat
  succ(n14)

n16: Nat
  succ(n15)

n17: Nat
  succ(n16)

n18: Nat
  succ(n17)

n19: Nat
  succ(n18)

n20: Nat
  succ(n19)

n21: Nat
  succ(n20)

n22: Nat
  succ(n21)

n23: Nat
  succ(n22)

n24: Nat
  succ(n23)

n25: Nat
  succ(n24)

n26: Nat
  succ(n25)

n27: Nat
  succ(n26)

n28: Nat
  succ(n27)

n29: Nat
  succ(n28)

n30: Nat
  succ(n29)

n31: Nat
  succ(n30)

n32: Nat
  succ(n31)

// Pair
// ====

Pair: Type -> Type -> Type
  (A) (B)
  self<P: Pair(A)(B) -> Type> ->
  (pair: (a: A) -> (b: B) -> P(pair<A><B>(a)(b))) ->
  P(self)

pair: <A: Type> -> <B: Type> -> A -> B -> Pair(A)(B)
  <> <> (a) (b)
  <> (pair)
  pair(a)(b)

fst: <A: Type> -> <B: Type> -> Pair(A)(B) -> A
  <A> <B> (pair)
  pair<() A>((a) (b) a)

snd: <A: Type> -> <B: Type> -> Pair(A)(B) -> B
  <A> <B> (pair)
  pair<() B>((a) (b) b)

// Maybe
// =====

Maybe: Type -> Type
  (A)
  self<P: Maybe(A) -> Type> ->
  (none: P(none<A>)) ->
  (some: (value: A) -> P(some<A>(value))) ->
  P(self)

none: <A: Type> -> Maybe(A)
  <>
  <> (none) () none

some: <A: Type> -> A -> Maybe(A)
  <> (value)
  <> () (some) some(value)

// List
// ====

List: (A: Type) -> Type
  (A)
  self<P: (x: List(A)) -> Type> ->
  (nil: P(nil<A>)) ->
  (cons: (head: A) -> (tail: List(A)) -> P(cons<A>(head)(tail))) ->
  P(self)

nil: <A: Type> -> List(A)
  <A>
  <> (nil) () nil

cons: <A: Type> -> (:A) -> (:List(A)) -> List(A)
  <A> (head) (tail)
  <> () (cons) cons(head)(tail)

find_aux: <A: Type> -> List(A) -> (A -> Nat -> Bool) -> Nat -> Maybe(Pair(A)(Nat))
  <A> (list) (cond) (indx)
  list<() Maybe(Pair(A)(Nat))>
  | none<Pair(A)(Nat)>;
  | (head) (tail)
    cond(head)(indx)<() Maybe(Pair(A)(Nat))>
    | some<Pair(A)(Nat)>(pair<A><Nat>(head)(indx));
    | find_aux<A>(tail)(cond)(succ(indx));;

find: <A: Type> -> List(A) -> (A -> Nat -> Bool) -> Maybe(Pair(A)(Nat))
  <A> (list) (cond)
  find_aux<A>(list)(cond)(zero)

take: <A: Type> -> Nat -> List(A) -> List(A)
  <A> (n) (list)
  list<() List(A)>
  | nil<A>;
  | (head) (tail)
    n<() List(A)>
    | nil<A>;
    | (pred) cons<A>(head)(take<A>(pred)(tail));;

drop: <A: Type> -> Nat -> List(A) -> List(A)
  <A> (n) (list)
  n<() List(A)>
  | list;
  | (pred)
    list<() List(A)>
    | nil<A>;
    | (head) (tail) drop<A>(pred)(tail);;

is_empty: <A: Type> -> List(A) -> Bool
  <A> (list)
  list<() Bool>
  | true;
  | (head) (tail) false;

zip_with: <A: Type> -> <B: Type> -> <C: Type> -> (A -> B -> C) -> List(A) -> List(B) -> List(C)
  <A> <B> <C> (fn) (as) (bs)
  as<() List(C)>
  | nil<C>;
  | (a.head) (a.tail)
    bs<() List(C)>
    | nil<C>;
    | (b.head) (b.tail)
      let head = fn(a.head)(b.head)
      let tail = zip_with<A><B><C>(fn)(a.tail)(b.tail)
      cons<C>(head)(tail);;

all_satisfy: <A: Type> -> (A -> Bool) -> List(A) -> Bool
  <A> (cond) (list)
  list<() Bool>
  | true;
  | (head) (tail)
    cond(head)<() Bool>
    | all_satisfy<A>(cond)(tail);
    | false;;

any_satisfy: <A: Type> -> (A -> Bool) -> List(A) -> Bool
  <A> (cond) (list)
  list<() Bool>
  | false;
  | (head) (tail)
    cond(head)<() Bool>
    | true;
    | any_satisfy<A>(cond)(tail);;

all_true: List(Bool) -> Bool
  (list) all_satisfy<Bool>((x) x)(list)

any_true: List(Bool) -> Bool
  (list) any_satisfy<Bool>((x) x)(list)

list_len: <A: Type> -> List(A) -> Nat
  <A> (list)
  list<() Nat>
  | zero;
  | (head) (tail)
    succ(list_len<A>(tail));

concat: <A: Type> -> List(A) -> List(A) -> List(A)
  <A> (as) (bs)
  as<() List(A)>
  | bs;
  | (head) (tail)
    cons<A>(head)(concat<A>(tail)(bs));

flatten : <A: Type> -> List(List(A)) -> List(A)
  <A> (as)
  as<() List(A)>
  | nil<A>;
  | (head) (tail)
    concat<A>(head)(flatten<A>(tail));

single : <A : Type> -> (x : A) -> List(A)
  <A> (x) cons<A>(x)(nil<A>)

// Bits
// ====

Bits: Type
  self<P: Bits -> Type> ->
  (be: P(be)) ->
  (b0: (pred: Bits) -> P(b0(pred))) ->
  (b1: (pred: Bits) -> P(b1(pred))) ->
  P(self)

be: Bits
  <P> (be) (b0) (b1) be

b0: (bs: Bits) -> Bits
  (bs) <P> (be) (b0) (b1) b0(bs)

b1: (bs: Bits) -> Bits
  (bs) <P> (be) (b0) (b1) b1(bs)

next_bits: (:Bits) -> Bits
  (x)
  x<() Bits>
  | b0(be);
  | (x.pred) b1(x.pred);
  | (x.pred) b0(next_bits(x.pred));

// Map
// ===

Map: (A: Type) -> Type
  (A)
  self<P: (x: Map(A)) -> Type> ->
  (empty: P(empty<A>)) ->
  (multi: (val: Maybe(A)) -> (lft: Map(A)) -> (rgt: Map(A)) -> P(multi<A>(val)(lft)(rgt))) ->
  P(self)

empty: <A: Type> -> Map(A)
  <A>
  <> (empty) () empty

multi: <A: Type> -> (:Maybe(A)) -> (:Map(A)) -> (:Map(A)) -> Map(A)
  <A> (val) (lft) (rgt)
  <> () (multi) multi(val)(lft)(rgt)

singleton_map: <A: Type> -> (:A) -> Map(A)
  <A> (x)
  multi<A>(some<A>(x))(empty<A>)(empty<A>)

lookup: <A: Type> -> (:Bits) -> (:Map(A)) -> Maybe(A)
  <A> (bits) (map)
  let lookup_type = <A: Type> -> (:Bits) -> (:Map(A)) -> Maybe(A)
  bits<() (:Map(A)) -> (:lookup_type) -> Maybe(A)>
  | (map) () map<() Maybe(A)>
    | none<A>;
    | (map.val) () () map.val;
  ;
  | (bits.pred) (map) (lookup) map<() Maybe(A)>
    | none<A>;
    | () (map.lft) () lookup<A>(bits.pred)(map.lft);
  ;
  | (bits.pred) (map) (lookup) map<() Maybe(A)>
    | none<A>;
    | () () (map.rgt) lookup<A>(bits.pred)(map.rgt);
  ;(map)(lookup)

insert: <A: Type> -> (:Bits) -> (:A) -> (:Map(A)) -> Map(A)
  <A> (bits) (val) (map)
  let insert_type = <A: Type> -> (:Bits) -> (:A) -> (:Map(A)) -> Map(A)
  bits<() (:A) -> (:Map(A)) -> (:insert_type) -> Map(A)>
  | () (map) () map<() (:Maybe(A)) -> Map(A)>
    | (val) multi<A>(val)(empty<A>)(empty<A>);
    | () (map.lft) (map.rgt) (val) multi<A>(val)(map.lft)(map.rgt)
    ;(some<A>(val))
  ;
  | (bits.pred) (val) (map) (insert) map<() (:(:Map(A)) -> Map(A)) -> Map(A)>
    | (insert) multi<A>(none<A>)(insert(empty<A>))(empty<A>);
    | (map.val) (map.lft) (map.rgt) (insert) multi<A>(map.val)(insert(map.lft))(map.rgt)
    ;(insert<A>(bits.pred)(val))
  ;
  | (bits.pred) (val) (map) (insert) map<() (:(:Map(A)) -> Map(A)) -> Map(A)>
    | (insert) multi<A>(none<A>)(empty<A>)(insert(empty<A>));
    | (map.val) (map.lft) (map.rgt) (insert) multi<A>(map.val)(map.lft)(insert(map.rgt))
    ;(insert<A>(bits.pred)(val))
  ;(val)(map)(insert)

// Union-Find
// ==========
UElem: (A: Type) -> Type
  (A)
  self<P: (x: UElem(A)) -> Type> ->
  (uelem: (rank: Nat) -> (val: A) -> P(uelem<A>(rank)(val))) ->
  (ulink: (path: Bits) -> P(ulink<A>(path))) ->
  P(self)

uelem: <A: Type> -> (:Nat) -> (:A) -> UElem(A)
  <A> (rank) (val)
  <> (uelem) () uelem(rank)(val)

ulink: <A: Type> -> (:Bits) -> UElem(A)
  <A> (path)
  <> () (ulink) ulink(path)

UPoints: (A: Type) -> Type
  (A)
  self<P: (x: UPoints(A)) -> Type> ->
  (upoints: (last: Bits) -> (map: Map(UElem(A))) -> P(upoints<A>(last)(map))) ->
  P(self)

upoints: <A: Type> -> (:Bits) -> (:Map(UElem(A))) -> UPoints(A)
  <A> (last) (map)
  <> (upoints) upoints(last)(map)

new_points: <A: Type> -> UPoints(A)
  <A> upoints<A>(be)(empty<UElem(A)>)

fresh: <A: Type> -> (:UPoints(A)) -> (:A) -> Pair(UPoints(A))(Bits)
  <A> (uf) (a)
  uf<() Pair(UPoints(A))(Bits)>
  | (uf.last) (uf.map)
    let new_map = insert<UElem(A)>(uf.last)(uelem<A>(zero)(a))(uf.map)
    let new_uf = upoints<A>(next_bits(uf.last))(new_map)
    pair<UPoints(A)><Bits>(new_uf)(uf.last);

ufind_aux: <A: Type> -> <B: Type> ->
          (:Map(UElem(A))) -> (:Bits) ->
          (:(:Bits) -> (:Nat) -> (:A) -> B) -> Maybe(B)
  <A> <B> (map) (path) (k)
  let found = lookup<UElem(A)>(path)(map)
  found<() Maybe(B)>
  | none<B>;
  | (found.val)
    let elem = found.val
    elem<() Maybe(B)>
    | (elem.rank) (elem.val) some<B>(k(path)(elem.rank)(elem.val));
    | (elem.path) ufind_aux<A><B>(map)(path)(k);;

ufind: <A: Type> -> <B: Type> ->
       (:UPoints(A)) -> (:Bits) ->
       (:(:Bits) -> (:Nat) -> (:A) -> B) -> Maybe(B)
  <A> <B> (uf) (path) (k)
  uf<() Maybe(B)>
  | () (uf.map) ufind_aux<A><B>(uf.map)(path)(k);

// Word
// ====

Word: Nat -> Type
  (size)
  self<P: (size: Nat) -> Word(size) -> Type> ->
  (we: P(zero)(we)) ->
  (w0: <size: Nat> -> (pred: Word(size)) -> P(succ(size))(w0<size>(pred))) ->
  (w1: <size: Nat> -> (pred: Word(size)) -> P(succ(size))(w1<size>(pred))) ->
  P(size)(self)

we: Word(zero)
  <P> (we) (w0) (w1)
  we

w0: <size: Nat> -> Word(size) -> Word(succ(size))
  <size> (wo) <P> (we) (w0) (w1)
  w0<size>(wo)

w1: <size: Nat> -> Word(size) -> Word(succ(size))
  <size> (wo) <P> (we) (w0) (w1)
  w1<size>(wo)

word_inc: <size: Nat> -> Word(size) -> Word(size)
  <size> (word)
  word<(size) () Word(size)>
  | we;
  | <size> (pred) w1<size>(pred);
  | <size> (pred) w0<size>(word_inc<size>(pred));

word_add_aux: <size: Nat> -> Word(size) -> Word(size) -> Bool -> Word(size)
  <size> (a) (b) (c)
  ( a<(a.size) () Word(a.size) -> Word(a.size)>
  | (b) we;
  | <a.size> (a.pred) (b)
    ( b<(b.size) () Word(pred(b.size)) -> Word(b.size)>
    | (a.pred)
      we;
    | <b.size> (b.pred) (a.pred)
      c<() Word(succ(b.size))>
      | w1<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(false));  // a=0 b=0 c=0
      | w0<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(false));; // a=0 b=0 c=1
    | <b.size> (b.pred) (a.pred)
      c<() Word(succ(b.size))>
      | w0<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(true));   // a=0 b=1 c=0
      | w1<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(false));  // a=0 b=1 c=1
    ;)(a.pred);
  | <a.size> (a.pred) (b)
    ( b<(b.size) () Word(pred(b.size)) -> Word(b.size)>
    | (a.pred) we;
    | <b.size> (b.pred) (a.pred)
      c<() Word(succ(b.size))>
      | w0<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(true));   // a=1 b=0 c=0
      | w1<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(false));; // a=1 b=0 c=1
    | <b.size> (b.pred) (a.pred)
      c<() Word(succ(b.size))>
      | w1<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(true));   // a=1 b=1 c=0
      | w0<b.size>(word_add_aux<b.size>(a.pred)(b.pred)(true));   // a=1 b=1 c=1
    ;)(a.pred)
  ;)(b)

word_add: <size: Nat> -> Word(size) -> Word(size) -> Word(size)
  <size> (a) (b) word_add_aux<size>(a)(b)(false)

word_cmp_aux: <size: Nat> -> Word(size) -> Word(size) -> Cmp -> Cmp
  <size> (a) (b) (c)
  ( a<(a.size) () Word(a.size) -> Cmp>
  | (b) c;
  | <a.size> (a.pred) (b)
    ( b<(b.size) () Word(pred(b.size)) -> Cmp>
    | (a.pred) c;
    | <b.size> (b.pred) (a.pred) word_cmp_aux<b.size>(a.pred)(b.pred)(c);
    | <b.size> (b.pred) (a.pred) word_cmp_aux<b.size>(a.pred)(b.pred)(ltn)
    ; )(a.pred);
  | <a.size> (a.pred) (b)
    ( b<(b.size) () Word(pred(b.size)) -> Cmp>
    | (a.pred) c;
    | <b.size> (b.pred) (a.pred) word_cmp_aux<b.size>(a.pred)(b.pred)(gtn);
    | <b.size> (b.pred) (a.pred) word_cmp_aux<b.size>(a.pred)(b.pred)(c)
    ; )(a.pred)
  ; )(b)

word_cmp: <size: Nat> -> Word(size) -> Word(size) -> Cmp
  <size> (a) (b)
  word_cmp_aux<size>(a)(b)(eql)

// a > b
word_ltn: <size:Nat> -> Word(size) -> Word(size) -> Bool
  <size> (a) (b)
  word_cmp<size>(a)(b)<() Bool>(true)(false)(false)

// a <= b
word_lte: <size:Nat> -> Word(size) -> Word(size) -> Bool
  <size> (a) (b)
  word_cmp<size>(a)(b)<() Bool>(true)(true)(false)

// a == b
word_eql: <size:Nat> -> Word(size) -> Word(size) -> Bool
  <size> (a) (b)
  word_cmp<size>(a)(b)<() Bool>(false)(true)(false)

// a >= b
word_gte: <size:Nat> -> Word(size) -> Word(size) -> Bool
  <size> (a) (b)
  word_cmp<size>(a)(b)<() Bool>(false)(true)(true)

// a > b
word_gtn: <size:Nat> -> Word(size) -> Word(size) -> Bool
  <size> (a) (b)
  word_cmp<size>(a)(b)<() Bool>(false)(false)(true)

// Uint32
// ======

U32: Type
  Word(n32)

u32_0: U32
  w0<n31>(w0<n30>(w0<n29>(w0<n28>(w0<n27>(w0<n26>(w0<n25>(w0<n24>(
  w0<n23>(w0<n22>(w0<n21>(w0<n20>(w0<n19>(w0<n18>(w0<n17>(w0<n16>(
  w0<n15>(w0<n14>(w0<n13>(w0<n12>(w0<n11>(w0<n10>(w0<n9 >(w0<n8 >(
  w0<n7 >(w0<n6 >(w0<n5 >(w0<n4 >(w0<n3 >(w0<n2 >(w0<n1 >(w0<n0 >(
  we))))))))))))))))))))))))))))))))

u32_inc: U32 -> U32
  word_inc<n32>

u32_add: U32 -> U32 -> U32
  word_add<n32>

// a < b
u32_ltn: U32 -> U32 -> Bool
  word_ltn<n32>

// a <= b
u32_lte: U32 -> U32 -> Bool
  word_lte<n32>

// a == b
u32_eql: U32 -> U32 -> Bool
  word_eql<n32>

// a >= b
u32_gte: U32 -> U32 -> Bool
  word_gte<n32>

// a > b
u32_gtn: U32 -> U32 -> Bool
  word_gtn<n32>

// Char
// ====

Char: Type
  Word(n32)

ascii: Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Char
  (a) (b) (c) (d) (e) (f) (g) (h)
  let ty = <size: Nat> -> Word(size) -> Word(succ(size))
  let wA = a<() ty>(w0)(w1)
  let wB = b<() ty>(w0)(w1)
  let wC = c<() ty>(w0)(w1)
  let wD = d<() ty>(w0)(w1)
  let wE = e<() ty>(w0)(w1)
  let wF = f<() ty>(w0)(w1)
  let wG = g<() ty>(w0)(w1)
  let wH = h<() ty>(w0)(w1)
  wH<n31>(wG<n30>(wF<n29>(wE<n28>(wD<n27>(wC<n26>(wB<n25>(wA<n24>(
  w0<n23>(w0<n22>(w0<n21>(w0<n20>(w0<n19>(w0<n18>(w0<n17>(w0<n16>(
  w0<n15>(w0<n14>(w0<n13>(w0<n12>(w0<n11>(w0<n10>(w0<n9 >(w0<n8 >(
  w0<n7 >(w0<n6 >(w0<n5 >(w0<n4 >(w0<n3 >(w0<n2 >(w0<n1 >(w0<n0 >(
  we))))))))))))))))))))))))))))))))

// ASCII characters
_NUL    : Char ascii(t0)(t0)(t0)(t0)(t0)(t0)(t0)(t0) // \NUL
_SOH    : Char ascii(t0)(t0)(t0)(t0)(t0)(t0)(t0)(t1) // \SOH
_STX    : Char ascii(t0)(t0)(t0)(t0)(t0)(t0)(t1)(t0) // \STX
_ETX    : Char ascii(t0)(t0)(t0)(t0)(t0)(t0)(t1)(t1) // \ETX
_EOT    : Char ascii(t0)(t0)(t0)(t0)(t0)(t1)(t0)(t0) // \EOT
_ENQ    : Char ascii(t0)(t0)(t0)(t0)(t0)(t1)(t0)(t1) // \ENQ
_ACK    : Char ascii(t0)(t0)(t0)(t0)(t0)(t1)(t1)(t0) // \ACK
_BEL    : Char ascii(t0)(t0)(t0)(t0)(t0)(t1)(t1)(t1) // \BEL
_BS     : Char ascii(t0)(t0)(t0)(t0)(t1)(t0)(t0)(t0) // \BS
_HT     : Char ascii(t0)(t0)(t0)(t0)(t1)(t0)(t0)(t1) // \HT
_LF     : Char ascii(t0)(t0)(t0)(t0)(t1)(t0)(t1)(t0) // \LF
_VT     : Char ascii(t0)(t0)(t0)(t0)(t1)(t0)(t1)(t1) // \VT
_FF     : Char ascii(t0)(t0)(t0)(t0)(t1)(t1)(t0)(t0) // \FF
_CR     : Char ascii(t0)(t0)(t0)(t0)(t1)(t1)(t0)(t1) // \CR
_SO     : Char ascii(t0)(t0)(t0)(t0)(t1)(t1)(t1)(t0) // \SO
_SI     : Char ascii(t0)(t0)(t0)(t0)(t1)(t1)(t1)(t1) // \S 
_DLE    : Char ascii(t0)(t0)(t0)(t1)(t0)(t0)(t0)(t0) // \DLE
_DC1    : Char ascii(t0)(t0)(t0)(t1)(t0)(t0)(t0)(t1) // \DC1
_DC2    : Char ascii(t0)(t0)(t0)(t1)(t0)(t0)(t1)(t0) // \DC2
_DC3    : Char ascii(t0)(t0)(t0)(t1)(t0)(t0)(t1)(t1) // \DC3
_DC4    : Char ascii(t0)(t0)(t0)(t1)(t0)(t1)(t0)(t0) // \DC4
_NAK    : Char ascii(t0)(t0)(t0)(t1)(t0)(t1)(t0)(t1) // \NAK
_SYN    : Char ascii(t0)(t0)(t0)(t1)(t0)(t1)(t1)(t0) // \SYN
_ETB    : Char ascii(t0)(t0)(t0)(t1)(t0)(t1)(t1)(t1) // \ETB
_CAN    : Char ascii(t0)(t0)(t0)(t1)(t1)(t0)(t0)(t0) // \CAN
_EM     : Char ascii(t0)(t0)(t0)(t1)(t1)(t0)(t0)(t1) // \EM
_SUB    : Char ascii(t0)(t0)(t0)(t1)(t1)(t0)(t1)(t0) // \SUB
_ESC    : Char ascii(t0)(t0)(t0)(t1)(t1)(t0)(t1)(t1) // \ESC
_FS     : Char ascii(t0)(t0)(t0)(t1)(t1)(t1)(t0)(t0) // \FS
_GS     : Char ascii(t0)(t0)(t0)(t1)(t1)(t1)(t0)(t1) // \GS
_RS     : Char ascii(t0)(t0)(t0)(t1)(t1)(t1)(t1)(t0) // \RS
_US     : Char ascii(t0)(t0)(t0)(t1)(t1)(t1)(t1)(t1) // \US
_space  : Char ascii(t0)(t0)(t1)(t0)(t0)(t0)(t0)(t0) // ' '
_excl   : Char ascii(t0)(t0)(t1)(t0)(t0)(t0)(t0)(t1) // '!'
_quot   : Char ascii(t0)(t0)(t1)(t0)(t0)(t0)(t1)(t0) // '"'
_hash   : Char ascii(t0)(t0)(t1)(t0)(t0)(t0)(t1)(t1) // '#'
_dollar : Char ascii(t0)(t0)(t1)(t0)(t0)(t1)(t0)(t0) // '$'
_percnt : Char ascii(t0)(t0)(t1)(t0)(t0)(t1)(t0)(t1) // '%'
_amp    : Char ascii(t0)(t0)(t1)(t0)(t0)(t1)(t1)(t0) // '&'
_apos   : Char ascii(t0)(t0)(t1)(t0)(t0)(t1)(t1)(t1) // "'"
_lpar   : Char ascii(t0)(t0)(t1)(t0)(t1)(t0)(t0)(t0) // '('
_rpar   : Char ascii(t0)(t0)(t1)(t0)(t1)(t0)(t0)(t1) // ')'
_ast    : Char ascii(t0)(t0)(t1)(t0)(t1)(t0)(t1)(t0) // '*'
_plus   : Char ascii(t0)(t0)(t1)(t0)(t1)(t0)(t1)(t1) // '+'
_comma  : Char ascii(t0)(t0)(t1)(t0)(t1)(t1)(t0)(t0) // ','
_dash   : Char ascii(t0)(t0)(t1)(t0)(t1)(t1)(t0)(t1) // '-'
_period : Char ascii(t0)(t0)(t1)(t0)(t1)(t1)(t1)(t0) // '.'
_sol    : Char ascii(t0)(t0)(t1)(t0)(t1)(t1)(t1)(t1) // '/'
_0      : Char ascii(t0)(t0)(t1)(t1)(t0)(t0)(t0)(t0) // '0'
_1      : Char ascii(t0)(t0)(t1)(t1)(t0)(t0)(t0)(t1) // '1'
_2      : Char ascii(t0)(t0)(t1)(t1)(t0)(t0)(t1)(t0) // '2'
_3      : Char ascii(t0)(t0)(t1)(t1)(t0)(t0)(t1)(t1) // '3'
_4      : Char ascii(t0)(t0)(t1)(t1)(t0)(t1)(t0)(t0) // '4'
_5      : Char ascii(t0)(t0)(t1)(t1)(t0)(t1)(t0)(t1) // '5'
_6      : Char ascii(t0)(t0)(t1)(t1)(t0)(t1)(t1)(t0) // '6'
_7      : Char ascii(t0)(t0)(t1)(t1)(t0)(t1)(t1)(t1) // '7'
_8      : Char ascii(t0)(t0)(t1)(t1)(t1)(t0)(t0)(t0) // '8'
_9      : Char ascii(t0)(t0)(t1)(t1)(t1)(t0)(t0)(t1) // '9'
_colon  : Char ascii(t0)(t0)(t1)(t1)(t1)(t0)(t1)(t0) // ':'
_semi   : Char ascii(t0)(t0)(t1)(t1)(t1)(t0)(t1)(t1) // ';'
_lt     : Char ascii(t0)(t0)(t1)(t1)(t1)(t1)(t0)(t0) // '<'
_equals : Char ascii(t0)(t0)(t1)(t1)(t1)(t1)(t0)(t1) // '='
_gt     : Char ascii(t0)(t0)(t1)(t1)(t1)(t1)(t1)(t0) // '>'
_quest  : Char ascii(t0)(t0)(t1)(t1)(t1)(t1)(t1)(t1) // '?'
_commat : Char ascii(t0)(t1)(t0)(t0)(t0)(t0)(t0)(t0) // '@'
_A      : Char ascii(t0)(t1)(t0)(t0)(t0)(t0)(t0)(t1) // 'A'
_B      : Char ascii(t0)(t1)(t0)(t0)(t0)(t0)(t1)(t0) // 'B'
_C      : Char ascii(t0)(t1)(t0)(t0)(t0)(t0)(t1)(t1) // 'C'
_D      : Char ascii(t0)(t1)(t0)(t0)(t0)(t1)(t0)(t0) // 'D'
_E      : Char ascii(t0)(t1)(t0)(t0)(t0)(t1)(t0)(t1) // 'E'
_F      : Char ascii(t0)(t1)(t0)(t0)(t0)(t1)(t1)(t0) // 'F'
_G      : Char ascii(t0)(t1)(t0)(t0)(t0)(t1)(t1)(t1) // 'G'
_H      : Char ascii(t0)(t1)(t0)(t0)(t1)(t0)(t0)(t0) // 'H'
_I      : Char ascii(t0)(t1)(t0)(t0)(t1)(t0)(t0)(t1) // 'I'
_J      : Char ascii(t0)(t1)(t0)(t0)(t1)(t0)(t1)(t0) // 'J'
_K      : Char ascii(t0)(t1)(t0)(t0)(t1)(t0)(t1)(t1) // 'K'
_L      : Char ascii(t0)(t1)(t0)(t0)(t1)(t1)(t0)(t0) // 'L'
_M      : Char ascii(t0)(t1)(t0)(t0)(t1)(t1)(t0)(t1) // 'M'
_N      : Char ascii(t0)(t1)(t0)(t0)(t1)(t1)(t1)(t0) // 'N'
_O      : Char ascii(t0)(t1)(t0)(t0)(t1)(t1)(t1)(t1) // 'O'
_P      : Char ascii(t0)(t1)(t0)(t1)(t0)(t0)(t0)(t0) // 'P'
_Q      : Char ascii(t0)(t1)(t0)(t1)(t0)(t0)(t0)(t1) // 'Q'
_R      : Char ascii(t0)(t1)(t0)(t1)(t0)(t0)(t1)(t0) // 'R'
_S      : Char ascii(t0)(t1)(t0)(t1)(t0)(t0)(t1)(t1) // 'S'
_T      : Char ascii(t0)(t1)(t0)(t1)(t0)(t1)(t0)(t0) // 'T'
_U      : Char ascii(t0)(t1)(t0)(t1)(t0)(t1)(t0)(t1) // 'U'
_V      : Char ascii(t0)(t1)(t0)(t1)(t0)(t1)(t1)(t0) // 'V'
_W      : Char ascii(t0)(t1)(t0)(t1)(t0)(t1)(t1)(t1) // 'W'
_X      : Char ascii(t0)(t1)(t0)(t1)(t1)(t0)(t0)(t0) // 'X'
_Y      : Char ascii(t0)(t1)(t0)(t1)(t1)(t0)(t0)(t1) // 'Y'
_Z      : Char ascii(t0)(t1)(t0)(t1)(t1)(t0)(t1)(t0) // 'Z'
_lbrack : Char ascii(t0)(t1)(t0)(t1)(t1)(t0)(t1)(t1) // '['
_bsol   : Char ascii(t0)(t1)(t0)(t1)(t1)(t1)(t0)(t0) // '\\'
_rbrack : Char ascii(t0)(t1)(t0)(t1)(t1)(t1)(t0)(t1) // ']'
_caret  : Char ascii(t0)(t1)(t0)(t1)(t1)(t1)(t1)(t0) // '^'
_lowbar : Char ascii(t0)(t1)(t0)(t1)(t1)(t1)(t1)(t1) // '_'
_grave  : Char ascii(t0)(t1)(t1)(t0)(t0)(t0)(t0)(t0) // '`'
_a      : Char ascii(t0)(t1)(t1)(t0)(t0)(t0)(t0)(t1) // 'a'
_b      : Char ascii(t0)(t1)(t1)(t0)(t0)(t0)(t1)(t0) // 'b'
_c      : Char ascii(t0)(t1)(t1)(t0)(t0)(t0)(t1)(t1) // 'c'
_d      : Char ascii(t0)(t1)(t1)(t0)(t0)(t1)(t0)(t0) // 'd'
_e      : Char ascii(t0)(t1)(t1)(t0)(t0)(t1)(t0)(t1) // 'e'
_f      : Char ascii(t0)(t1)(t1)(t0)(t0)(t1)(t1)(t0) // 'f'
_g      : Char ascii(t0)(t1)(t1)(t0)(t0)(t1)(t1)(t1) // 'g'
_h      : Char ascii(t0)(t1)(t1)(t0)(t1)(t0)(t0)(t0) // 'h'
_i      : Char ascii(t0)(t1)(t1)(t0)(t1)(t0)(t0)(t1) // 'i'
_j      : Char ascii(t0)(t1)(t1)(t0)(t1)(t0)(t1)(t0) // 'j'
_k      : Char ascii(t0)(t1)(t1)(t0)(t1)(t0)(t1)(t1) // 'k'
_l      : Char ascii(t0)(t1)(t1)(t0)(t1)(t1)(t0)(t0) // 'l'
_m      : Char ascii(t0)(t1)(t1)(t0)(t1)(t1)(t0)(t1) // 'm'
_n      : Char ascii(t0)(t1)(t1)(t0)(t1)(t1)(t1)(t0) // 'n'
_o      : Char ascii(t0)(t1)(t1)(t0)(t1)(t1)(t1)(t1) // 'o'
_p      : Char ascii(t0)(t1)(t1)(t1)(t0)(t0)(t0)(t0) // 'p'
_q      : Char ascii(t0)(t1)(t1)(t1)(t0)(t0)(t0)(t1) // 'q'
_r      : Char ascii(t0)(t1)(t1)(t1)(t0)(t0)(t1)(t0) // 'r'
_s      : Char ascii(t0)(t1)(t1)(t1)(t0)(t0)(t1)(t1) // 's'
_t      : Char ascii(t0)(t1)(t1)(t1)(t0)(t1)(t0)(t0) // 't'
_u      : Char ascii(t0)(t1)(t1)(t1)(t0)(t1)(t0)(t1) // 'u'
_v      : Char ascii(t0)(t1)(t1)(t1)(t0)(t1)(t1)(t0) // 'v'
_w      : Char ascii(t0)(t1)(t1)(t1)(t0)(t1)(t1)(t1) // 'w'
_x      : Char ascii(t0)(t1)(t1)(t1)(t1)(t0)(t0)(t0) // 'x'
_y      : Char ascii(t0)(t1)(t1)(t1)(t1)(t0)(t0)(t1) // 'y'
_z      : Char ascii(t0)(t1)(t1)(t1)(t1)(t0)(t1)(t0) // 'z'
_lbrace : Char ascii(t0)(t1)(t1)(t1)(t1)(t0)(t1)(t1) // '<'
_vert   : Char ascii(t0)(t1)(t1)(t1)(t1)(t1)(t0)(t0) // '|'
_rbrace : Char ascii(t0)(t1)(t1)(t1)(t1)(t1)(t0)(t1) // '>'
_tilde  : Char ascii(t0)(t1)(t1)(t1)(t1)(t1)(t1)(t0) // '~'
_DEL    : Char ascii(t0)(t1)(t1)(t1)(t1)(t1)(t1)(t1) // \DEL

// String
// ======

String: Type
  List(Char)

string_eql: String -> String -> Bool
  (a) (b)
  let eql_len = nat_eql(list_len<Char>(a))(list_len<Char>(b))
  let eql_val = all_satisfy<Bool>((x) x)(zip_with<Char><Char><Bool>(u32_eql)(a)(b))
  and(eql_len)(eql_val)

ext: Char -> String -> String
  (c) (str) cons<Char>(c)(str)

end: String
  nil<Char>

exts: String -> List(String) -> List(String)
  (s) (strs) cons<String>(s)(strs)

ends: List(String)
  nil<String>

str: Char -> String
  (c) single<Char>(c)

strs: String -> List(String)
  (s) single<String>(s)

cat: String -> String -> String
  concat<Char>

cat_list: List(String) -> String
  flatten<Char>

// Term
// ====

Term: Type
  self<P: Term -> Type> ->
  (var:
    (hash: U32) ->
    (indx: Nat) ->
    P(var(indx))) ->
  (ref:
    (hash: U32) ->
    (name: String) ->
    P(ref(name))) ->
  (typ:
    (hash: U32) ->
    P(typ)) ->
  (all:
    (hash: U32) ->
    (eras: Bool) ->
    (self: String) ->
    (name: String) ->
    (bind: Term) ->
    (body: Term) ->
    P(all(eras)(self)(name)(bind)(body))) ->
  (lam:
    (hash: U32) ->
    (eras: Bool) ->
    (name: String) ->
    (body: Term) ->
    P(lam(eras)(name)(body))) ->
  (app:
    (hash: U32) ->
    (eras: Bool) ->
    (func: Term) ->
    (argm: Term) ->
    P(app(eras)(func)(argm))) ->
  (lit:
    (hash: U32) ->
    (name: String) ->
    (expr: Term) ->
    (body: Term) ->
    P(lit(name)(expr)(body))) ->
  (ann:
    (hash: U32) ->
    (done: Bool) ->
    (expr: Term) ->
    (type: Term) ->
    P(ann(done)(expr)(type))) ->
  P(self)

var: Nat -> Term
  (indx)
  <> (var) () () () () () () ()
  var(u32_0)(indx)

ref: String -> Term
  (name)
  <> () (ref) () () () () () ()
  ref(u32_0)(name)

typ: Term
  <> () () (typ) () () () () ()
  typ(u32_0)

all: Bool -> String -> String -> Term -> Term -> Term
  (eras) (self) (name) (bind) (body)
  <> () () () (all) () () () ()
  all(u32_0)(eras)(self)(name)(bind)(body)

lam: Bool -> String -> Term -> Term
  (eras) (name) (body)
  <> () () () () (lam) () () ()
  lam(u32_0)(eras)(name)(body)

app: Bool -> Term -> Term -> Term
  (eras) (func) (argm)
  <> () () () () () (app) () ()
  app(u32_0)(eras)(func)(argm)

lit: String -> Term -> Term -> Term
  (name) (expr) (body)
  <> () () () () () () (lit) ()
  lit(u32_0)(name)(expr)(body)

ann: Bool -> Term -> Term -> Term
  (done) (expr) (type)
  <> () () () () () () () (ann)
  ann(u32_0)(done)(expr)(type)

// Parsing
// =======

Parsed : (A: Type) -> Type
  (A) Maybe(Pair(String)(A))

parsed: <A: Type> -> String -> A -> Parsed(A)
  <A> (code) (val)
  some<Pair(String)(A)>(pair<String><A>(code)(val))

noparse: <A: Type> -> Parsed(A)
  <A> none<Pair(String)(A)>

parsing
  : <A: Type> ->
    <B: Type> ->
    (x: Parsed(A)) ->
    (f: String -> A -> Parsed(B)) ->
    Parsed(B)
  <A> <B> (x) (f)
  let _none = noparse<B>
  let _some = (value) value<() Parsed(B)>(f)
  x<() Parsed(B)>(_none)(_some)

LPAR: String str(_lpar)                                      // "("
RPAR: String str(_rpar  )                                    // ")"
LSIG: String str(_lbrace)                                    // "<"
RSIG: String str(_rbrace)                                    // ">"
DASH: String str(_dash)                                      // "-"
PIPE: String str(_vert)                                      // "|"
COLO: String str(_colon)                                     // ":"
SEMI: String str(_semi)                                      // ";"
COLS: String ext(_colon)(str(_colon))                        // "::"
ARR0: String ext(_dash)(str(_gt))                            // "->"
EQLS: String str(_equals)                                    // "="
TYPS: String ext(_T)(ext(_y)(ext(_p)(single<Char>(_e))))     // Type
LETS: String ext(_l)(ext(_e)(ext(_t)(single<Char>(_space)))) // "let "
SPAC: String str(_space)                                     // " "
OPEN: Pair(String)(String) pair<String><String>(LPAR)(LSIG)  // ["(","<"]
CLOS: Pair(String)(String) pair<String><String>(RPAR)(RSIG)  // [")",">"]

is_space: Char -> Bool
  (c)
    let is_spc = word_eql<n32>(c)(_space)
    let is_tab = word_eql<n32>(c)(_HT)
    let is_lin = word_eql<n32>(c)(_LF)
    or(is_spc)(or(is_tab)(is_lin))

is_name: Char -> Bool
  (c)
    let is_num = and(word_gte<n32>(c)(_0))(word_lte<n32>(c)(_9))
    let is_low = and(word_gte<n32>(c)(_a))(word_lte<n32>(c)(_z))
    let is_upp = and(word_gte<n32>(c)(_A))(word_lte<n32>(c)(_Z))
    let is_und = word_eql<n32>(c)(_lowbar)
    or(is_num)(or(is_low)(or(is_upp)(is_und)))

first_valid: <A: Type> -> List(Maybe(A)) -> Maybe(A)
  <A> (list)
  list<() Maybe(A)>
  | none<A>;
  | (head) (tail)
    head<() Maybe(A)>
    | first_valid<A>(tail);
    | (value) some<A>(value);;

drop_while: (Char -> Bool) -> String -> String
  (cond) (code)
  code<() String>
  | nil<Char>;
  | (head) (tail)
    cond(head)<() String>
    | drop_while(cond)(tail);
    | cons<Char>(head)(tail);;

drop_spaces: String -> String
  drop_while(is_space)

// TODO: /* multi-line comment */
drop_comment: String -> String
  (code)
  let code = drop_spaces(code)
  // Removes "// ... \n"
  let code = 
    let fst2 = take<Char>(n2)(code)
    let sla2 = ext(_sol)(ext(_sol)(end))
    string_eql(fst2)(sla2)<() String>
    | let code = drop<Char>(n2)(code)
      let code = drop_while((x) not(u32_eql(_LF)(x)))(code)
      code;
    | code;
  code

// TODO: remove comments
next: String -> String
  (code) drop_spaces(code)

parse_str: String -> String -> Parsed(String)
  (code) (str)
  str<() Parsed(String)>
  | parsed<String>(code)(str);
  | (str_head) (str_tail)
    code<() Parsed(String)>
    | noparse<String>;
    | (code_head) (code_tail)
      u32_eql(code_head)(str_head)<() Parsed(String)>
      | parse_str(code_tail)(str_tail);
      | noparse<String>;;;

parse_opt: String -> Pair(String)(String) -> Parsed(Bool)
  (code) (opts)
  opts<() Parsed(Bool)>
  | (ch0) (ch1)
    parse_str(ch0)(code)<() Parsed(Bool)>
    | parse_str(ch1)(code)<() Parsed(Bool)>
      | noparse<Bool>;
      | (got) got<() Parsed(Bool)>((code) (skip) parsed<Bool>(code)(true));;
    | (got) got<() Parsed(Bool)>((code) (skip) parsed<Bool>(code)(false));;

parse_nam_aux: String -> Pair(String)(String)
  (code)
  let Ret = Pair(String)(String)
  let ret = pair<String><String>
  code<() Ret>
  | ret(code)(end);
  | (head) (tail)
    is_name(head)<() Ret>
    | let _pair = (code) (rest) ret(code)(ext(head)(rest))
      parse_nam_aux(tail)<() Ret>(_pair);
    | ret(code)(end);;

parse_nam: String -> Bool -> Maybe(Pair(String)(String))
  (code) (allow_empty)
  parse_nam_aux(code)<() Parsed(String)>
  | (code) (name)
    or(allow_empty)(not(is_empty<Char>(name)))<() Parsed(String)>
    | parsed<String>(code)(name);
    | noparse<String>;;

// Stringification
// ===============

nest : Bool -> String -> String
  (b) (s)
  b<() String>
  | cat(LSIG)(cat(s)(RSIG));
  | cat(LPAR)(cat(s)(RPAR));

sp : String -> String
  (s) cat_list(exts(SPAC)(exts(s)(strs(SPAC))))

ERR : String
  ext(_hash)(ext(_E)(ext(_R)(str(_R))))

stringify_trm_go : List(String) -> Term -> String
  (vs) (term)
  let go = stringify_trm_go
  term<() String>
  |-var- () (indx)
    let res = find<String>(vs)(() (i) nat_eql(indx)(i))
    res<() String>(ERR)((x) fst<String><Nat>(x));
  |-ref- () (nam) nam;
  |-typ- () TYPS;
  |-all- () (e) (s) (n) (h) (b)
    let body = go(exts(n)(vs))(b)
    let head = nest(e)(cat_list(exts(n)(exts(sp(COLO))(strs(go(vs)(h))))))
    cat_list(exts(s)(exts(head)(exts(sp(ARR0))(strs(body)))));
  |-lam- () (e) (n) (b)
    let head = nest(e)(n)
    let body = go(exts(n)(vs))(b)
    cat_list(exts(head)(strs(body)));
  |-app- () (e) (f) (a)
    let func = nest(false)(go(vs)(f))
    let argm = nest(e)(go(vs)(a))
    cat_list(exts(func)(strs(argm)));
  |-lit- () (n) (x) (b)
    cat_list(exts(LETS)(exts(n)(exts(sp(EQLS))(strs(go(exts(n)(vs))(b))))));
  |-ann- () () (x) (t)
    cat_list(exts(go(vs)(x))(exts(sp(COLS))(strs(go(vs)(t)))));

stringify_trm : Term -> String
  (t) stringify_trm_go(nil<String>)(t)

// Parsing
// =======

parse_par: String -> List(String) -> Parsed(Term)
  (code) (vars)
  parsing<String><Term>(parse_str(next(code))(LPAR)) | (code) (skip)
  parsing<Term  ><Term>(parse_trm(next(code))(vars)) | (code) (term)
  parsing<String><Term>(parse_str(next(code))(RPAR)) | (code) (skip)
  parsed<Term>(code)(term);;;

parse_com: String -> List(String) -> Parsed(Term)
  (code) (vars)
  parsing<String><Term>(parse_str(next(code))(DASH))  | (code) (skip)
  parsing<String><Term>(parse_nam(     code )(false)) | (code) (name)
  parsing<String><Term>(parse_str(next(code))(DASH))  | (code) (skip)
  parsing<Term  ><Term>(parse_trm(next(code))(vars))  | (code) (term)
  parsed<Term>(code)(term);;;;

parse_all: String -> List(String) -> Parsed(Term)
  (code) (vars)
  parsing<String><Term>(parse_nam(next(code))(true)) | (code) (self)
  parsing<Bool  ><Term>(parse_opt(     code )(OPEN)) | (code) (eras)
  parsing<String><Term>(parse_nam(next(code))(true)) | (code) (name)
  parsing<String><Term>(parse_str(next(code))(COLO)) | (code) (skip)
  let vars = cons<String>(self)(vars)
  parsing<Term  ><Term>(parse_trm(next(code))(vars)) | (code) (bind)
  parsing<Bool  ><Term>(parse_opt(next(code))(CLOS)) | (code) (skip)
  parsing<String><Term>(parse_str(next(code))(ARR0)) | (code) (skip)
  let vars = cons<String>(name)(vars)
  parsing<Term  ><Term>(parse_trm(next(code))(vars)) | (code) (body)
  parsed<Term>(code)(all(eras)(self)(name)(bind)(body));;;;;;;;

parse_lam: String -> List(String) -> Parsed(Term)
  (code) (vars)
  parsing<Bool  ><Term>(parse_opt(next(code))(OPEN)) | (code) (eras)
  parsing<String><Term>(parse_nam(next(code))(true)) | (code) (name)
  parsing<Bool  ><Term>(parse_opt(next(code))(CLOS)) | (code) (skip)
  let vars = cons<String>(name)(vars)
  parsing<Term  ><Term>(parse_trm(next(code))(vars)) | (code) (body)
  parsed<Term>(code)(lam(eras)(name)(body));;;;

parse_let: String -> List(String) -> Parsed(Term)
  (code) (vars)
  parsing<String><Term>(parse_str(next(code))(LETS))  | (code) (skip)
  parsing<String><Term>(parse_nam(next(code))(false)) | (code) (name)
  parsing<String><Term>(parse_str(next(code))(EQLS))  | (code) (skip)
  parsing<Term  ><Term>(parse_trm(next(code))(vars))  | (code) (expr)
  let vars = cons<String>(name)(vars)
  parsing<Term  ><Term>(parse_trm(next(code))(vars))  | (code) (body)
  parsed<Term>(code)(lit(name)(expr)(body));;;;;

parse_typ: String -> List(String) -> Parsed(Term)
  (code) (vars)
  parsing<String><Term>(parse_str(next(code))(TYPS)) | (code) (skip)
  parsed<Term>(code)(typ);

parse_var: String -> List(String) -> Parsed(Term)
  (code) (vars)
  parsing<String><Term>(parse_nam(next(code))(false)) | (code) (name)
  find<String>(vars)((x) (i) string_eql(x)(name))<() Parsed(Term)>
  | parsed<Term>(code)(ref(name));
  | (value) parsed<Term>(code)(var(snd<String><Nat>(value)));;

parse_app: String -> Term -> List(String) -> Parsed(Term)
  (code) (func) (vars)
  parsing<Bool><Term>(parse_opt(next(code))(OPEN)) | (code) (eras)
  parsing<Term><Term>(parse_trm(next(code))(vars)) | (code) (argm)
  parsing<Bool><Term>(parse_opt(next(code))(CLOS)) | (code) (skip)
  parsed<Term>(code)(app(eras)(func)(argm));;;

parse_pip: String -> Term -> List(String) -> Parsed(Term)
  (code) (func) (vars)
  parsing<String><Term>(parse_str(next(code))(PIPE)) | (code) (skip)
  parsing<Term  ><Term>(parse_trm(next(code))(vars)) | (code) (argm)
  parsing<String><Term>(parse_str(next(code))(SEMI)) | (code) (skip)
  parsed<Term>(code)(app(false)(func)(argm));;;

parse_arr: String -> Term -> List(String) -> Parsed(Term)
  (code) (bind) (vars)
  parsing<String><Term>(parse_str(next(code))(ARR0)) | (code) (skip)
  let vars = cons<String>(nil<Char>)(cons<String>(nil<Char>)(vars))
  parsing<Term  ><Term>(parse_trm(next(code))(vars)) | (code) (body)
  let term = all(false)(nil<Char>)(nil<Char>)(shift(bind)(n1)(n0))(body)
  parsed<Term>(code)(term);;

parse_ann: String -> Term -> List(String) -> Parsed(Term)
  (code) (expr) (vars)
  parsing<String><Term>(parse_str(next(code))(COLS)) | (code) (skip)
  parsing<Term  ><Term>(parse_trm(next(code))(vars)) | (code) (type)
  parsed<Term>(code)(ann(false)(expr)(type));;

parse_pst: String -> Term -> List(String) -> Parsed(Term)
  (code) (term) (vars)
  let post_parse = first_valid<Pair(String)(Term)>(
    cons<Parsed(Term)>(parse_app(code)(term)(vars))(
    cons<Parsed(Term)>(parse_pip(code)(term)(vars))(
    cons<Parsed(Term)>(parse_arr(code)(term)(vars))(
    cons<Parsed(Term)>(parse_ann(code)(term)(vars))(
    nil<Parsed(Term)>)))))
  post_parse<() Parsed(Term)>
  | parsed<Term>(code)(term);
  | (value)
    value<() Parsed(Term)>
    | (code) (term) parse_pst(code)(term)(vars);;

parse_trm: String -> List(String) -> Parsed(Term)
  (code) (vars)
  let base_parse = first_valid<Pair(String)(Term)>(
    cons<Parsed(Term)>(parse_all(code)(vars))(
    cons<Parsed(Term)>(parse_lam(code)(vars))(
    cons<Parsed(Term)>(parse_let(code)(vars))(
    cons<Parsed(Term)>(parse_par(code)(vars))(
    cons<Parsed(Term)>(parse_com(code)(vars))(
    cons<Parsed(Term)>(parse_typ(code)(vars))(
    cons<Parsed(Term)>(parse_var(code)(vars))(
    nil<Parsed(Term)>))))))))
  parsing<Term><Term>(base_parse)((code) (term)
    parse_pst(code)(term)(vars))

// Substitution
// ============

shift: Term -> Nat -> Nat -> Term
  (term) (inc) (dep)
  term<() Term>
  | (hash) (indx)
    nat_ltn(indx)(dep)<() Term>
    | var(indx);
    | var(add(inc)(indx));;
  | (hash) (name)
    ref(name);
  | (hash)
    typ;
  | (hash) (eras) (self) (name) (bind) (body)
    let eras = eras
    let self = self
    let name = name
    let bind = shift(bind)(inc)(succ(dep))
    let body = shift(body)(inc)(succ(succ(dep)))
    all(eras)(self)(name)(bind)(body);
  | (hash) (eras) (name) (body)
    let eras = eras
    let name = name
    let body = shift(body)(inc)(succ(dep))
    lam(eras)(name)(body);
  | (hash) (eras) (func) (argm)
    let eras = eras
    let func = shift(func)(inc)(dep)
    let argm = shift(argm)(inc)(dep)
    app(eras)(func)(argm);
  | (hash) (name) (expr) (body)
    let name = name
    let expr = shift(expr)(inc)(dep)
    let body = shift(expr)(inc)(succ(dep))
    lit(name)(expr)(body);
  | (hash) (done) (expr) (type)
    let done = done
    let expr = shift(expr)(inc)(dep)
    let type = shift(expr)(inc)(dep)
    ann(done)(expr)(type);

subst: Term -> Term -> Nat -> Term
  (term) (val) (dep)
  term<() Term>
  | (hash) (indx)
    nat_cmp(indx)(dep)<() Term>
    | var(indx);
    | val;
    | var(pred(indx));;
  | (hash) (name)
    ref(name);
  | (hash)
    typ;
  | (hash) (eras) (self) (name) (bind) (body)
    let eras = eras
    let self = self
    let name = name
    let bind = subst(bind)(shift(val)(n1)(n0))(succ(dep))
    let body = subst(body)(shift(val)(n2)(n0))(succ(succ(dep)))
    all(eras)(self)(name)(bind)(body);
  | (hash) (eras) (name) (body)
    let eras = eras
    let name = name
    let body = subst(body)(shift(val)(n1)(n0))(succ(dep))
    lam(eras)(name)(body);
  | (hash) (eras) (func) (argm)
    let eras = eras
    let func = subst(func)(val)(dep)
    let argm = subst(argm)(val)(dep)
    app(eras)(func)(argm);
  | (hash) (name) (expr) (body)
    let name = name
    let expr = subst(expr)(val)(dep)
    let body = subst(expr)(shift(val)(n1)(n0))(succ(dep))
    lit(name)(expr)(body);
  | (hash) (done) (expr) (type)
    let done = done
    let expr = subst(expr)(val)(dep)
    let type = subst(expr)(val)(dep)
    ann(done)(expr)(type);

// Evaluation
// ==========

HTerm: Type
  self<P: HTerm -> Type> ->
  (hvar:
    (indx: Nat) ->
    (posi: Bool) ->
    P(hvar(indx)(posi))) ->
  (href:
    (name: String) ->
    P(href(name))) ->
  (htyp:
    P(htyp)) ->
  (hall:
    (eras: Bool) ->
    (bind: HTerm -> HTerm) ->
    (body: HTerm -> HTerm -> HTerm) ->
    P(hall(eras)(bind)(body))) ->
  (hlam:
    (body: HTerm -> HTerm) ->
    P(hlam(body))) ->
  (happ:
    (func: HTerm) ->
    (argm: HTerm) ->
    P(happ(func)(argm))) ->
  (hlit:
    (expr: HTerm) ->
    (body: HTerm -> HTerm) ->
    P(hlit(expr)(body))) ->
  P(self)

hvar: Nat -> Bool -> HTerm
  (indx) (posi)
  <> (hvar) () () () () () ()
  hvar(indx)(posi)

href: String -> HTerm
  (name)
  <> () (href) () () () () ()
  href(name)

htyp: HTerm
  <> () () (htyp) () () () ()
  htyp

hall: Bool -> (HTerm -> HTerm) -> (HTerm -> HTerm -> HTerm) -> HTerm
  (eras) (bind) (body)
  <> () () () (hall) () () ()
  hall(eras)(bind)(body)

hlam: (HTerm -> HTerm) -> HTerm
  (body)
  <> () () () () (hlam) () ()
  hlam(body)

happ: HTerm -> HTerm -> HTerm
  (func) (argm)
  <> () () () () () (happ) ()
  happ(func)(argm)

hlit: HTerm -> (HTerm -> HTerm) -> HTerm
  (expr) (body)
  <> () () () () () () (hlit)
  hlit(expr)(body)

to_high_order: Term -> List(HTerm) -> Nat -> HTerm
  (term) (vars) (depth)
  term<() HTerm>
  | (hash) (indx)
    find<HTerm>(vars)((x) (i) nat_eql(i)(indx))<() HTerm>
    | hvar(sub(succ(indx))(depth))(false);
    | (value) fst<HTerm><Nat>(value);;
  | (hash) (name)
    href(name);
  | (hash)
    htyp;
  | (hash) (eras) (self) (name) (bind) (body)
    let eras = eras
    let bind = (s) to_high_order(bind)(cons<HTerm>(s)(vars))(succ(depth))
    let body = (s) (x) to_high_order(body)(cons<HTerm>(x)(cons<HTerm>(s)(vars)))(succ(succ(depth)))
    hall(eras)(bind)(body);
  | (hash) (eras) (name) (body)
    eras<() HTerm>
    | let body = subst(body)(ref(nil<Char>))(n0)
      to_high_order(body)(vars)(depth);
    | let body = (x) to_high_order(body)(cons<HTerm>(x)(vars))(succ(depth))
      hlam(body);;
  | (hash) (eras) (func) (argm)
    eras<() HTerm>
    | to_high_order(func)(vars)(depth);
    | let func = to_high_order(func)(vars)(depth)
      let argm = to_high_order(argm)(vars)(depth)
      happ(func)(argm);;
  | (hash) (name) (expr) (body)
    let expr = to_high_order(expr)(vars)(depth)
    let body = (x) to_high_order(body)(cons<HTerm>(x)(vars))(succ(depth))
    hlit(expr)(body);
  | (hash) (done) (expr) (type)
    to_high_order(expr)(vars)(depth);

to_low_order: HTerm -> Nat -> Term
  (hterm) (depth)
  hterm<() Term>
  | (indx) (posi)
    posi<() Term>
    | var(sub(sub(depth)(indx))(n1));
    | var(sub(add(depth)(indx))(n1));;
  | (name)
    ref(name);
  | typ;
  | (eras) (bind) (body)
    let eras = eras
    let self = nil<Char> // TODO
    let name = nil<Char> // TODO
    let bind = to_low_order(bind(hvar(depth)(true)))(succ(depth))
    let body = to_low_order(body(hvar(depth)(true))(hvar(succ(depth))(true)))(succ(succ(depth)))
    all(eras)(self)(name)(bind)(body);
  | (body)
    let eras = false
    let name = nil<Char> // TODO
    let body = to_low_order(body(hvar(depth)(true)))(succ(depth))
    lam(eras)(name)(body);
  | (func) (argm)
    let eras = false
    let func = to_low_order(func)(depth)
    let argm = to_low_order(argm)(depth)
    app(eras)(func)(argm);
  | (expr) (body)
    let name = nil<Char> // TODO
    let expr = to_low_order(expr)(depth)
    let body = to_low_order(body(hvar(depth)(true)))(succ(depth))
    lit(name)(expr)(body);

// Main
// ====

example_0: Word(n4)
  let w0011 = w1<n3>(w1<n2>(w0<n1>(w0<n0>(we))))
  let w0101 = w1<n3>(w0<n2>(w1<n1>(w0<n0>(we))))
  word_add<n4>(w0011)(w0101) // 3 + 5 == 8

main: String -> String
  (code)
  parse_trm(code)(nil<String>)<() String>
  | nil<Char>;
  | (parsed) parsed<() String>((code) (term) stringify_trm(term));
