// Renders App
App.GG.draw(img: VoxBox): App.Draw<App.GG.State>
  (state)
  let local = state@local
  <div style={
    "height": "max(100%, 600px)"
    "width": "100vw"
    "display": "flex",
    "align-items": "center",
    "justify-content": "center"
  }>
    <div style={
        "max-height": "100%",
        "max-width": "100%",
        "overflow": "hidden",
      }>{
        DOM.vbox({
            "class": "pixel-art" 
            "id": "game_screen",
            "width": "1024px",
            "height": "1024px",
            "scale": "4"
          },
          {},
          let bar = case local@phase as phase {setup: 0#64, game: phase.turn_bar} 
          let img = App.GG.draw.grid(local@grid, img)
          let img = App.GG.draw.turn_bar(bar, img)
          App.GG.draw.setup(local@phase,img))
      }</div>
  </div>

App.GG.draw.setup(phase: App.GG.Phase, img: VoxBox): VoxBox
  case phase {
    setup: 
      let img = VoxBox.Draw.image(15 - 96, 13 - 66, 150, App.GG.img.background, img)
      let {x, y}   = App.GG.Constants.chips_starting_position
      let selected = App.GG.Table.Slot.get_selected_index(phase.table)
      let img = App.GG.draw.setup.chips(0, phase.table@slots, selected, x, y, img)
      let img = VoxBox.Draw.text(I32.show(phase.energy), PixelFont.black, Pos32.new(93,80,200), img)
      let bar = I32.to_u32((phase.energy * 64) / 100)
      let img = VoxBox.Draw.rect(93, 80 - bar, 100, 11, bar, Col32.new(240, 220, 0, 255), img)
      img
    game: img
  }
//40x22
App.GG.draw.turn_bar(turn_bar: U64, img: VoxBox): VoxBox
  let max = U32.min(F64.to_u32(U64.to_f64(turn_bar)), 1200)
  VoxBox.Draw.rect(21, 15, 100, max / 6, 4, Col32.new(100, 255, 100, 255), img)

App.GG.draw.setup.chips(
  count: U32, 
  slots: List<App.GG.Table.Slot>, 
  selected: Maybe<U32>,
  x: U32, 
  y: U32, 
  img: VoxBox
): VoxBox
  case slots {
    nil : img
    cons:
      // get constants
      let {cx, cy} = App.GG.Constants.chip_size
      let {vx, vy} = App.GG.Constants.chips_space_between
      let max_stack = App.GG.Constants.chips_array@snd
      // calculate x and y
      let {x, y} = 
        if ((count + 1) % (max_stack + 1)) =? 0 then 
          {x + (cx + vx), y - ((cy + vy) * max_stack)} 
        else 
          {x, y} 
      let {tx, ty} = {(x + 2) - (App.GG.Constants.chip_size@fst / 2), (y + 4) - (App.GG.Constants.chip_size@snd / 2)}

      // draw user selection if chip is selected
      let img = App.GG.draw.setup.chips.selected_chip(
        x, y, count, selected, img
      )
      // draw chips
      let {tx, ty} = {(x + 2) - (App.GG.Constants.chip_size@fst / 2), (y + 4) - (App.GG.Constants.chip_size@snd / 2)} // get text position
      let img = Maybe {
        get chip = slots.head@chip
        let img = VoxBox.Draw.image_colorize(x - 128, y - 128, 200, Col32.new_hue(App.GG.Class.to_hue(chip@class)) App.GG.img.back_w_outline_brighter, img)
        // let img = VoxBox.Draw.image(x - 128, y - 128, 200, chip@img, img)
        let img = VoxBox.Draw.text(chip@name, PixelFont.black, Pos32.new(tx,ty,200), img)
        return img
      } <> img
      // recursion
      App.GG.draw.setup.chips(count + 1, slots.tail, selected, x, y + (cy + vy), img)
  }

      // case table.head@chip as chip {
      //   none: App.GG.draw.setup.chips(count + 1, table.tail, x, y + (cy + vy), img)
      //   some:
      //     let img = VoxBox.Draw.image_colorize(x - 128, y - 128, 200, Col32.new_hue(chip.value@hue) App.GG.img.back_w_outline_brighter, img)
      //     let img = VoxBox.Draw.text(chip.value@name, PixelFont.black, Pos32.new(tx,ty,200), img)


App.GG.draw.setup.chips.selected_chip(
  x: U32
  y: U32
  count: U32
  selected: Maybe<U32>
  img: VoxBox
): VoxBox
  Maybe {
    get selected = selected
    let img = 
      if selected =? count then 
        VoxBox.Draw.image(x - 128, y - 128, 250, App.GG.img.outline_selected, img)
      else 
        img
    return img
  } <> img

// App.GG.draw.setup.chip(chip: App.GG.Chip, x: U32, y: U32, img:VoxBox): VoxBox
//   VoxBox.Draw.image(x, y, 200, chip@img, img)



// Draws the grid
App.GG.draw.grid(
  grid: App.GG.Grid
  img: VoxBox
): VoxBox
  for key:val in grid with img:
    App.GG.draw.tile(key, val, {32,32}, grid, img)
  img

// Draws a tile and its contents
App.GG.draw.tile(
  coord: App.GG.Coord,
  tile: App.GG.Tile,
  tile_size: Pair<U32, U32>,
  grid: App.GG.Grid
  img: VoxBox
): VoxBox
  let {x, y} = App.GG.Coord.to_xy(coord)
  let tile_img = 
    case tile@owner {
      blue:     App.GG.img.ally_tile
      red:      App.GG.img.enemy_tile
      neutral:  App.GG.img.target_tile
    }
  let creature = tile@creature
  let img = 
    VoxBox.Draw.image(x, y, 0, tile_img, img)
  let img =
    case creature {
      none:
        img
      some:
        let f = App.GG.Monster.to_vbox(creature.value@category)
        let sprite = f(creature.value@animation@fst, creature.value@animation@snd)
        //let img = VoxBox.Draw.image_colorize(x, y, 20, Col32.new_hue(F64.to_u32(U64.to_f64((creature.value@animation@snd % 1024) / 4))), sprite, img)
        let img = VoxBox.Draw.image(x, y, 20, sprite, img)
        let img = VoxBox.Draw.text(I32.show(creature.value@hp), PixelFont.small_black, Pos32.new(x + 122,y + 100, 100), img)
        let img = 
          let actions = creature.value@actions
          let current = actions@current
          without current: img
          open current
          let result = current@effect(coord, App.GG.Effect.Origin.creature, grid)
          case result {
            err: img
            new: result.img(img)
          }
        img
    }
  
  let pair = {0, img}
  for projectile in tile@projectiles with pair:
    let {idx, img} = pair
    let origin = App.GG.Effect.Origin.projectile(idx)
    let result = projectile@effect(coord, origin, grid)
    case result {
      err: {idx + 1, img}
      new: {idx + 1, result.img(img)}
    }
  img
