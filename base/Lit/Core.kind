// Litereum: a minimal decentralized computer
// ==========================================

// Types
// -----

// A Litereum term
type Lit.Core.Term {
  // A variable
  var(
    name: String
  )
  // Creates a value
  create(
    type: String
    form: Nat
    vals: List<Lit.Core.Term>
  )
  // Pattern-matches a value
  match(
    type: String
    name: String
    expr: Lit.Core.Term
    cses: List<Pair<List<String>,Lit.Core.Term>>
  )
  // Calls an external program
  call(
    name: String
    func: String
    args: List<Lit.Core.Term>
    cont: Lit.Core.Term
  )
  // Binds an new program
  bind(
    name: String
    main: Lit.Core.Term
    cont: Lit.Core.Term
  )
}

// Lit.Core types are algebraic datatypes (ADTs)
type Lit.Core.Type {
  lab
  eff(
    name: String
  )
  adt(
    name: String
    forms: List<Lit.Core.Type.Form>
  )
}

// A constructor of an ADT
type Lit.Core.Type.Form {
  new(
    name: String
    fields: List<Lit.Core.Type.Field>
  )
}

// A field of an ADT's constructor
type Lit.Core.Type.Field {
  new(
    name: String
    type: String
  )
}

// A user
type Lit.Core.User {
  new(
    name: String
    pkey: String
  )
}

// A function
type Lit.Core.Func {
  new(
    name: String
    ownr: Maybe<String>
    main: Lit.Core.Term
    iarg: List<String>
    ityp: List<String>
    otyp: String
  )
}

// An external call
type Lit.Core.Exec {
  new(
    user: String
    sign: String
    expr: Lit.Core.Term
  )
}

// A paragraph in a Litereum page
type Lit.Core.Line {
  new_type(value: Lit.Core.Type)
  new_func(value: Lit.Core.Func)
  new_user(value: Lit.Core.User)
  ext_exec(value: Lit.Core.Exec)
}

// A page of the Litereum book
Lit.Core.Page: Type
  List<Lit.Core.Line>

// A Lit.Core global entry
type Lit.Core.Entry {
  type(value: Lit.Core.Type)
  func(value: Lit.Core.Func)
  user(value: Lit.Core.User)
}

// Lit.Core's global state
Lit.Core.World: Type
  Map<Lit.Core.Entry>

// Getters and Setters
// -------------------

Lit.Core.World.get_type(name: String, world: Lit.Core.World): Maybe<Lit.Core.Type>
  case world{name} as entry {
    some: case entry.value {
      type: some(entry.value.value)
    } default none
  } default none
  
Lit.Core.World.get_func(name: String, world: Lit.Core.World): Maybe<Lit.Core.Func>
  case world{name} as entry {
    some: case entry.value {
      func: some(entry.value.value)
    } default none
  } default none

Lit.Core.World.get_user(name: String, world: Lit.Core.World): Maybe<Lit.Core.User>
  case world{name} as entry {
    some: case entry.value {
      user: some(entry.value.value)
    } default none
  } default none

Lit.Core.Type.find_form(name: String, type: Lit.Core.Type): Maybe<Pair<Nat,Lit.Core.Type.Form>>
  case type {
    lab: none
    eff: none
    adt: List.ifind!((i,f) String.eql(f@name,name), type.forms)
  }

// Type-Checking
// -------------

Lit.Core.Type.equal(a: Lit.Core.Type, b: Lit.Core.Type): Bool
  case a b {
    lab lab: true
    eff eff: String.eql(a.name, b.name)
    adt adt: String.eql(a.name, b.name)
  } default false

Lit.Core.World.check.term(
  term: Lit.Core.Term
  type: Lit.Core.Type
  ctx: Map<Lit.Core.Type>
  world: Lit.Core.World
): Bool
  //log("- chk " | Lit.Lang.show.term(term,world) | " : " | Lit.Lang.show.type.short(type))
  //log("- ctx " | String.join(", ", List.map!!((a) a@fst|":"|Lit.Lang.show.type.short(a@snd), Map.to_list!(ctx))))
  //log("")
  open world
  case term {
    var:
      let var_type = ctx{term.name} abort false
      //log("-- var " | Lit.Core.Type.show(var_type) | " " | Lit.Core.Type.show(type))
      Lit.Core.Type.equal(var_type, type)
    create: case type {
      lab:
        false
      eff:
        false
      adt:
        use term_type = Lit.Core.World.get_type(term.type,world) abort false
        if Lit.Core.Type.equal(term_type, type) then
          use form = type.forms[term.form] abort false
          Lit.Core.World.check.many(term.vals, List.mapped!(form.fields)!((x) x@type), ctx, world)
        else
          false
    }
    match:
      let expr_type = Lit.Core.World.get_type(term.type,world) abort false
      case expr_type {
        lab:
          false
        eff:
          false
        adt:
          let expr = Lit.Core.World.check.term(term.expr, expr_type, ctx, world)
          let cses = List.mapped!(term.cses)!((x) x@snd)
          let cses = Lit.Core.World.check.match.cases(cses, type, expr_type.forms, term.name, ctx, world)
          expr && cses
      }
    call:
      use func = Lit.Core.World.get_func(term.func,world) abort false
      use otyp = Lit.Core.World.get_type(func.otyp,world) abort false
      let ctx2 = ctx{term.name} <- otyp
      let args = Lit.Core.World.check.many(term.args, func.ityp, ctx, world)
      let cont = Lit.Core.World.check.term(term.cont, otyp, ctx2, world)
      args && cont
    bind:
      // TODO: check access
      use func = Lit.Core.World.get_func(term.name,world) abort false
      use otyp = Lit.Core.World.get_type(func.otyp,world) abort false
      let nofn = List.is_empty!(func.iarg)
      let main = Lit.Core.World.check.term(term.main, otyp, ctx, world)
      nofn && main
  } default false

Lit.Core.World.check.many(
  terms: List<Lit.Core.Term>
  types: List<String>
  ctx: Map<Lit.Core.Type>
  world: Lit.Core.World
): Bool
  open world
  case terms types {
    cons cons:
      let type = Lit.Core.World.get_type(types.head, world) abort false
      let head = Lit.Core.World.check.term(terms.head, type, ctx, world)
      let tail = Lit.Core.World.check.many(terms.tail, types.tail, ctx, world)
      head && tail
    nil nil:
      true
  } default false

Lit.Core.World.check.match.cases(
  cases: List<Lit.Core.Term>
  type: Lit.Core.Type
  forms: List<Lit.Core.Type.Form>
  name: String
  ctx: Map<Lit.Core.Type>
  world: Lit.Core.World
): Bool
  case cases forms {
    cons cons:
      let ext_ctx = ctx
      for field in forms.head@fields with ext_ctx:
        let type = Lit.Core.World.get_type(field@type, world) <> Lit.Core.Type.lab
        ext_ctx{name | "." | field@name} <- type
      let case_ok = Lit.Core.World.check.term(cases.head, type, ext_ctx, world)
      let rest_ok = Lit.Core.World.check.match.cases(cases.tail, type, forms.tail, name, ctx, world)
      case_ok && rest_ok
    nil nil:
      true
  } default false

// Validation
// ----------

// Checks if:
// - no global binders with the same name
// - variables are used at most once
Litereum.Core.World.validate(
  term: Lit.Core.Term
  used: Map<Bool>
): Pair<Map<Bool>,Bool>
  case term {
    var:
      case used{term.name} as was_used {
        none:
          // undefined variable
          {used, false}
        some: 
          if was_used.value then
            // variable already used
            {used, false}
          else
            // first use of the variable
            {used{term.name} <- true, true}
      }
    create:
      let state = {used, true}
      let state = for val in term.vals:
        let {used, res0} = state
        let {used, res1} = Litereum.Core.World.validate(val, used)
        {used, res0 && res1}
      state
    match:
      let state = Litereum.Core.World.validate(term.expr, used)
      let state = for cse in term.cses:
        let {fields, body} = cse
        let state = for field in fields:
          let {used, resx} = state
          case used{field} as got {
            some: {used, false} // same name used more than once
            none: {used{field} <- false, resx}
          }
        state
      state
    call:
      let state = {used, true}
      let state = for arg in term.args:
        let {used, res0} = state
        let {used, res1} = Litereum.Core.World.validate(arg, used)
        {used, res0 && res1}
      state
    bind:
      let used = used{term.name} <- false
      let {used, res0} = Litereum.Core.World.validate(term.main, used)
      let {used, res1} = Litereum.Core.World.validate(term.cont, used)
      {used, res0 && res1}
  }

// Execution
// ---------

Lit.Core.World.run.page(
  page: Lit.Core.Page
  world: Lit.Core.World
): Maybe<Lit.Core.World>
  case page {
    nil: some(world)
    cons: case Lit.Core.World.run.line(page.head, world) as new_world {
      none: none
      some: Lit.Core.World.run.page(page.tail, new_world.value)
    }
  }


Lit.Core.World.run.line(
  line: Lit.Core.Line
  world: Lit.Core.World
): Maybe<Lit.Core.World>
  case line {
    new_type:
      // TODO: check something?
      let type = line.value
      case type {
        eff:
          none
        lab:
          none
        adt: 
          log("- new_type: " | type.name)
          case world{type.name} as got_type {
            none: some(world{type.name} <- Lit.Core.Entry.type(type))
          } default log("error: type redefinition: " | type.name) none
      }
    new_func:
      use func = line.value
      log("- new_func: " | func.name)
      case world{func.name} as got {
        none:
          let new_world = world{func.name} <- Lit.Core.Entry.func(func)
          let ctx = some({})
          let ctx = for arg in List.zip!!(func.iarg, func.ityp): Maybe {
            let {arg_name, arg_type} = arg
            get ctx = ctx
            get typ = Lit.Core.World.get_type(arg_type, world)
            return ctx{arg_name} <- typ
          }
          case ctx {
            none:
              log("error: func input type undefined: " | func.name) none
            some:
              let otyp = Lit.Core.World.get_type(func.otyp, world) abort log("error: func otyp not found: " | func.name) none
              if Lit.Core.World.check.term(func.main, otyp, ctx.value, new_world) then
                some(new_world)
              else
                log("error: func ill-typed: " | func.name) none
          }
      } default log("error: func redefinition: " | func.name) none
    new_user:
      use user = line.value
      log("- new_user: " | user.name)
      case world{user.name} as got {
        none: some(world{user.name} <- Lit.Core.Entry.user(user))
      } default log("error: user redefinition: " | user.name) none
    ext_exec:
      use exec = line.value
      case world{exec.user} as got_entry {
        some: case got_entry.value as entry {
          user: 
            use user = entry.value
            let {result, world} = Lit.Core.World.run.term(exec.expr, exec.user, world, {})
            log("- ext_exec: " | Lit.Lang.show.term(result, world))
            some(world)
        } default log("error: exec user not a user") none
      } default log("error: exec user undefined") none
  }

Lit.Core.World.run.term(
  term: Lit.Core.Term
  self: String
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
): Pair<Lit.Core.Term, Lit.Core.World>
  //log("- run " | Lit.Lang.show.term(term,world))
  //log("- var " | String.join(", ", List.map!!((x) x@fst|":"|Lit.Lang.show.term(x@snd,world), Map.to_list!(vars))))
  //log("")
  case term {
    var: 
      case vars{term.name} as got {
        none: {term, world}
        some: Lit.Core.World.run.term(got.value, self, world, vars)
      }
    match: Maybe {
      let {expr, world} = Lit.Core.World.run.term(term.expr, self, world, vars)
      case expr {
        create: case term.cses[expr.form] as selected_case {
          some: 
            let {case_fields, case_body} = selected_case.value
            let vars = for subst in List.zip!!(case_fields, expr.vals):
              let {field, value} = subst
              vars{field} <- value
            Lit.Core.World.run.term(case_body, self, world, vars)
        } default {term, world}
      } default {term,world}
    }
    create:
      let {vals, world} = Lit.Core.World.run.terms(term.vals, self, world, vars)
      {Lit.Core.Term.create(term.type, term.form, vals), world}
    call: case world{term.func} as got {
      none:
        {term, world}
      some: case got.value as entry {
        func:
          use func = entry.value
          let main_vars = vars
          let state = {main_vars, world}
          let state = for arg in List.zip!!(func.iarg, term.args):
            let {arg_name, arg_term} = arg
            let {arg_term, world} = Lit.Core.World.run.term(arg_term, self, world, main_vars)
            let main_vars = main_vars{arg_name} <- arg_term
            {main_vars, world}
          let {main_vars, world} = state
          let {done, world} = Lit.Core.World.run.term(func.main, term.func, world, main_vars)
          let vars = vars{term.name} <- done
          Lit.Core.World.run.term(term.cont, self, world, vars)
      } default {term,world}
    }
    bind: case world{term.name} as got {
      none:
        {term, world}
      some: case got.value as entry {
        func:
          use func = entry.value
          let {main, world} = Lit.Core.World.run.term(term.main, self, world, vars)
          let world = world{term.name} <- Lit.Core.Entry.func(func@main <- main)
          Lit.Core.World.run.term(term.cont, self, world, vars)
      } default {term, world}
    }
  } default {term,world}

Lit.Core.World.run.terms(
  terms: List<Lit.Core.Term>
  self: String
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
): Pair<List<Lit.Core.Term>, Lit.Core.World>
  case terms {
    nil:
      {[], world}
    cons:
      let {head, world} = Lit.Core.World.run.term(terms.head, self, world, vars)
      let {tail, world} = Lit.Core.World.run.terms(terms.tail, self, world, vars)
      {head & tail, world}
  }

// Tests
// -----

Lit.Core: _

  let world = {}

  let code = `
    user MrDog {
      0123456789abcdef
    }

    type Unit {
      new
    }

    type Bool {
      true
      false
    }

    type Nat {
      zero
      succ{pred: Nat}
    }

    type NatBool {
      new{
        x: Nat,
        y: Bool
      }
    }

    not(x: Bool): Bool
      case x : Bool {
        true: Bool/false
        false: Bool/true
      }

    double(x: Nat): Nat
      case x : Nat {
        zero:
          Nat/zero
        succ:
          call rest = double(x.pred)
          Nat/succ{pred: Nat/succ{pred: rest}}
      }

    with MrDog {
      call n = double(Nat/succ{pred: Nat/succ{pred: Nat/succ{pred: Nat/zero}}})
      call b = not(Bool/true)
      NatBool/new{x: n, y: b}
    } signed { 0123abcd }

    Count @ COUNT(): Nat
      Nat/zero

    Count.inc(): Unit
      call count = COUNT()
      bind COUNT = Nat/succ{pred: count}
      Unit/new

    with MrDog {
      call x = Count.inc()
      call x = Count.inc()
      call x = Count.inc()
      call x = COUNT()
      x
    } signed { 0123abcd }
  `

  let page = Parser.run!(Lit.Lang.parser.page(world), code) abort IO.print("parse error")

  case Lit.Core.World.run.page(page, world) as result {
    none: IO.print("failure")
    some: IO.print("success")
  }
