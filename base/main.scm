; Short alias to vector-ref
(define get vector-ref)

; Converts a Kind word to a native integer
(define (word-to-u16 w)
  (define (word-to-u16-go i w x)
    (cond ((= 16 i) x)
      ((symbol=? 'Word.e (get w 0)) (word-to-u16-go (+ i 1) (vector 'Word.e) x))
      ((symbol=? 'Word.o (get w 0)) (word-to-u16-go (+ i 1) (get w 1) x))
      ((symbol=? 'Word.i (get w 0)) (word-to-u16-go (+ i 1) (get w 1) (fxior x (fxarithmetic-shift-left 1 i))))))
  (word-to-u16-go 0 w 0))

; Converts a native integer to a Kind word
(define (u16-to-word x)
  (define (u16-to-word-go i x w)
    (if (= 16 i) w (u16-to-word-go (+ i 1) x
      (if (= (fxand (fxarithmetic-shift-right x (- 15 i)) 1) 0)
        (vector 'Word.o w)
        (vector 'Word.i w)))))
  (u16-to-word-go 0 x (vector 'Word.e)))

; Joins a list of strings with an intercalated separator
(define (string_join sep strs fst)
  (if (null? strs) 
    ""
    (string-append
      (if fst "" sep)
      (car strs)
      (string_join sep (cdr strs) #f))))

; Returns the last index that chr occurs in str, -1 otherwise
(define (last_index_of chr str idx)
  (if (= idx (string-length str))
    -1
    (let ((rest (last_index_of chr str (+ idx 1))))
      (if (char=? (string-ref str idx) chr)
        (max idx rest)
        rest))))

; Returns the first index that chr occurs in str, -1 otherwise
(define (first_index_of chr str idx)
  (if (= idx (string-length str))
    -1
    (if (char=? (string-ref str idx) chr)
      idx
      (first_index_of chr str (+ idx 1)))))

; Splits a string using an identifier
(define (split_at_first chr str)
  (let ((split_idx (first_index_of chr str 0)))
    (if (= split_idx -1)
      str
      (cons
        (substring str 0 split_idx)
        (substring str (+ split_idx 1) (string-length str))))))

; Splits a string using an identifier
(define (split_at_last chr str)
  (let ((split_idx (last_index_of chr str 0)))
    (if (= split_idx -1)
      str
      (cons
        (substring str 0 split_idx)
        (substring str (+ split_idx 1) (string-length str))))))

; Converts a date to a string, in milliseconds
(define (time_to_string time)
  (number->string
    (+ (* (time-second time) 1000)
      (div (time-nanosecond time) 1000000))))

; Prints a text with a newline
(define (print txt)
  (display txt)
  (display "
"))

; Gets a line from stdin
(define (get_line)
  (let ((port (current-input-port)))
    (get-line port)))

; Deletes a file
(define (del_file file)
  (delete-file file))

; Gets the contents of a file as a string
; If it doesn't exist, returns empty
(define (get_file file)
  (if (file-exists? file)
    (let ((port (open-input-file file)))
      (let ((text (get-string-all port)))
        (begin
          (close-input-port port)
          text)))
    ""))

; Sets the contents of a file
(define (set_file file text)
  (system (string-append "mkdir -p " (car (split_at_last #\/ file))))
  (if (file-exists? file) (delete-file file))
  (let ((port (open-output-file file)))
    (begin
      (display text port)
      (close-output-port port))))

; Returns a list of files in a directory
(define (get_dir path)
  (directory-list path)) 

; Returns the time a file was modified. TODO: test on Windows/Linux
(define (get_file_mtime file)
  (time_to_string (file-modification-time file)))

; Returns the current time
(define (get_time)
  (time_to_string (current-time)))

; Performs a single Kind IO action
(define (io_action name)
  (case name
    ("print" (lambda (x) (print x)))
    ("put_string" (lambda (x) (display x)))
    ("get_line" (lambda (x) (get_line)))
    ("del_file" (lambda (x) (del_file x)))
    ("get_file" (lambda (x) (get_file x)))
    ("set_file" (lambda (x) (let ((file_text (split_at_first #\= x))) (set_file (car file_text) (cdr file_text)))))
    ("get_dir" (lambda (x) (get_dir x)))
    ("get_file_mtime" (lambda (x) (get_file_mtime x)))
    ("get_time" (lambda (x) (get_time)))))

; Runs a Kind IO program
(define (run_io io)
  (case (get io 0)
    ('IO.end (get io 0))
    ('IO.ask (let (
      (io_query (get io 1))
      (io_param (get io 2))
      (io_then (get io 3)))
      (run_io (io_then ((io_action io_query) io_param)))))))

(define Bool-inst (lambda (x) ((x #t) #f)))
(define Bool-elim (lambda (x) (let ((self0 x)) (case self0 (#t (let () (lambda (c0) (lambda (c1) c0)))) (#f (let () (lambda (c0) (lambda (c1) c1))))))))
(define Nat-inst (lambda (x) ((x 0) (lambda (x0) (+ x0 1)))))
(define Nat-elim (lambda (x) (let ((self0 x)) (case (= self0 0) (#t (let () (lambda (c0) (lambda (c1) c0)))) (#f (let ((f0 (- self0 1))) (lambda (c0) (lambda (c1) (c1 f0)))))))))
(define U16-inst (lambda (x) (x (lambda (x0) (word-to-u16 x0)))))
(define U16-elim (lambda (x) (let ((self0 x)) (case #t (#t (let ((f0 (u16-to-word self0))) (lambda (c0) (c0 f0))))))))
(define String-inst (lambda (x) ((x "") (lambda (x0) (lambda (x1) (string-append (make-string 1 (integer->char x0)) x1))))))
(define String-elim (lambda (x) (let ((self0 x)) (case (= (string-length self0) 0) (#t (let () (lambda (c0) (lambda (c1) c0)))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (lambda (c0) (lambda (c1) ((c1 f0) f1)))))))))
(define ($Bits) '())
(define (Bits) ($Bits))
(define ($BitsMap A) '())
(define (BitsMap) (lambda (A) ($BitsMap A)))
(define ($BitsMap.get bits map) (let ((self0 bits)) (case (get self0 0) ('Bits.e (let () (let ((self0 map)) (case (get self0 0) ('BitsMap.new (let () ($Maybe.none))) ('BitsMap.tie (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) f0)))))) ('Bits.o (let ((f0 (get self0 1))) (let ((self1 map)) (case (get self1 0) ('BitsMap.new (let () ($Maybe.none))) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.get f0 f2))))))) ('Bits.i (let ((f0 (get self0 1))) (let ((self1 map)) (case (get self1 0) ('BitsMap.new (let () ($Maybe.none))) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.get f0 f3))))))))))
(define (BitsMap.get) (lambda (bits) (lambda (map) ($BitsMap.get bits map))))
(define ($BitsMap.keys xs) ($List.reverse ($BitsMap.keys.go xs ($Bits.e) ($List.nil))))
(define (BitsMap.keys) (lambda (xs) ($BitsMap.keys xs)))
(define ($BitsMap.keys.go xs key list) (let ((self0 xs)) (case (get self0 0) ('BitsMap.new (let () list)) ('BitsMap.tie (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((list0 (let ((self3 f0)) (case (get self3 0) ('Maybe.none (let () list)) ('Maybe.some (let ((f3 (get self3 1))) ($List.cons ($Bits.reverse key) list))))))) (let ((list1 ($BitsMap.keys.go f1 ($Bits.o key) list0))) (let ((list2 ($BitsMap.keys.go f2 ($Bits.i key) list1))) list2))))))))
(define (BitsMap.keys.go) (lambda (xs) (lambda (key) (lambda (list) ($BitsMap.keys.go xs key list)))))
(define ($BitsMap.map fn map) (let ((self0 map)) (case (get self0 0) ('BitsMap.new (let () ($BitsMap.new))) ('BitsMap.tie (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((val (let ((self3 f0)) (case (get self3 0) ('Maybe.none (let () ($Maybe.none))) ('Maybe.some (let ((f3 (get self3 1))) ($Maybe.some (fn f3)))))))) (let ((lft ($BitsMap.map fn f1))) (let ((rgt ($BitsMap.map fn f2))) ($BitsMap.tie val lft rgt)))))))))
(define (BitsMap.map) (lambda (fn) (lambda (map) ($BitsMap.map fn map))))
(define ($BitsMap.new) (vector 'BitsMap.new))
(define (BitsMap.new) ($BitsMap.new))
(define ($BitsMap.set bits val map) (let ((self0 bits)) (case (get self0 0) ('Bits.e (let () (let ((self0 map)) (case (get self0 0) ('BitsMap.new (let () ($BitsMap.tie ($Maybe.some val) ($BitsMap.new) ($BitsMap.new)))) ('BitsMap.tie (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($BitsMap.tie ($Maybe.some val) f1 f2))))))) ('Bits.o (let ((f0 (get self0 1))) (let ((self1 map)) (case (get self1 0) ('BitsMap.new (let () ($BitsMap.tie ($Maybe.none) ($BitsMap.set f0 val ($BitsMap.new)) ($BitsMap.new)))) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.tie f1 ($BitsMap.set f0 val f2) f3))))))) ('Bits.i (let ((f0 (get self0 1))) (let ((self1 map)) (case (get self1 0) ('BitsMap.new (let () ($BitsMap.tie ($Maybe.none) ($BitsMap.new) ($BitsMap.set f0 val ($BitsMap.new))))) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.tie f1 f2 ($BitsMap.set f0 val f3)))))))))))
(define (BitsMap.set) (lambda (bits) (lambda (val) (lambda (map) ($BitsMap.set bits val map)))))
(define ($BitsMap.set_if_empty bits val map) ($BitsMap.set_if_empty.cps bits val map))
(define (BitsMap.set_if_empty) (lambda (bits) (lambda (val) (lambda (map) ($BitsMap.set_if_empty bits val map)))))
(define ($BitsMap.set_if_empty.cps bits val map) ($Trampoline.call ($BitsMap.set_if_empty.cps.go bits val map (Trampoline.done))))
(define (BitsMap.set_if_empty.cps) (lambda (bits) (lambda (val) (lambda (map) ($BitsMap.set_if_empty.cps bits val map)))))
(define ($BitsMap.set_if_empty.cps.go bits val map cont) (let ((self0 bits)) (case (get self0 0) ('Bits.e (let () (let ((self0 map)) (case (get self0 0) ('BitsMap.new (let () (cont ($BitsMap.tie ($Maybe.some val) ($BitsMap.new) ($BitsMap.new))))) ('BitsMap.tie (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (cont ($BitsMap.tie (let ((self3 f0)) (case (get self3 0) ('Maybe.none (let () ($Maybe.some val))) ('Maybe.some (let ((f3 (get self3 1))) ($Maybe.some f3))))) f1 f2)))))))) ('Bits.o (let ((f0 (get self0 1))) (let ((self1 map)) (case (get self1 0) ('BitsMap.new (let () ($BitsMap.set_if_empty.cps.go f0 val ($BitsMap.new) (lambda (lft) ($Trampoline.wrap (lambda (-) (cont ($BitsMap.tie ($Maybe.none) lft ($BitsMap.new))))))))) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.set_if_empty.cps.go f0 val f2 (lambda (lft) ($Trampoline.wrap (lambda (-) (cont ($BitsMap.tie f1 lft f3)))))))))))) ('Bits.i (let ((f0 (get self0 1))) (let ((self1 map)) (case (get self1 0) ('BitsMap.new (let () ($BitsMap.set_if_empty.cps.go f0 val ($BitsMap.new) (lambda (rgt) ($Trampoline.wrap (lambda (-) (cont ($BitsMap.tie ($Maybe.none) ($BitsMap.new) rgt)))))))) ('BitsMap.tie (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($BitsMap.set_if_empty.cps.go f0 val f3 (lambda (rgt) ($Trampoline.wrap (lambda (-) (cont ($BitsMap.tie f1 f2 rgt)))))))))))))))
(define (BitsMap.set_if_empty.cps.go) (lambda (bits) (lambda (val) (lambda (map) (lambda (cont) ($BitsMap.set_if_empty.cps.go bits val map cont))))))
(define ($BitsMap.tie val lft rgt) (vector 'BitsMap.tie val lft rgt))
(define (BitsMap.tie) (lambda (val) (lambda (lft) (lambda (rgt) ($BitsMap.tie val lft rgt)))))
(define ($BitsMap.to_list xs) ($List.reverse ($BitsMap.to_list.go xs ($Bits.e) ($List.nil))))
(define (BitsMap.to_list) (lambda (xs) ($BitsMap.to_list xs)))
(define ($BitsMap.to_list.go xs key list) (let ((self0 xs)) (case (get self0 0) ('BitsMap.new (let () list)) ('BitsMap.tie (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((list0 (let ((self3 f0)) (case (get self3 0) ('Maybe.none (let () list)) ('Maybe.some (let ((f3 (get self3 1))) ($List.cons ($Pair.new ($Bits.reverse key) f3) list))))))) (let ((list1 ($BitsMap.to_list.go f1 ($Bits.o key) list0))) (let ((list2 ($BitsMap.to_list.go f2 ($Bits.i key) list1))) list2))))))))
(define (BitsMap.to_list.go) (lambda (xs) (lambda (key) (lambda (list) ($BitsMap.to_list.go xs key list)))))
(define ($BitsSet) '())
(define (BitsSet) ($BitsSet))
(define ($BitsSet.has bits set) (let ((self0 ($BitsMap.get bits set))) (case (get self0 0) ('Maybe.none (let () ($Bool.false))) ('Maybe.some (let ((f0 (get self0 1))) ($Bool.true))))))
(define (BitsSet.has) (lambda (bits) (lambda (set) ($BitsSet.has bits set))))
(define ($BitsSet.mut.has bits set) ($BitsSet.has bits set))
(define (BitsSet.mut.has) (lambda (bits) (lambda (set) ($BitsSet.mut.has bits set))))
(define ($BitsSet.mut.new a) ($BitsSet.new))
(define (BitsSet.mut.new) (lambda (a) ($BitsSet.mut.new a)))
(define ($BitsSet.mut.set bits set) ($BitsSet.set bits set))
(define (BitsSet.mut.set) (lambda (bits) (lambda (set) ($BitsSet.mut.set bits set))))
(define ($BitsSet.new) ($BitsMap.new))
(define (BitsSet.new) ($BitsSet.new))
(define ($BitsSet.set bits set) ($BitsMap.set bits ($Unit.new) set))
(define (BitsSet.set) (lambda (bits) (lambda (set) ($BitsSet.set bits set))))
(define ($Bits.chunks_of len bits) ($Bits.chunks_of.go len bits len ($Bits.e)))
(define (Bits.chunks_of) (lambda (len) (lambda (bits) ($Bits.chunks_of len bits))))
(define ($Bits.chunks_of.go len bits need chunk) (let ((self0 bits)) (case (get self0 0) ('Bits.e (let () ($List.cons ($Bits.reverse chunk) ($List.nil)))) ('Bits.o (let ((f0 (get self0 1))) (let ((self1 need)) (case (= self1 0) (#t (let () (let ((head ($Bits.reverse chunk))) (let ((tail ($Bits.chunks_of.go len bits len ($Bits.e)))) ($List.cons head tail))))) (#f (let ((f1 (- self1 1))) (let ((chunk ($Bits.o chunk))) ($Bits.chunks_of.go len f0 f1 chunk)))))))) ('Bits.i (let ((f0 (get self0 1))) (let ((self1 need)) (case (= self1 0) (#t (let () (let ((head ($Bits.reverse chunk))) (let ((tail ($Bits.chunks_of.go len bits len ($Bits.e)))) ($List.cons head tail))))) (#f (let ((f1 (- self1 1))) (let ((chunk ($Bits.i chunk))) ($Bits.chunks_of.go len f0 f1 chunk)))))))))))
(define (Bits.chunks_of.go) (lambda (len) (lambda (bits) (lambda (need) (lambda (chunk) ($Bits.chunks_of.go len bits need chunk))))))
(define ($Bits.concat a b) (let ((self0 a)) (case (get self0 0) ('Bits.e (let () b)) ('Bits.o (let ((f0 (get self0 1))) ($Bits.o ($Bits.concat f0 b)))) ('Bits.i (let ((f0 (get self0 1))) ($Bits.i ($Bits.concat f0 b)))))))
(define (Bits.concat) (lambda (a) (lambda (b) ($Bits.concat a b))))
(define ($Bits.e) (vector 'Bits.e))
(define (Bits.e) ($Bits.e))
(define ($Bits.eql a b) (let ((self0 a)) (case (get self0 0) ('Bits.e (let () (let ((self0 b)) (case (get self0 0) ('Bits.e (let () ($Bool.true))) ('Bits.o (let ((f0 (get self0 1))) ($Bool.false))) ('Bits.i (let ((f0 (get self0 1))) ($Bool.false))))))) ('Bits.o (let ((f0 (get self0 1))) (let ((self1 b)) (case (get self1 0) ('Bits.e (let () ($Bool.false))) ('Bits.o (let ((f1 (get self1 1))) ($Bits.eql f0 f1))) ('Bits.i (let ((f1 (get self1 1))) ($Bool.false))))))) ('Bits.i (let ((f0 (get self0 1))) (let ((self1 b)) (case (get self1 0) ('Bits.e (let () ($Bool.false))) ('Bits.o (let ((f1 (get self1 1))) ($Bool.false))) ('Bits.i (let ((f1 (get self1 1))) ($Bits.eql f0 f1))))))))))
(define (Bits.eql) (lambda (a) (lambda (b) ($Bits.eql a b))))
(define ($Bits.i pred) (vector 'Bits.i pred))
(define (Bits.i) (lambda (pred) ($Bits.i pred)))
(define ($Bits.inc a) (let ((self0 a)) (case (get self0 0) ('Bits.e (let () ($Bits.i ($Bits.e)))) ('Bits.o (let ((f0 (get self0 1))) ($Bits.i f0))) ('Bits.i (let ((f0 (get self0 1))) ($Bits.o ($Bits.inc f0)))))))
(define (Bits.inc) (lambda (a) ($Bits.inc a)))
(define ($Bits.o pred) (vector 'Bits.o pred))
(define (Bits.o) (lambda (pred) ($Bits.o pred)))
(define ($Bits.reverse a) ($Bits.reverse.tco a ($Bits.e)))
(define (Bits.reverse) (lambda (a) ($Bits.reverse a)))
(define ($Bits.reverse.tco a r) (let ((self0 a)) (case (get self0 0) ('Bits.e (let () r)) ('Bits.o (let ((f0 (get self0 1))) ($Bits.reverse.tco f0 ($Bits.o r)))) ('Bits.i (let ((f0 (get self0 1))) ($Bits.reverse.tco f0 ($Bits.i r)))))))
(define (Bits.reverse.tco) (lambda (a) (lambda (r) ($Bits.reverse.tco a r))))
(define ($Bits.tail a) (let ((self0 a)) (case (get self0 0) ('Bits.e (let () ($Bits.e))) ('Bits.o (let ((f0 (get self0 1))) f0)) ('Bits.i (let ((f0 (get self0 1))) f0)))))
(define (Bits.tail) (lambda (a) ($Bits.tail a)))
(define ($Bits.to_nat b) (let ((self0 b)) (case (get self0 0) ('Bits.e (let () 0)) ('Bits.o (let ((f0 (get self0 1))) ($Nat.mul 2 ($Bits.to_nat f0)))) ('Bits.i (let ((f0 (get self0 1))) ($Nat.succ ($Nat.mul 2 ($Bits.to_nat f0))))))))
(define (Bits.to_nat) (lambda (b) ($Bits.to_nat b)))
(define ($Bool) '())
(define (Bool) ($Bool))
(define ($Bool.and a b) (and a b))
(define (Bool.and) (lambda (a) (lambda (b) ($Bool.and a b))))
(define ($Bool.eql a b) (let ((self0 a)) (case self0 (#t (let () b)) (#f (let () ($Bool.not b))))))
(define (Bool.eql) (lambda (a) (lambda (b) ($Bool.eql a b))))
(define ($Bool.false) #f)
(define (Bool.false) ($Bool.false))
(define ($Bool.not a) (not a))
(define (Bool.not) (lambda (a) ($Bool.not a)))
(define ($Bool.or a b) (or a b))
(define (Bool.or) (lambda (a) (lambda (b) ($Bool.or a b))))
(define ($Bool.read code) (let ((self0 ($String.eql code "Bool.true"))) (case self0 (#t (let () ($Maybe.some ($Bool.true)))) (#f (let () (let ((self0 ($String.eql code "Bool.false"))) (case self0 (#t (let () ($Maybe.some ($Bool.false)))) (#f (let () ($Maybe.none))))))))))
(define (Bool.read) (lambda (code) ($Bool.read code)))
(define ($Bool.show b) (let ((self0 b)) (case self0 (#t (let () "Bool.true")) (#f (let () "Bool.false")))))
(define (Bool.show) (lambda (b) ($Bool.show b)))
(define ($Bool.true) #t)
(define (Bool.true) ($Bool.true))
(define ($Char) '())
(define (Char) ($Char))
(define ($Char.dec_value chr) (let ((self0 ($U16.eql chr 48))) (case self0 (#t (let () 0)) (#f (let () (let ((self0 ($U16.eql chr 49))) (case self0 (#t (let () 1)) (#f (let () (let ((self0 ($U16.eql chr 50))) (case self0 (#t (let () 2)) (#f (let () (let ((self0 ($U16.eql chr 51))) (case self0 (#t (let () 3)) (#f (let () (let ((self0 ($U16.eql chr 52))) (case self0 (#t (let () 4)) (#f (let () (let ((self0 ($U16.eql chr 53))) (case self0 (#t (let () 5)) (#f (let () (let ((self0 ($U16.eql chr 54))) (case self0 (#t (let () 6)) (#f (let () (let ((self0 ($U16.eql chr 55))) (case self0 (#t (let () 7)) (#f (let () (let ((self0 ($U16.eql chr 56))) (case self0 (#t (let () 8)) (#f (let () (let ((self0 ($U16.eql chr 57))) (case self0 (#t (let () 9)) (#f (let () 0)))))))))))))))))))))))))))))))))))))))))
(define (Char.dec_value) (lambda (chr) ($Char.dec_value chr)))
(define ($Char.eql a b) ($U16.eql a b))
(define (Char.eql) (lambda (a) (lambda (b) ($Char.eql a b))))
(define ($Char.hex_value16 chr) (let ((self0 ($Bool.and ($U16.gte chr 48) ($U16.lte chr 57)))) (case self0 (#t (let () ($U16.sub chr 48))) (#f (let () (let ((self0 ($Bool.and ($U16.gte chr 97) ($U16.lte chr 102)))) (case self0 (#t (let () ((lambda (x0) ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc x0))))))))))) ($U16.sub chr 97)))) (#f (let () (let ((self0 ($Bool.and ($U16.gte chr 65) ($U16.lte chr 70)))) (case self0 (#t (let () ((lambda (x0) ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc ($U16.inc x0))))))))))) ($U16.sub chr 65)))) (#f (let () ($U16.zero))))))))))))))
(define (Char.hex_value16) (lambda (chr) ($Char.hex_value16 chr)))
(define ($Char.is_hex chr) ($Bool.or ($Bool.and ($U16.gte chr 48) ($U16.lte chr 57)) ($Bool.or ($Bool.and ($U16.gte chr 97) ($U16.lte chr 102)) ($Bool.or ($Bool.and ($U16.gte chr 65) ($U16.lte chr 70)) ($Bool.false)))))
(define (Char.is_hex) (lambda (chr) ($Char.is_hex chr)))
(define ($Cmp) '())
(define (Cmp) ($Cmp))
(define ($Cmp.as_eql cmp) (let ((self0 cmp)) (case (get self0 0) ('Cmp.ltn (let () ($Bool.false))) ('Cmp.eql (let () ($Bool.true))) ('Cmp.gtn (let () ($Bool.false))))))
(define (Cmp.as_eql) (lambda (cmp) ($Cmp.as_eql cmp)))
(define ($Cmp.as_gte cmp) (let ((self0 cmp)) (case (get self0 0) ('Cmp.ltn (let () ($Bool.false))) ('Cmp.eql (let () ($Bool.true))) ('Cmp.gtn (let () ($Bool.true))))))
(define (Cmp.as_gte) (lambda (cmp) ($Cmp.as_gte cmp)))
(define ($Cmp.as_lte cmp) (let ((self0 cmp)) (case (get self0 0) ('Cmp.ltn (let () ($Bool.true))) ('Cmp.eql (let () ($Bool.true))) ('Cmp.gtn (let () ($Bool.false))))))
(define (Cmp.as_lte) (lambda (cmp) ($Cmp.as_lte cmp)))
(define ($Cmp.as_ltn cmp) (let ((self0 cmp)) (case (get self0 0) ('Cmp.ltn (let () ($Bool.true))) ('Cmp.eql (let () ($Bool.false))) ('Cmp.gtn (let () ($Bool.false))))))
(define (Cmp.as_ltn) (lambda (cmp) ($Cmp.as_ltn cmp)))
(define ($Cmp.eql) (vector 'Cmp.eql))
(define (Cmp.eql) ($Cmp.eql))
(define ($Cmp.gtn) (vector 'Cmp.gtn))
(define (Cmp.gtn) ($Cmp.gtn))
(define ($Cmp.ltn) (vector 'Cmp.ltn))
(define (Cmp.ltn) ($Cmp.ltn))
(define ($Debug.log s x) (x ($Unit.new)))
(define (Debug.log) (lambda (s) (lambda (x) ($Debug.log s x))))
(define ($Either A B) '())
(define (Either) (lambda (A) (lambda (B) ($Either A B))))
(define ($Either.left value) (vector 'Either.left value))
(define (Either.left) (lambda (value) ($Either.left value)))
(define ($Either.right value) (vector 'Either.right value))
(define (Either.right) (lambda (value) ($Either.right value)))
(define ($IO A) '())
(define (IO) (lambda (A) ($IO A)))
(define ($IO.ask query param then) (vector 'IO.ask query param then))
(define (IO.ask) (lambda (query) (lambda (param) (lambda (then) ($IO.ask query param then)))))
(define ($IO.bind a f) (let ((self0 a)) (case (get self0 0) ('IO.end (let ((f0 (get self0 1))) (f f0))) ('IO.ask (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($IO.ask f0 f1 (lambda (x) ($IO.bind (f2 x) f))))))))
(define (IO.bind) (lambda (a) (lambda (f) ($IO.bind a f))))
(define ($IO.end value) (vector 'IO.end value))
(define (IO.end) (lambda (value) ($IO.end value)))
(define ($IO.get_file name) ($IO.ask "get_file" name (lambda (file) ($IO.end file))))
(define (IO.get_file) (lambda (name) ($IO.get_file name)))
(define ($IO.get_file_mtime name) ($IO.ask "get_file_mtime" name (lambda (file) ($IO.end file))))
(define (IO.get_file_mtime) (lambda (name) ($IO.get_file_mtime name)))
(define ($IO.get_time) ($IO.ask "get_time" "" (lambda (time) ($IO.end ($Nat.read time)))))
(define (IO.get_time) ($IO.get_time))
(define ($IO.monad) ($Monad.new (IO.bind) (IO.end)))
(define (IO.monad) ($IO.monad))
(define ($IO.print text) ($IO.put_string ($String.concat text "\xA;")))
(define (IO.print) (lambda (text) ($IO.print text)))
(define ($IO.put_string text) ($IO.ask "put_string" text (lambda (skip) ($IO.end ($Unit.new)))))
(define (IO.put_string) (lambda (text) ($IO.put_string text)))
(define ($IO.set_file name content) ($IO.ask "set_file" ($String.concat name ($String.concat "=" content)) (lambda (ok) ($IO.end ($Unit.new)))))
(define (IO.set_file) (lambda (name) (lambda (content) ($IO.set_file name content))))
(define ($Kind.Ann) '())
(define (Kind.Ann) ($Kind.Ann))
(define ($Kind.Ann.new name term type) (vector 'Kind.Ann.new name term type))
(define (Kind.Ann.new) (lambda (name) (lambda (term) (lambda (type) ($Kind.Ann.new name term type)))))
(define ($Kind.Binder) '())
(define (Kind.Binder) ($Kind.Binder))
(define ($Kind.Binder.new eras name term) (vector 'Kind.Binder.new eras name term))
(define (Kind.Binder.new) (lambda (eras) (lambda (name) (lambda (term) ($Kind.Binder.new eras name term)))))
(define ($Kind.Check V) '())
(define (Kind.Check) (lambda (V) ($Kind.Check V)))
(define ($Kind.Check.bind a f) (let ((self0 a)) (case (get self0 0) ('Kind.Check.result (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Maybe.none (let () ($Kind.Check.result ($Maybe.none) f1))) ('Maybe.some (let ((f2 (get self2 1))) (let ((self3 (f f2))) (case (get self3 0) ('Kind.Check.result (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Check.result f3 ($List.concat f1 f4)))))))))))))))
(define (Kind.Check.bind) (lambda (a) (lambda (f) ($Kind.Check.bind a f))))
(define ($Kind.Check.monad) ($Monad.new (Kind.Check.bind) (Kind.Check.pure)))
(define (Kind.Check.monad) ($Kind.Check.monad))
(define ($Kind.Check.pure value) ($Kind.Check.result ($Maybe.some value) ($List.nil)))
(define (Kind.Check.pure) (lambda (value) ($Kind.Check.pure value)))
(define ($Kind.Check.result value errors) (vector 'Kind.Check.result value errors))
(define (Kind.Check.result) (lambda (value) (lambda (errors) ($Kind.Check.result value errors))))
(define ($Kind.Code.backslash) ($Nat.to_u16 92))
(define (Kind.Code.backslash) ($Kind.Code.backslash))
(define ($Kind.Code.color col str) ($String.cons ($Nat.to_u16 27) ($String.cons 91 ($String.concat col ($String.cons 109 ($String.concat str ($String.cons ($Nat.to_u16 27) ($String.cons 91 ($String.cons 48 ($String.cons 109 ($String.nil)))))))))))
(define (Kind.Code.color) (lambda (col) (lambda (str) ($Kind.Code.color col str))))
(define ($Kind.Code.escape str) ($Kind.Code.escape.go str ""))
(define (Kind.Code.escape) (lambda (str) ($Kind.Code.escape str)))
(define ($Kind.Code.escapes) ($List.cons ($Pair.new "\\b" 8) ($List.cons ($Pair.new "\\f" 12) ($List.cons ($Pair.new "\\n" 10) ($List.cons ($Pair.new "\\r" 13) ($List.cons ($Pair.new "\\t" 9) ($List.cons ($Pair.new "\\v" 11) ($List.cons ($Pair.new ($String.cons ($Kind.Code.backslash) ($String.cons ($Kind.Code.backslash) ($String.nil))) ($Kind.Code.backslash)) ($List.cons ($Pair.new "\\\"" 34) ($List.cons ($Pair.new "\\0" 0) ($List.cons ($Pair.new "\\'" 39) ($List.nil))))))))))))
(define (Kind.Code.escapes) ($Kind.Code.escapes))
(define ($Kind.Code.escape.char chr) (let ((self0 ($U16.eql chr ($Kind.Code.backslash)))) (case self0 (#t (let () ($String.cons ($Kind.Code.backslash) ($String.cons chr ($String.nil))))) (#f (let () (let ((self0 ($U16.eql chr 34))) (case self0 (#t (let () ($String.cons ($Kind.Code.backslash) ($String.cons chr ($String.nil))))) (#f (let () (let ((self0 ($U16.eql chr 39))) (case self0 (#t (let () ($String.cons ($Kind.Code.backslash) ($String.cons chr ($String.nil))))) (#f (let () (let ((self0 ($U16.btw 32 chr 126))) (case self0 (#t (let () ($String.cons chr ($String.nil)))) (#f (let () ($String.concat ($String.cons ($Kind.Code.backslash) ($String.nil)) ($String.concat "u{" ($String.concat ($U16.show_hex chr) "}"))))))))))))))))))))
(define (Kind.Code.escape.char) (lambda (chr) ($Kind.Code.escape.char chr)))
(define ($Kind.Code.escape.go str result) (let ((self0 str)) (case (= (string-length self0) 0) (#t (let () ($String.reverse result))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($Kind.Code.escape.go f1 ($String.concat ($String.reverse ($Kind.Code.escape.char f0)) result)))))))
(define (Kind.Code.escape.go) (lambda (str) (lambda (result) ($Kind.Code.escape.go str result))))
(define ($Kind.Code.highlight code idx0 idx1) ($Kind.Code.highlight.go code idx0 idx1 0 1 ($Maybe.none) ($String.reverse "   1 | ") ($List.nil)))
(define (Kind.Code.highlight) (lambda (code) (lambda (idx0) (lambda (idx1) ($Kind.Code.highlight code idx0 idx1)))))
(define ($Kind.Code.highlight.end col row res) ($String.join "\xA;" res))
(define (Kind.Code.highlight.end) (lambda (col) (lambda (row) (lambda (res) ($Kind.Code.highlight.end col row res)))))
(define ($Kind.Code.highlight.go code ix0 ix1 col row lft lin res) (let ((spa 3)) (let ((self1 code)) (case (= (string-length self1) 0) (#t (let () ($Kind.Code.highlight.end col row ($List.reverse res)))) (#f (let ((f1 (char->integer (string-ref self1 0)))(f2 (let ((_str_ self1)) (substring _str_ 1 (string-length _str_))))) (let ((self3 ($U16.eql f1 10))) (case self3 (#t (let () (let ((stp ($Maybe.extract lft ($Bool.false) (Nat.is_zero)))) (let ((self4 stp)) (case self4 (#t (let () ($Kind.Code.highlight.end col row ($List.reverse res)))) (#f (let () (let ((siz ($Nat.succ ($Nat.double spa)))) (let ((lft (let ((self5 ix1)) (case (= self5 0) (#t (let () (let ((self5 lft)) (case (get self5 0) ('Maybe.none (let () ($Maybe.some spa))) ('Maybe.some (let ((f5 (get self5 1))) ($Maybe.some ($Nat.pred f5)))))))) (#f (let ((f5 (- self5 1))) lft)))))) (let ((ix0 ($Nat.pred ix0))) (let ((ix1 ($Nat.pred ix1))) (let ((col 0)) (let ((row ($Nat.succ row))) (let ((res ($List.cons ($String.reverse lin) res))) (let ((lin ($String.reverse ($String.flatten ($List.cons ($String.pad_left 4 32 ($Nat.show row)) ($List.cons " | " ($List.nil))))))) ($Kind.Code.highlight.go f2 ix0 ix1 col row lft lin res)))))))))))))))) (#f (let () (let ((chr ($String.cons f1 ($String.nil)))) (let ((chr (let ((self4 ($Bool.and ($Nat.is_zero ix0) ($Bool.not ($Nat.is_zero ix1))))) (case self4 (#t (let () ($String.reverse ($Kind.Code.color "31" ($Kind.Code.color "4" chr))))) (#f (let () chr)))))) (let ((res (let ((self5 ($Nat.eql ix0 1))) (case self5 (#t (let () ($List.take spa res))) (#f (let () res)))))) (let ((ix0 ($Nat.pred ix0))) (let ((ix1 ($Nat.pred ix1))) (let ((col ($Nat.succ col))) (let ((lin ($String.flatten ($List.cons chr ($List.cons lin ($List.nil)))))) ($Kind.Code.highlight.go f2 ix0 ix1 col row lft lin res))))))))))))))))))
(define (Kind.Code.highlight.go) (lambda (code) (lambda (ix0) (lambda (ix1) (lambda (col) (lambda (row) (lambda (lft) (lambda (lin) (lambda (res) ($Kind.Code.highlight.go code ix0 ix1 col row lft lin res))))))))))
(define ($Kind.Constructor) '())
(define (Kind.Constructor) ($Kind.Constructor))
(define ($Kind.Constructor.build_term type ctor) (let ((self0 type)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) (let ((self4 ctor)) (case (get self4 0) ('Kind.Constructor.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) ($Kind.Constructor.build_term.go type ctor f0 f1 f5))))))))))
(define (Kind.Constructor.build_term) (lambda (type) (lambda (ctor) ($Kind.Constructor.build_term type ctor))))
(define ($Kind.Constructor.build_term.go type ctor name pars args) (let ((self0 pars)) (case (get self0 0) ('List.nil (let () (let ((self0 args)) (case (get self0 0) ('List.nil (let () ($Kind.Term.lam ($Kind.Name.read "P") (lambda (x) ($Kind.Constructor.build_term.opt type ctor))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.lam f3 (lambda (x) ($Kind.Constructor.build_term.go type ctor name pars f1))))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.lam f3 (lambda (x) ($Kind.Constructor.build_term.go type ctor name f1 args))))))))))))
(define (Kind.Constructor.build_term.go) (lambda (type) (lambda (ctor) (lambda (name) (lambda (pars) (lambda (args) ($Kind.Constructor.build_term.go type ctor name pars args)))))))
(define ($Kind.Constructor.build_term.opt type ctor) (let ((self0 type)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) ($Kind.Constructor.build_term.opt.go type ctor f3))))))
(define (Kind.Constructor.build_term.opt) (lambda (type) (lambda (ctor) ($Kind.Constructor.build_term.opt type ctor))))
(define ($Kind.Constructor.build_term.opt.go type ctor ctrs) (let ((self0 ctrs)) (case (get self0 0) ('List.nil (let () (let ((self0 ctor)) (case (get self0 0) ('Kind.Constructor.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((ret ($Kind.Term.ref f0))) (let ((ret ($List.for f1 ret (lambda (arg) (lambda (ret) ($Kind.Term.app ret ($Kind.Term.ref (let ((self6 arg)) (case (get self6 0) ('Kind.Binder.new (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) f7))))))))))) ret)))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Constructor.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.lam f2 (lambda (x) ($Kind.Constructor.build_term.opt.go type ctor f1))))))))))))
(define (Kind.Constructor.build_term.opt.go) (lambda (type) (lambda (ctor) (lambda (ctrs) ($Kind.Constructor.build_term.opt.go type ctor ctrs)))))
(define ($Kind.Constructor.build_type type ctor) (let ((self0 type)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) (let ((self4 ctor)) (case (get self4 0) ('Kind.Constructor.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) ($Kind.Constructor.build_type.go type ctor f0 f1 f5))))))))))
(define (Kind.Constructor.build_type) (lambda (type) (lambda (ctor) ($Kind.Constructor.build_type type ctor))))
(define ($Kind.Constructor.build_type.go type ctor name pars args) (let ((self0 pars)) (case (get self0 0) ('List.nil (let () (let ((self0 args)) (case (get self0 0) ('List.nil (let () (let ((self0 type)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) (let ((self4 ctor)) (case (get self4 0) ('Kind.Constructor.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((type ($Kind.Term.ref name))) (let ((type ($List.for f1 type (lambda (v) (lambda (type) ($Kind.Term.app type ($Kind.Term.ref (let ((self10 v)) (case (get self10 0) ('Kind.Binder.new (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) f11))))))))))) (let ((type ($List.for f6 type (lambda (v) (lambda (type) ($Kind.Term.app type (let ((self11 v)) (case (get self11 0) ('Kind.Binder.new (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) f13)))))))))) type))))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all f2 "" f3 f4 (lambda (s) (lambda (x) ($Kind.Constructor.build_type.go type ctor name pars f1)))))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all f2 "" f3 f4 (lambda (s) (lambda (x) ($Kind.Constructor.build_type.go type ctor name f1 args)))))))))))))
(define (Kind.Constructor.build_type.go) (lambda (type) (lambda (ctor) (lambda (name) (lambda (pars) (lambda (args) ($Kind.Constructor.build_type.go type ctor name pars args)))))))
(define ($Kind.Constructor.new name args inds) (vector 'Kind.Constructor.new name args inds))
(define (Kind.Constructor.new) (lambda (name) (lambda (args) (lambda (inds) ($Kind.Constructor.new name args inds)))))
(define ($Kind.Context) '())
(define (Kind.Context) ($Kind.Context))
(define ($Kind.Context.find name ctx) (let ((self0 ($Kind.Context.get_name_skips name))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Context.find.go f0 f1 ctx))))))
(define (Kind.Context.find) (lambda (name) (lambda (ctx) ($Kind.Context.find name ctx))))
(define ($Kind.Context.find.go name skip ctx) (let ((self0 ctx)) (case (get self0 0) ('List.nil (let () ($Maybe.none))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 ($Kind.Name.eql name f2))) (case self4 (#t (let () (let ((self4 skip)) (case (= self4 0) (#t (let () ($Maybe.some f3))) (#f (let ((f4 (- self4 1))) ($Kind.Context.find.go name f4 f1))))))) (#f (let () ($Kind.Context.find.go name skip f1))))))))))))))
(define (Kind.Context.find.go) (lambda (name) (lambda (skip) (lambda (ctx) ($Kind.Context.find.go name skip ctx)))))
(define ($Kind.Context.get_name_skips name) (let ((self0 name)) (case (= (string-length self0) 0) (#t (let () ($Pair.new "" 0))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((name_skips ($Kind.Context.get_name_skips f1))) (let ((self3 name_skips)) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 ($U16.eql f0 94))) (case self5 (#t (let () ($Pair.new f3 ($Nat.succ f4)))) (#f (let () ($Pair.new ($String.cons f0 f3) f4)))))))))))))))
(define (Kind.Context.get_name_skips) (lambda (name) ($Kind.Context.get_name_skips name)))
(define ($Kind.Context.show context) (let ((self0 context)) (case (get self0 0) ('List.nil (let () "")) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((name ($Kind.Name.show f2))) (let ((type ($Kind.Term.show ($Kind.Term.normalize f3 ($Kind.Map.new))))) (let ((rest ($Kind.Context.show f1))) ($String.concat rest ($String.concat "- " ($String.concat name ($String.concat ": " ($String.concat type "\xA;")))))))))))))))))
(define (Kind.Context.show) (lambda (context) ($Kind.Context.show context)))
(define ($Kind.Core.dependencies term) ($Kind.Map.keys ($Kind.Core.dependencies.go term ($Kind.Map.new))))
(define (Kind.Core.dependencies) (lambda (term) ($Kind.Core.dependencies term)))
(define ($Kind.Core.dependencies.go term deps) (let ((nil ($Kind.Term.typ))) (let ((self1 term)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))(f2 (get self1 2))) deps)) ('Kind.Term.ref (let ((f1 (get self1 1))) ($Kind.Map.set f1 ($Unit.new) deps))) ('Kind.Term.typ (let () deps)) ('Kind.Term.all (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))) (let ((deps ($Kind.Core.dependencies.go f4 deps))) (let ((deps ($Kind.Core.dependencies.go ((f5 nil) nil) deps))) deps)))) ('Kind.Term.lam (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((deps ($Kind.Core.dependencies.go (f2 nil) deps))) deps))) ('Kind.Term.app (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((deps ($Kind.Core.dependencies.go f1 deps))) (let ((deps ($Kind.Core.dependencies.go f2 deps))) deps)))) ('Kind.Term.let (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (let ((deps ($Kind.Core.dependencies.go f2 deps))) (let ((deps ($Kind.Core.dependencies.go (f3 nil) deps))) deps)))) ('Kind.Term.def (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (let ((deps ($Kind.Core.dependencies.go f2 deps))) (let ((deps ($Kind.Core.dependencies.go (f3 nil) deps))) deps)))) ('Kind.Term.ann (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (let ((deps ($Kind.Core.dependencies.go f2 deps))) (let ((deps ($Kind.Core.dependencies.go f3 deps))) deps)))) ('Kind.Term.gol (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) deps)) ('Kind.Term.hol (let ((f1 (get self1 1))) deps)) ('Kind.Term.nat (let ((f1 (get self1 1))) deps)) ('Kind.Term.chr (let ((f1 (get self1 1))) deps)) ('Kind.Term.str (let ((f1 (get self1 1))) deps)) ('Kind.Term.cse (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))) deps)) ('Kind.Term.ori (let ((f1 (get self1 1))(f2 (get self1 2))) deps))))))
(define (Kind.Core.dependencies.go) (lambda (term) (lambda (deps) ($Kind.Core.dependencies.go term deps))))
(define ($Kind.Core.read code) (let ((self0 ($Kind.Core.read.term ($String.concat code ";")))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (= (string-length self2) 0) (#t (let () ($Maybe.none))) (#f (let ((f2 (char->integer (string-ref self2 0)))(f3 (let ((_str_ self2)) (substring _str_ 1 (string-length _str_))))) ($Maybe.some (f1 ($List.nil))))))))))))
(define (Kind.Core.read) (lambda (code) ($Kind.Core.read code)))
(define ($Kind.Core.read.char code chr) (let ((self0 ($Kind.Core.read.spaces code))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (= (string-length self2) 0) (#t (let () ($Pair.new "" ($Unit.new)))) (#f (let ((f2 (char->integer (string-ref self2 0)))(f3 (let ((_str_ self2)) (substring _str_ 1 (string-length _str_))))) (let ((self4 ($U16.eql f2 chr))) (case self4 (#t (let () ($Pair.new f3 ($Unit.new)))) (#f (let () ($Pair.new "" ($Unit.new)))))))))))))))
(define (Kind.Core.read.char) (lambda (code) (lambda (chr) ($Kind.Core.read.char code chr))))
(define ($Kind.Core.read.chrx code) (let ((self0 ($String.starts_with code "\\u{"))) (case self0 (#t (let () (let ((code ($String.drop 3 code))) (let ((self1 ($Kind.Core.read.u16 code ($Nat.to_u16 0)))) (case (get self1 0) ('Pair.new (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((self3 ($String.starts_with f1 "}"))) (case self3 (#t (let () ($Pair.new ($String.drop 1 f1) f2))) (#f (let () ($Pair.new "" 63)))))))))))) (#f (let () (let ((self0 ($String.starts_with code "\\'"))) (case self0 (#t (let () ($Pair.new ($String.drop 2 code) 39))) (#f (let () (let ((self0 ($String.starts_with code "\\\""))) (case self0 (#t (let () ($Pair.new ($String.drop 2 code) 34))) (#f (let () (let ((self0 ($String.starts_with code "\\\\"))) (case self0 (#t (let () ($Pair.new ($String.drop 2 code) 92))) (#f (let () (let ((self0 code)) (case (= (string-length self0) 0) (#t (let () ($Pair.new "" 63))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($Pair.new f1 f0))))))))))))))))))))))
(define (Kind.Core.read.chrx) (lambda (code) ($Kind.Core.read.chrx code)))
(define ($Kind.Core.read.find list cond indx skip) (let ((self0 list)) (case (get self0 0) ('List.nil (let () ($Maybe.none))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ((cond f0) indx))) (case self2 (#t (let () (let ((self2 ($Nat.eql skip 0))) (case self2 (#t (let () ($Maybe.some ($Pair.new f0 indx)))) (#f (let () ($Kind.Core.read.find f1 cond ($Nat.succ indx) ($Nat.pred skip)))))))) (#f (let () ($Kind.Core.read.find f1 cond ($Nat.succ indx) skip))))))))))
(define (Kind.Core.read.find) (lambda (list) (lambda (cond) (lambda (indx) (lambda (skip) ($Kind.Core.read.find list cond indx skip))))))
(define ($Kind.Core.read.is_name chr) ($Bool.or ($Bool.and ($U16.gte chr ($Nat.to_u16 46)) ($U16.lte chr ($Nat.to_u16 47))) ($Bool.or ($Bool.and ($U16.gte chr ($Nat.to_u16 48)) ($U16.ltn chr ($Nat.to_u16 58))) ($Bool.or ($Bool.and ($U16.gte chr ($Nat.to_u16 65)) ($U16.ltn chr ($Nat.to_u16 91))) ($Bool.or ($Bool.and ($U16.gte chr ($Nat.to_u16 95)) ($U16.ltn chr ($Nat.to_u16 96))) ($Bool.or ($Bool.and ($U16.gte chr ($Nat.to_u16 97)) ($U16.ltn chr ($Nat.to_u16 123))) ($Bool.false)))))))
(define (Kind.Core.read.is_name) (lambda (chr) ($Kind.Core.read.is_name chr)))
(define ($Kind.Core.read.name code) (let ((self0 code)) (case (= (string-length self0) 0) (#t (let () ($Pair.new code ""))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 ($Kind.Core.read.is_name f0))) (case self2 (#t (let () (let ((self2 ($Kind.Core.read.name f1))) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) ($Pair.new f2 ($String.cons f0 f3)))))))) (#f (let () ($Pair.new code ""))))))))))
(define (Kind.Core.read.name) (lambda (code) ($Kind.Core.read.name code)))
(define ($Kind.Core.read.natx code nat) (let ((self0 code)) (case (= (string-length self0) 0) (#t (let () ($Pair.new code nat))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 ($Char.is_hex f0))) (case self2 (#t (let () (let ((nat ($Nat.add ($Nat.mul nat 10) ($Char.dec_value f0)))) ($Kind.Core.read.natx f1 nat)))) (#f (let () ($Pair.new code nat))))))))))
(define (Kind.Core.read.natx) (lambda (code) (lambda (nat) ($Kind.Core.read.natx code nat))))
(define ($Kind.Core.read.spaces code) (let ((self0 code)) (case (= (string-length self0) 0) (#t (let () ($Pair.new code ($Unit.new)))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((is_space ($Bool.or ($U16.eql f0 32) ($Bool.or ($U16.eql f0 10) ($Bool.or ($U16.eql f0 13) ($Bool.or ($U16.eql f0 9) ($Bool.or ($U16.eql f0 11) ($Bool.or ($U16.eql f0 12) ($Bool.false))))))))) (let ((self3 is_space)) (case self3 (#t (let () ($Kind.Core.read.spaces f1))) (#f (let () ($Pair.new code ($Unit.new))))))))))))
(define (Kind.Core.read.spaces) (lambda (code) ($Kind.Core.read.spaces code)))
(define ($Kind.Core.read.strx code) (let ((self0 ($String.starts_with code "\""))) (case self0 (#t (let () ($Pair.new code ""))) (#f (let () (let ((self0 ($Kind.Core.read.chrx code))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($Kind.Core.read.strx f0))) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) ($Pair.new f2 ($String.cons f1 f3)))))))))))))))
(define (Kind.Core.read.strx) (lambda (code) ($Kind.Core.read.strx code)))
(define ($Kind.Core.read.term code) (let ((self0 ($Kind.Core.read.spaces code))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (= (string-length self2) 0) (#t (let () ($Pair.new "" (lambda (ctx) ($Kind.Term.ref "error"))))) (#f (let ((f2 (char->integer (string-ref self2 0)))(f3 (let ((_str_ self2)) (substring _str_ 1 (string-length _str_))))) (let ((head f2)) (let ((code f3)) (let ((self6 ($Char.eql head 42))) (case self6 (#t (let () ($Pair.new code (lambda (ctx) ($Kind.Term.typ))))) (#f (let () (let ((self6 ($U16.eql head 64))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.name code))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 40))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) (let ((self10 ($Kind.Core.read.name f8))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))(f11 (get self10 2))) (let ((self12 ($Kind.Core.read.char f10 58))) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))(f13 (get self12 2))) (let ((self14 ($Kind.Core.read.term f12))) (case (get self14 0) ('Pair.new (let ((f14 (get self14 1))(f15 (get self14 2))) (let ((self16 ($Kind.Core.read.char f14 41))) (case (get self16 0) ('Pair.new (let ((f16 (get self16 1))(f17 (get self16 2))) (let ((self18 ($Kind.Core.read.term f16))) (case (get self18 0) ('Pair.new (let ((f18 (get self18 1))(f19 (get self18 2))) ($Pair.new f18 (lambda (ctx) ($Kind.Term.all ($Bool.false) f7 f11 (f15 ctx) (lambda (s) (lambda (x) (f19 ($List.cons ($Pair.new f11 x) ($List.cons ($Pair.new f7 s) ctx)))))))))))))))))))))))))))))))))))))) (#f (let () (let ((self6 ($U16.eql head 37))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.name code))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 40))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) (let ((self10 ($Kind.Core.read.name f8))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))(f11 (get self10 2))) (let ((self12 ($Kind.Core.read.char f10 58))) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))(f13 (get self12 2))) (let ((self14 ($Kind.Core.read.term f12))) (case (get self14 0) ('Pair.new (let ((f14 (get self14 1))(f15 (get self14 2))) (let ((self16 ($Kind.Core.read.char f14 41))) (case (get self16 0) ('Pair.new (let ((f16 (get self16 1))(f17 (get self16 2))) (let ((self18 ($Kind.Core.read.term f16))) (case (get self18 0) ('Pair.new (let ((f18 (get self18 1))(f19 (get self18 2))) ($Pair.new f18 (lambda (ctx) ($Kind.Term.all ($Bool.true) f7 f11 (f15 ctx) (lambda (s) (lambda (x) (f19 ($List.cons ($Pair.new f11 x) ($List.cons ($Pair.new f7 s) ctx)))))))))))))))))))))))))))))))))))))) (#f (let () (let ((self6 ($U16.eql head 35))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.name code))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.term f6))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) ($Pair.new f8 (lambda (ctx) ($Kind.Term.lam f7 (lambda (x) (f9 ($List.cons ($Pair.new f7 x) ctx)))))))))))))))) (#f (let () (let ((self6 ($U16.eql head 40))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.term code))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.term f6))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) (let ((self10 ($Kind.Core.read.char f8 41))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))(f11 (get self10 2))) ($Pair.new f10 (lambda (ctx) ($Kind.Term.app (f7 ctx) (f9 ctx)))))))))))))))))) (#f (let () (let ((self6 ($U16.eql head 33))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.name code))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 61))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) (let ((self10 ($Kind.Core.read.term f8))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))(f11 (get self10 2))) (let ((self12 ($Kind.Core.read.char f10 59))) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))(f13 (get self12 2))) (let ((self14 ($Kind.Core.read.term f12))) (case (get self14 0) ('Pair.new (let ((f14 (get self14 1))(f15 (get self14 2))) ($Pair.new f14 (lambda (ctx) ($Kind.Term.let f7 (f11 ctx) (lambda (x) (f15 ($List.cons ($Pair.new f7 x) ctx)))))))))))))))))))))))))))) (#f (let () (let ((self6 ($U16.eql head 36))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.name code))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 61))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) (let ((self10 ($Kind.Core.read.term f8))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))(f11 (get self10 2))) (let ((self12 ($Kind.Core.read.char f10 59))) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))(f13 (get self12 2))) (let ((self14 ($Kind.Core.read.term f12))) (case (get self14 0) ('Pair.new (let ((f14 (get self14 1))(f15 (get self14 2))) ($Pair.new f14 (lambda (ctx) ($Kind.Term.def f7 (f11 ctx) (lambda (x) (f15 ($List.cons ($Pair.new f7 x) ctx)))))))))))))))))))))))))))) (#f (let () (let ((self6 ($U16.eql head 123))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.term code))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 58))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) (let ((self10 ($Kind.Core.read.term f8))) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))(f11 (get self10 2))) (let ((self12 ($Kind.Core.read.char f10 125))) (case (get self12 0) ('Pair.new (let ((f12 (get self12 1))(f13 (get self12 2))) ($Pair.new f12 (lambda (ctx) ($Kind.Term.ann ($Bool.false) (f7 ctx) (f11 ctx)))))))))))))))))))))) (#f (let () (let ((self6 ($U16.eql head 39))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.chrx code))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 39))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) ($Pair.new f8 (lambda (ctx) ($Kind.Term.chr f7))))))))))))) (#f (let () (let ((self6 ($U16.eql head 34))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.strx code))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 ($Kind.Core.read.char f6 34))) (case (get self8 0) ('Pair.new (let ((f8 (get self8 1))(f9 (get self8 2))) ($Pair.new f8 (lambda (ctx) ($Kind.Term.str f7))))))))))))) (#f (let () (let ((self6 ($U16.eql head 43))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.natx code 0))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) ($Pair.new f6 (lambda (ctx) ($Kind.Term.nat f7))))))))) (#f (let () (let ((self6 ($Kind.Core.read.is_name head))) (case self6 (#t (let () (let ((self6 ($Kind.Core.read.name code))) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((name ($String.cons head f7))) (let ((self9 (let ((self9 f6)) (case (= (string-length self9) 0) (#t (let () ($Pair.new "" 0))) (#f (let ((f9 (char->integer (string-ref self9 0)))(f10 (let ((_str_ self9)) (substring _str_ 1 (string-length _str_))))) (let ((self11 ($U16.eql f9 94))) (case self11 (#t (let () ($Kind.Core.read.natx f10 0))) (#f (let () ($Pair.new f6 0))))))))))) (case (get self9 0) ('Pair.new (let ((f9 (get self9 1))(f10 (get self9 2))) ($Pair.new f9 (lambda (ctx) (let ((got ($Kind.Core.read.find ctx (lambda (x) (lambda (i) ($String.eql ($Pair.fst x) name))) 0 f10))) (let ((self13 got)) (case (get self13 0) ('Maybe.none (let () ($Kind.Term.ref name))) ('Maybe.some (let ((f13 (get self13 1))) ($Pair.snd ($Pair.fst f13)))))))))))))))))))) (#f (let () ($Pair.new "" (lambda (ctx) ($Kind.Term.ref "error"))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define (Kind.Core.read.term) (lambda (code) ($Kind.Core.read.term code)))
(define ($Kind.Core.read.u16 code u16) (let ((self0 code)) (case (= (string-length self0) 0) (#t (let () ($Pair.new code u16))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 ($Char.is_hex f0))) (case self2 (#t (let () (let ((u16 ($U16.add ($U16.mul u16 ($Nat.to_u16 16)) ($Char.hex_value16 f0)))) ($Kind.Core.read.u16 f1 u16)))) (#f (let () ($Pair.new code u16))))))))))
(define (Kind.Core.read.u16) (lambda (code) (lambda (u16) ($Kind.Core.read.u16 code u16))))
(define ($Kind.Core.show term) ($Kind.Core.show.go term 0 ($List.nil)))
(define (Kind.Core.show) (lambda (term) ($Kind.Core.show term)))
(define ($Kind.Core.show.go term indx vars) (let ((self0 term)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Core.var_name ($Nat.pred ($Nat.sub indx f1)) f0 0 vars))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Name.show f0))) ('Kind.Term.typ (let () "*")) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((eras f0)) (let ((init (let ((self6 eras)) (case self6 (#t (let () "%")) (#f (let () "@")))))) (let ((self ($Kind.Name.show f1))) (let ((name ($Kind.Name.show f2))) (let ((xtyp ($Kind.Core.show.go f3 indx vars))) (let ((body ($Kind.Core.show.go ((f4 ($Kind.Term.var f1 indx)) ($Kind.Term.var f2 ($Nat.succ indx))) ($Nat.succ ($Nat.succ indx)) ($List.cons f2 ($List.cons f1 vars))))) ($String.flatten ($List.cons init ($List.cons self ($List.cons "(" ($List.cons name ($List.cons ":" ($List.cons xtyp ($List.cons ") " ($List.cons body ($List.nil)))))))))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((name ($Kind.Name.show f0))) (let ((body ($Kind.Core.show.go (f1 ($Kind.Term.var f0 indx)) ($Nat.succ indx) ($List.cons f0 vars)))) ($String.flatten ($List.cons "#" ($List.cons name ($List.cons " " ($List.cons body ($List.nil)))))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((func ($Kind.Core.show.go f0 indx vars))) (let ((argm ($Kind.Core.show.go f1 indx vars))) ($String.flatten ($List.cons "(" ($List.cons func ($List.cons " " ($List.cons argm ($List.cons ")" ($List.nil))))))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((name ($Kind.Name.show f0))) (let ((expr ($Kind.Core.show.go f1 indx vars))) (let ((body ($Kind.Core.show.go (f2 ($Kind.Term.var f0 indx)) ($Nat.succ indx) ($List.cons f0 vars)))) ($String.flatten ($List.cons "!" ($List.cons name ($List.cons " = " ($List.cons expr ($List.cons "; " ($List.cons body ($List.nil))))))))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((name ($Kind.Name.show f0))) (let ((expr ($Kind.Core.show.go f1 indx vars))) (let ((body ($Kind.Core.show.go (f2 ($Kind.Term.var f0 indx)) ($Nat.succ indx) ($List.cons f0 vars)))) ($String.flatten ($List.cons "$" ($List.cons name ($List.cons " = " ($List.cons expr ($List.cons "; " ($List.cons body ($List.nil))))))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((term ($Kind.Core.show.go f1 indx vars))) (let ((type ($Kind.Core.show.go f2 indx vars))) ($String.flatten ($List.cons "{" ($List.cons term ($List.cons ":" ($List.cons type ($List.cons "}" ($List.nil))))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) "<GOL>")) ('Kind.Term.hol (let ((f0 (get self0 1))) "<HOL>")) ('Kind.Term.nat (let ((f0 (get self0 1))) ($String.flatten ($List.cons "+" ($List.cons ($Nat.show f0) ($List.nil)))))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($String.flatten ($List.cons "'" ($List.cons ($Kind.Code.escape.char f0) ($List.cons "'" ($List.nil))))))) ('Kind.Term.str (let ((f0 (get self0 1))) ($String.flatten ($List.cons "\"" ($List.cons ($Kind.Code.escape f0) ($List.cons "\"" ($List.nil))))))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) "<CSE>")) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Core.show.go f1 indx vars))))))
(define (Kind.Core.show.go) (lambda (term) (lambda (indx) (lambda (vars) ($Kind.Core.show.go term indx vars)))))
(define ($Kind.Core.var_name indx name brui vars) (let ((self0 indx)) (case (= self0 0) (#t (let () (let ((self0 brui)) (case (= self0 0) (#t (let () name)) (#f (let ((f0 (- self0 1))) ($String.concat name ($String.concat "^" ($Nat.show brui))))))))) (#f (let ((f0 (- self0 1))) (let ((self1 vars)) (case (get self1 0) ('List.nil (let () "unbound")) ('List.cons (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((brui (let ((self3 ($String.eql name f1))) (case self3 (#t (let () ($Nat.succ brui))) (#f (let () brui)))))) ($Kind.Core.var_name f0 name brui f2)))))))))))
(define (Kind.Core.var_name) (lambda (indx) (lambda (name) (lambda (brui) (lambda (vars) ($Kind.Core.var_name indx name brui vars))))))
(define ($Kind.Datatype) '())
(define (Kind.Datatype) ($Kind.Datatype))
(define ($Kind.Datatype.build_term type) (let ((self0 type)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) ($Kind.Datatype.build_term.go type f0 f1 f2))))))
(define (Kind.Datatype.build_term) (lambda (type) ($Kind.Datatype.build_term type)))
(define ($Kind.Datatype.build_term.constructor type ctor) (let ((self0 ctor)) (case (get self0 0) ('Kind.Constructor.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Datatype.build_term.constructor.go type ctor f1))))))
(define (Kind.Datatype.build_term.constructor) (lambda (type) (lambda (ctor) ($Kind.Datatype.build_term.constructor type ctor))))
(define ($Kind.Datatype.build_term.constructors type) (let ((self0 type)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) ($Kind.Datatype.build_term.constructors.go type f0 f3))))))
(define (Kind.Datatype.build_term.constructors) (lambda (type) ($Kind.Datatype.build_term.constructors type)))
(define ($Kind.Datatype.build_term.constructors.go type name ctrs) (let ((self0 ctrs)) (case (get self0 0) ('List.nil (let () (let ((self0 type)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) (let ((ret ($Kind.Term.ref ($Kind.Name.read "P")))) (let ((ret ($List.for f2 ret (lambda (v) (lambda (ret) ($Kind.Term.app ret ($Kind.Term.ref (let ((self7 v)) (case (get self7 0) ('Kind.Binder.new (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) f8))))))))))) ($Kind.Term.app ret ($Kind.Term.ref ($String.concat name ".Self"))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Constructor.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all ($Bool.false) "" f2 ($Kind.Datatype.build_term.constructor type f0) (lambda (s) (lambda (x) ($Kind.Datatype.build_term.constructors.go type name f1)))))))))))))
(define (Kind.Datatype.build_term.constructors.go) (lambda (type) (lambda (name) (lambda (ctrs) ($Kind.Datatype.build_term.constructors.go type name ctrs)))))
(define ($Kind.Datatype.build_term.constructor.go type ctor args) (let ((self0 args)) (case (get self0 0) ('List.nil (let () (let ((self0 type)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) (let ((self4 ctor)) (case (get self4 0) ('Kind.Constructor.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((ret ($Kind.Term.ref ($Kind.Name.read "P")))) (let ((ret ($List.for f6 ret (lambda (v) (lambda (ret) ($Kind.Term.app ret (let ((self10 v)) (case (get self10 0) ('Kind.Binder.new (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) f12)))))))))) (let ((ctr ($String.flatten ($List.cons f0 ($List.cons ($Kind.Name.read ".") ($List.cons f4 ($List.nil))))))) (let ((slf ($Kind.Term.ref ctr))) (let ((slf ($List.for f1 slf (lambda (v) (lambda (slf) ($Kind.Term.app slf ($Kind.Term.ref (let ((self13 v)) (case (get self13 0) ('Kind.Binder.new (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) f14))))))))))) (let ((slf ($List.for f5 slf (lambda (v) (lambda (slf) ($Kind.Term.app slf ($Kind.Term.ref (let ((self14 v)) (case (get self14 0) ('Kind.Binder.new (let ((f14 (get self14 1))(f15 (get self14 2))(f16 (get self14 3))) f15))))))))))) ($Kind.Term.app ret slf))))))))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (let ((eras f2)) (let ((name f3)) (let ((xtyp f4)) (let ((body ($Kind.Datatype.build_term.constructor.go type ctor f1))) ($Kind.Term.all eras "" name xtyp (lambda (s) (lambda (x) body))))))))))))))))
(define (Kind.Datatype.build_term.constructor.go) (lambda (type) (lambda (ctor) (lambda (args) ($Kind.Datatype.build_term.constructor.go type ctor args)))))
(define ($Kind.Datatype.build_term.go type name pars inds) (let ((self0 pars)) (case (get self0 0) ('List.nil (let () (let ((self0 inds)) (case (get self0 0) ('List.nil (let () ($Kind.Term.all ($Bool.true) ($String.concat name ".Self") ($Kind.Name.read "P") ($Kind.Datatype.build_term.motive type) (lambda (s) (lambda (x) ($Kind.Datatype.build_term.constructors type)))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.lam f3 (lambda (x) ($Kind.Datatype.build_term.go type name pars f1))))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.lam f3 (lambda (x) ($Kind.Datatype.build_term.go type name f1 inds))))))))))))
(define (Kind.Datatype.build_term.go) (lambda (type) (lambda (name) (lambda (pars) (lambda (inds) ($Kind.Datatype.build_term.go type name pars inds))))))
(define ($Kind.Datatype.build_term.motive type) (let ((self0 type)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) ($Kind.Datatype.build_term.motive.go type f0 f2))))))
(define (Kind.Datatype.build_term.motive) (lambda (type) ($Kind.Datatype.build_term.motive type)))
(define ($Kind.Datatype.build_term.motive.go type name inds) (let ((self0 inds)) (case (get self0 0) ('List.nil (let () (let ((self0 type)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) (let ((slf ($Kind.Term.ref name))) (let ((slf ($List.for f1 slf (lambda (v) (lambda (slf) ($Kind.Term.app slf ($Kind.Term.ref (let ((self7 v)) (case (get self7 0) ('Kind.Binder.new (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) f8))))))))))) (let ((slf ($List.for f2 slf (lambda (v) (lambda (slf) ($Kind.Term.app slf ($Kind.Term.ref (let ((self8 v)) (case (get self8 0) ('Kind.Binder.new (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) f9))))))))))) ($Kind.Term.all ($Bool.false) "" "" slf (lambda (s) (lambda (x) ($Kind.Term.typ))))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all f2 "" f3 f4 (lambda (s) (lambda (x) ($Kind.Datatype.build_term.motive.go type name f1)))))))))))))
(define (Kind.Datatype.build_term.motive.go) (lambda (type) (lambda (name) (lambda (inds) ($Kind.Datatype.build_term.motive.go type name inds)))))
(define ($Kind.Datatype.build_type type) (let ((self0 type)) (case (get self0 0) ('Kind.Datatype.new (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) ($Kind.Datatype.build_type.go type f0 f1 f2))))))
(define (Kind.Datatype.build_type) (lambda (type) ($Kind.Datatype.build_type type)))
(define ($Kind.Datatype.build_type.go type name pars inds) (let ((self0 pars)) (case (get self0 0) ('List.nil (let () (let ((self0 inds)) (case (get self0 0) ('List.nil (let () ($Kind.Term.typ))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all ($Bool.false) "" f3 f4 (lambda (s) (lambda (x) ($Kind.Datatype.build_type.go type name pars f1)))))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all ($Bool.false) "" f3 f4 (lambda (s) (lambda (x) ($Kind.Datatype.build_type.go type name f1 inds)))))))))))))
(define (Kind.Datatype.build_type.go) (lambda (type) (lambda (name) (lambda (pars) (lambda (inds) ($Kind.Datatype.build_type.go type name pars inds))))))
(define ($Kind.Datatype.new name pars inds ctrs) (vector 'Kind.Datatype.new name pars inds ctrs))
(define (Kind.Datatype.new) (lambda (name) (lambda (pars) (lambda (inds) (lambda (ctrs) ($Kind.Datatype.new name pars inds ctrs))))))
(define ($Kind.Def) '())
(define (Kind.Def) ($Kind.Def))
(define ($Kind.Defs) '())
(define (Kind.Defs) ($Kind.Defs))
(define ($Kind.Defs.cache defs) ($Kind.Defs.cache.go ($Kind.Map.to_list defs)))
(define (Kind.Defs.cache) (lambda (defs) ($Kind.Defs.cache defs)))
(define ($Kind.Defs.cache.go kvs) (let ((self0 kvs)) (case (get self0 0) ('List.nil (let () (($Monad.pure ($IO.monad)) ($Unit.new)))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f3)) (case (get self4 0) ('Kind.Def.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))(f7 (get self4 4))(f8 (get self4 5))(f9 (get self4 6))(f10 (get self4 7))(f11 (get self4 8))(f12 (get self4 9))) (let ((self13 f12)) (case (get self13 0) ('Kind.Status.init (let () ($Kind.Defs.cache.go f1))) ('Kind.Status.wait (let () ($Kind.Defs.cache.go f1))) ('Kind.Status.done (let ((f13 (get self13 1))) ((($Monad.bind ($IO.monad)) ($IO.get_file_mtime f4)) (lambda (time) ((($Monad.bind ($IO.monad)) ($IO.set_file ($String.concat ".cache/" ($String.concat f2 ".term")) ($Kind.Core.show f8))) (lambda (-) ((($Monad.bind ($IO.monad)) ($IO.set_file ($String.concat ".cache/" ($String.concat f2 ".type")) ($Kind.Core.show f9))) (lambda (-) ((($Monad.bind ($IO.monad)) ($IO.set_file ($String.concat ".cache/" ($String.concat f2 ".isct")) ($Bool.show f10))) (lambda (-) ((($Monad.bind ($IO.monad)) ($IO.set_file ($String.concat ".cache/" ($String.concat f2 ".arit")) ($Nat.show f11))) (lambda (-) ((($Monad.bind ($IO.monad)) ($IO.set_file ($String.concat ".cache/" ($String.concat f2 ".file")) f4)) (lambda (-) ((($Monad.bind ($IO.monad)) ($IO.set_file ($String.concat ".cache/" ($String.concat f2 ".time")) time)) (lambda (-) ($Kind.Defs.cache.go f1))))))))))))))))) ('Kind.Status.fail (let ((f13 (get self13 1))) ($Kind.Defs.cache.go f1))))))))))))))))))
(define (Kind.Defs.cache.go) (lambda (kvs) ($Kind.Defs.cache.go kvs)))
(define ($Kind.Defs.read file code defs) (let ((self0 ((($Kind.Parser.file file code defs) 0) code))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((err f2)) (let ((hig ($Kind.Code.highlight code f0 ($Nat.succ f0)))) (let ((str ($String.flatten ($List.cons err ($List.cons "\xA;" ($List.cons hig ($List.nil))))))) ($Either.left str)))))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Either.right f2))))))
(define (Kind.Defs.read) (lambda (file) (lambda (code) (lambda (defs) ($Kind.Defs.read file code defs)))))
(define ($Kind.Defs.report defs names) (let ((types ($Kind.Defs.report.types defs names))) (let ((errors ($Kind.Defs.report.errors defs))) (let ((errors (let ((self2 errors)) (case (= (string-length self2) 0) (#t (let () "All terms check.")) (#f (let ((f2 (char->integer (string-ref self2 0)))(f3 (let ((_str_ self2)) (substring _str_ 1 (string-length _str_))))) errors)))))) ($String.concat types ($String.concat "\xA;" errors))))))
(define (Kind.Defs.report) (lambda (defs) (lambda (names) ($Kind.Defs.report defs names))))
(define ($Kind.Defs.report.errors defs) (let ((errors "")) (let ((errors ($List.for ($BitsMap.keys defs) errors (lambda (key) (lambda (errors) (let ((name ($Kind.Name.from_bits key))) (let ((defn ($Kind.Map.get name defs))) (let ((self5 defn)) (case (get self5 0) ('Maybe.none (let () errors)) ('Maybe.some (let ((f5 (get self5 1))) (let ((self6 f5)) (case (get self6 0) ('Kind.Def.new (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))(f9 (get self6 4))(f10 (get self6 5))(f11 (get self6 6))(f12 (get self6 7))(f13 (get self6 8))(f14 (get self6 9))) (let ((self15 f14)) (case (get self15 0) ('Kind.Status.init (let () errors)) ('Kind.Status.wait (let () errors)) ('Kind.Status.done (let ((f15 (get self15 1))) errors)) ('Kind.Status.fail (let ((f15 (get self15 1))) (let ((self16 f15)) (case (get self16 0) ('List.nil (let () errors)) ('List.cons (let ((f16 (get self16 1))(f17 (get self16 2))) (let ((name_str f9)) (let ((rel_errs ($Kind.Error.relevant f15))) (let ((errors ($List.for rel_errs errors (lambda (err) (lambda (errors) (let ((err_msg ($Kind.Error.show err defs))) (let ((ori_val ($Kind.Error.origin err))) (let ((self24 ori_val)) (case (get self24 0) ('Maybe.none (let () ($String.concat errors ($String.concat err_msg "\xA;")))) ('Maybe.some (let ((f24 (get self24 1))) (let ((self25 f24)) (case (get self25 0) ('Pair.new (let ((f25 (get self25 1))(f26 (get self25 2))) (let ((inside ($String.concat "Inside '" ($String.concat f6 "':\xA;")))) (let ((source ($Kind.Code.highlight f7 f25 f26))) ($String.concat errors ($String.concat err_msg ($String.concat inside ($String.concat source ($String.concat "\xA;" "\xA;")))))))))))))))))))))) errors)))))))))))))))))))))))))) errors)))
(define (Kind.Defs.report.errors) (lambda (defs) ($Kind.Defs.report.errors defs)))
(define ($Kind.Defs.report.types defs names) (let ((types "")) (let ((types ($List.for names types (lambda (name) (lambda (types) (let ((self3 ($Kind.Map.get name defs))) (case (get self3 0) ('Maybe.none (let () types)) ('Maybe.some (let ((f3 (get self3 1))) (let ((self4 f3)) (case (get self4 0) ('Kind.Def.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))(f7 (get self4 4))(f8 (get self4 5))(f9 (get self4 6))(f10 (get self4 7))(f11 (get self4 8))(f12 (get self4 9))) ($String.concat types ($String.concat name ($String.concat ": " ($String.concat ($Kind.Term.show f9) "\xA;"))))))))))))))))) types)))
(define (Kind.Defs.report.types) (lambda (defs) (lambda (names) ($Kind.Defs.report.types defs names))))
(define ($Kind.Def.new file code orig name term type isct arit stat) (vector 'Kind.Def.new file code orig name term type isct arit stat))
(define (Kind.Def.new) (lambda (file) (lambda (code) (lambda (orig) (lambda (name) (lambda (term) (lambda (type) (lambda (isct) (lambda (arit) (lambda (stat) ($Kind.Def.new file code orig name term type isct arit stat)))))))))))
(define ($Kind.Error) '())
(define (Kind.Error) ($Kind.Error))
(define ($Kind.Error.cant_infer origin term context) (vector 'Kind.Error.cant_infer origin term context))
(define (Kind.Error.cant_infer) (lambda (origin) (lambda (term) (lambda (context) ($Kind.Error.cant_infer origin term context)))))
(define ($Kind.Error.indirect name) (vector 'Kind.Error.indirect name))
(define (Kind.Error.indirect) (lambda (name) ($Kind.Error.indirect name)))
(define ($Kind.Error.is_goal error) (let ((self0 error)) (case (get self0 0) ('Kind.Error.type_mismatch (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) ($Bool.false))) ('Kind.Error.show_goal (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Bool.true))) ('Kind.Error.waiting (let ((f0 (get self0 1))) ($Bool.false))) ('Kind.Error.indirect (let ((f0 (get self0 1))) ($Bool.false))) ('Kind.Error.patch (let ((f0 (get self0 1))(f1 (get self0 2))) ($Bool.false))) ('Kind.Error.undefined_reference (let ((f0 (get self0 1))(f1 (get self0 2))) ($Bool.false))) ('Kind.Error.cant_infer (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Bool.false))))))
(define (Kind.Error.is_goal) (lambda (error) ($Kind.Error.is_goal error)))
(define ($Kind.Error.is_mistake error) (let ((self0 error)) (case (get self0 0) ('Kind.Error.type_mismatch (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) ($Bool.true))) ('Kind.Error.show_goal (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Bool.false))) ('Kind.Error.waiting (let ((f0 (get self0 1))) ($Bool.false))) ('Kind.Error.indirect (let ((f0 (get self0 1))) ($Bool.false))) ('Kind.Error.patch (let ((f0 (get self0 1))(f1 (get self0 2))) ($Bool.false))) ('Kind.Error.undefined_reference (let ((f0 (get self0 1))(f1 (get self0 2))) ($Bool.false))) ('Kind.Error.cant_infer (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Bool.true))))))
(define (Kind.Error.is_mistake) (lambda (error) ($Kind.Error.is_mistake error)))
(define ($Kind.Error.is_undef error) (let ((self0 error)) (case (get self0 0) ('Kind.Error.type_mismatch (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) ($Bool.false))) ('Kind.Error.show_goal (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Bool.false))) ('Kind.Error.waiting (let ((f0 (get self0 1))) ($Bool.false))) ('Kind.Error.indirect (let ((f0 (get self0 1))) ($Bool.false))) ('Kind.Error.patch (let ((f0 (get self0 1))(f1 (get self0 2))) ($Bool.false))) ('Kind.Error.undefined_reference (let ((f0 (get self0 1))(f1 (get self0 2))) ($Bool.true))) ('Kind.Error.cant_infer (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Bool.false))))))
(define (Kind.Error.is_undef) (lambda (error) ($Kind.Error.is_undef error)))
(define ($Kind.Error.origin error) (let ((self0 error)) (case (get self0 0) ('Kind.Error.type_mismatch (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) f0)) ('Kind.Error.show_goal (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Maybe.none))) ('Kind.Error.waiting (let ((f0 (get self0 1))) ($Maybe.none))) ('Kind.Error.indirect (let ((f0 (get self0 1))) ($Maybe.none))) ('Kind.Error.patch (let ((f0 (get self0 1))(f1 (get self0 2))) ($Maybe.none))) ('Kind.Error.undefined_reference (let ((f0 (get self0 1))(f1 (get self0 2))) f0)) ('Kind.Error.cant_infer (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) f0)))))
(define (Kind.Error.origin) (lambda (error) ($Kind.Error.origin error)))
(define ($Kind.Error.patch path term) (vector 'Kind.Error.patch path term))
(define (Kind.Error.patch) (lambda (path) (lambda (term) ($Kind.Error.patch path term))))
(define ($Kind.Error.relevant errors) (let ((undefs ($List.filter (Kind.Error.is_undef) errors))) (let ((mistakes ($List.filter (Kind.Error.is_mistake) errors))) (let ((goals ($List.filter (Kind.Error.is_goal) errors))) (let ((self3 undefs)) (case (get self3 0) ('List.nil (let () (let ((self3 mistakes)) (case (get self3 0) ('List.nil (let () goals)) ('List.cons (let ((f3 (get self3 1))(f4 (get self3 2))) ($List.concat ($List.cons f3 ($List.nil)) goals))))))) ('List.cons (let ((f3 (get self3 1))(f4 (get self3 2))) ($List.concat undefs goals)))))))))
(define (Kind.Error.relevant) (lambda (errors) ($Kind.Error.relevant errors)))
(define ($Kind.Error.show error defs) (let ((self0 error)) (case (get self0 0) ('Kind.Error.type_mismatch (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))) (let ((expected (let ((self4 f1)) (case (get self4 0) ('Either.left (let ((f4 (get self4 1))) f4)) ('Either.right (let ((f4 (get self4 1))) ($Kind.Term.show ($Kind.Term.normalize f4 ($Map.from_list ($List.nil)))))))))) (let ((detected (let ((self5 f2)) (case (get self5 0) ('Either.left (let ((f5 (get self5 1))) f5)) ('Either.right (let ((f5 (get self5 1))) ($Kind.Term.show ($Kind.Term.normalize f5 ($Map.from_list ($List.nil)))))))))) ($String.concat "Type mismatch.\xA;" ($String.concat "- Expected: " ($String.concat expected ($String.concat "\xA;" ($String.concat "- Detected: " ($String.concat detected ($String.concat "\xA;" (let ((self6 f3)) (case (get self6 0) ('List.nil (let () "")) ('List.cons (let ((f6 (get self6 1))(f7 (get self6 2))) ($String.concat "With context:\xA;" ($Kind.Context.show f3))))))))))))))))) ('Kind.Error.show_goal (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((goal_name ($String.concat "Goal ?" ($String.concat ($Kind.Name.show f0) ":\xA;")))) (let ((with_type (let ((self6 f3)) (case (get self6 0) ('Maybe.none (let () "")) ('Maybe.some (let ((f6 (get self6 1))) (let ((goal ($Kind.Term.expand f1 f6 defs))) ($String.concat "With type: " ($String.concat (let ((self8 f2)) (case self8 (#t (let () ($Kind.Term.show.go goal ($Maybe.some (lambda (x) x))))) (#f (let () ($Kind.Term.show goal))))) "\xA;"))))))))) (let ((with_ctxt (let ((self7 f4)) (case (get self7 0) ('List.nil (let () "")) ('List.cons (let ((f7 (get self7 1))(f8 (get self7 2))) ($String.concat "With context:\xA;" ($Kind.Context.show f4)))))))) ($String.flatten ($List.cons goal_name ($List.cons with_type ($List.cons with_ctxt ($List.nil)))))))))) ('Kind.Error.waiting (let ((f0 (get self0 1))) ($String.concat "Waiting for '" ($String.concat f0 "'.")))) ('Kind.Error.indirect (let ((f0 (get self0 1))) ($String.concat "Error on dependency '" ($String.concat f0 "'.")))) ('Kind.Error.patch (let ((f0 (get self0 1))(f1 (get self0 2))) ($String.concat "Patching: " ($Kind.Term.show f1)))) ('Kind.Error.undefined_reference (let ((f0 (get self0 1))(f1 (get self0 2))) ($String.concat "Undefined reference: " ($String.concat ($Kind.Name.show f1) "\xA;")))) ('Kind.Error.cant_infer (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((term ($Kind.Term.show f1))) (let ((context ($Kind.Context.show f2))) ($String.concat "Can't infer type of: " ($String.concat term ($String.concat "\xA;" ($String.concat "With context:\xA;" context)))))))))))
(define (Kind.Error.show) (lambda (error) (lambda (defs) ($Kind.Error.show error defs))))
(define ($Kind.Error.show_goal name dref verb goal context) (vector 'Kind.Error.show_goal name dref verb goal context))
(define (Kind.Error.show_goal) (lambda (name) (lambda (dref) (lambda (verb) (lambda (goal) (lambda (context) ($Kind.Error.show_goal name dref verb goal context)))))))
(define ($Kind.Error.type_mismatch origin expected detected context) (vector 'Kind.Error.type_mismatch origin expected detected context))
(define (Kind.Error.type_mismatch) (lambda (origin) (lambda (expected) (lambda (detected) (lambda (context) ($Kind.Error.type_mismatch origin expected detected context))))))
(define ($Kind.Error.undefined_reference origin name) (vector 'Kind.Error.undefined_reference origin name))
(define (Kind.Error.undefined_reference) (lambda (origin) (lambda (name) ($Kind.Error.undefined_reference origin name))))
(define ($Kind.Error.waiting name) (vector 'Kind.Error.waiting name))
(define (Kind.Error.waiting) (lambda (name) ($Kind.Error.waiting name)))
(define ($Kind.Letter) '())
(define (Kind.Letter) ($Kind.Letter))
(define ($Kind.MPath) '())
(define (Kind.MPath) ($Kind.MPath))
(define ($Kind.MPath.i path) ($Maybe.mapped path (Kind.Path.i)))
(define (Kind.MPath.i) (lambda (path) ($Kind.MPath.i path)))
(define ($Kind.MPath.nil) ($Maybe.some (Kind.Path.nil)))
(define (Kind.MPath.nil) ($Kind.MPath.nil))
(define ($Kind.MPath.o path) ($Maybe.mapped path (Kind.Path.o)))
(define (Kind.MPath.o) (lambda (path) ($Kind.MPath.o path)))
(define ($Kind.MPath.to_bits path) (let ((self0 path)) (case (get self0 0) ('Maybe.none (let () ($Bits.e))) ('Maybe.some (let ((f0 (get self0 1))) (f0 ($Bits.e)))))))
(define (Kind.MPath.to_bits) (lambda (path) ($Kind.MPath.to_bits path)))
(define ($Kind.Map) '())
(define (Kind.Map) ($Kind.Map))
(define ($Kind.Map.def file code orig name term type isct arit done defs) (let ((defn (((((((((Kind.Def.new) file) code) orig) name) term) type) isct) arit))) (let ((self1 done)) (case self1 (#t (let () ($Kind.Map.set name (defn ($Kind.Status.done ($Bool.false))) defs))) (#f (let () ($Kind.Map.set_if_empty name (defn ($Kind.Status.init)) defs)))))))
(define (Kind.Map.def) (lambda (file) (lambda (code) (lambda (orig) (lambda (name) (lambda (term) (lambda (type) (lambda (isct) (lambda (arit) (lambda (done) (lambda (defs) ($Kind.Map.def file code orig name term type isct arit done defs))))))))))))
(define ($Kind.Map.get name map) ($BitsMap.get ($Kind.Name.to_bits name) map))
(define (Kind.Map.get) (lambda (name) (lambda (map) ($Kind.Map.get name map))))
(define ($Kind.Map.keys xs) ($List.mapped ($Kind.Map.to_list xs) (Pair.fst)))
(define (Kind.Map.keys) (lambda (xs) ($Kind.Map.keys xs)))
(define ($Kind.Map.map fn map) ($BitsMap.map fn map))
(define (Kind.Map.map) (lambda (fn) (lambda (map) ($Kind.Map.map fn map))))
(define ($Kind.Map.new) ($BitsMap.new))
(define (Kind.Map.new) ($Kind.Map.new))
(define ($Kind.Map.set name val map) ($BitsMap.set ($Kind.Name.to_bits name) val map))
(define (Kind.Map.set) (lambda (name) (lambda (val) (lambda (map) ($Kind.Map.set name val map)))))
(define ($Kind.Map.set_if_empty name val map) ($BitsMap.set_if_empty ($Kind.Name.to_bits name) val map))
(define (Kind.Map.set_if_empty) (lambda (name) (lambda (val) (lambda (map) ($Kind.Map.set_if_empty name val map)))))
(define ($Kind.Map.to_list xs) (let ((kvs ($List.reverse ($BitsMap.to_list.go xs ($Bits.e) ($List.nil))))) ($List.mapped kvs (lambda (kv) (let ((self2 kv)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) ($Pair.new ($Kind.Name.from_bits f2) f3)))))))))
(define (Kind.Map.to_list) (lambda (xs) ($Kind.Map.to_list xs)))
(define ($Kind.Name) '())
(define (Kind.Name) ($Kind.Name))
(define ($Kind.Name.eql a b) ($String.eql a b))
(define (Kind.Name.eql) (lambda (a) (lambda (b) ($Kind.Name.eql a b))))
(define ($Kind.Name.from_bits bits) (let ((list ($Bits.chunks_of 6 bits))) (let ((name ($List.fold list ($String.nil) (lambda (bts) (lambda (name) (let ((u16 ($U16.new ($Word.from_bits 16 ($Bits.reverse bts))))) (let ((chr (let ((self4 ($U16.btw ($Nat.to_u16 0) u16 ($Nat.to_u16 25)))) (case self4 (#t (let () ($U16.add u16 ($Nat.to_u16 65)))) (#f (let () (let ((self4 ($U16.btw ($Nat.to_u16 26) u16 ($Nat.to_u16 51)))) (case self4 (#t (let () ($U16.add u16 ($Nat.to_u16 71)))) (#f (let () (let ((self4 ($U16.btw ($Nat.to_u16 52) u16 ($Nat.to_u16 61)))) (case self4 (#t (let () ($U16.sub u16 ($Nat.to_u16 4)))) (#f (let () (let ((self4 ($U16.eql ($Nat.to_u16 62) u16))) (case self4 (#t (let () ($Nat.to_u16 46))) (#f (let () ($Nat.to_u16 95))))))))))))))))))) ($String.cons chr name)))))))) name)))
(define (Kind.Name.from_bits) (lambda (bits) ($Kind.Name.from_bits bits)))
(define ($Kind.Name.is_letter chr) (let ((self0 ($U16.btw 65 chr 90))) (case self0 (#t (let () ($Bool.true))) (#f (let () (let ((self0 ($U16.btw 97 chr 122))) (case self0 (#t (let () ($Bool.true))) (#f (let () (let ((self0 ($U16.btw 48 chr 57))) (case self0 (#t (let () ($Bool.true))) (#f (let () (let ((self0 ($U16.eql 46 chr))) (case self0 (#t (let () ($Bool.true))) (#f (let () (let ((self0 ($U16.eql 95 chr))) (case self0 (#t (let () ($Bool.true))) (#f (let () (let ((self0 ($U16.eql 94 chr))) (case self0 (#t (let () ($Bool.true))) (#f (let () ($Bool.false))))))))))))))))))))))))))
(define (Kind.Name.is_letter) (lambda (chr) ($Kind.Name.is_letter chr)))
(define ($Kind.Name.read str) str)
(define (Kind.Name.read) (lambda (str) ($Kind.Name.read str)))
(define ($Kind.Name.show name) name)
(define (Kind.Name.show) (lambda (name) ($Kind.Name.show name)))
(define ($Kind.Name.to_bits name) (let ((self0 name)) (case (= (string-length self0) 0) (#t (let () ($Bits.e))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((chr f0)) (let ((u16 (let ((self3 ($U16.btw 65 chr 90))) (case self3 (#t (let () ($U16.sub chr ($Nat.to_u16 65)))) (#f (let () (let ((self3 ($U16.btw 97 chr 122))) (case self3 (#t (let () ($U16.sub chr ($Nat.to_u16 71)))) (#f (let () (let ((self3 ($U16.btw 48 chr 57))) (case self3 (#t (let () ($U16.add chr ($Nat.to_u16 4)))) (#f (let () (let ((self3 ($U16.eql 46 chr))) (case self3 (#t (let () ($Nat.to_u16 62))) (#f (let () (let ((self3 ($U16.eql 95 chr))) (case self3 (#t (let () ($Nat.to_u16 63))) (#f (let () ($Nat.to_u16 0))))))))))))))))))))))) (let ((bts (let ((self4 u16)) (case #t (#t (let ((f4 (u16-to-word self4))) ($Word.to_bits ($Word.trim 6 f4)))))))) ($Bits.concat ($Bits.reverse bts) ($Kind.Name.to_bits f1))))))))))
(define (Kind.Name.to_bits) (lambda (name) ($Kind.Name.to_bits name)))
(define ($Kind.Parser.add) (((Kind.Parser.op) "+") "Nat.add"))
(define (Kind.Parser.add) ($Kind.Parser.add))
(define ($Kind.Parser.and) (((Kind.Parser.op) "&&") "Bool.and"))
(define (Kind.Parser.and) ($Kind.Parser.and))
(define ($Kind.Parser.annotation init term) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "::")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (type) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.ann ($Bool.false) term type))))))))))
(define (Kind.Parser.annotation) (lambda (init) (lambda (term) ($Kind.Parser.annotation init term))))
(define ($Kind.Parser.application init func) ((($Monad.bind ($Parser.monad)) ((Parser.text) "(")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.until1 ($Kind.Parser.text ")") ($Kind.Parser.item ($Kind.Parser.term)))) (lambda (args) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((expr ($List.for args func (lambda (x) (lambda (f) ($Kind.Term.app f x)))))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig expr))))))))))
(define (Kind.Parser.application) (lambda (init) (lambda (func) ($Kind.Parser.application init func))))
(define ($Kind.Parser.application.erased init func) ((($Monad.bind ($Parser.monad)) (Parser.get_index)) (lambda (init) ((($Monad.bind ($Parser.monad)) ((Parser.text) "<")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.until1 ($Parser.spaces_text ">") ($Kind.Parser.item ($Kind.Parser.term)))) (lambda (args) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((expr ($List.for args func (lambda (x) (lambda (f) ($Kind.Term.app f x)))))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig expr))))))))))))
(define (Kind.Parser.application.erased) (lambda (init) (lambda (func) ($Kind.Parser.application.erased init func))))
(define ($Kind.Parser.application.hole init term) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "!")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))))))))
(define (Kind.Parser.application.hole) (lambda (init) (lambda (term) ($Kind.Parser.application.hole init term))))
(define ($Kind.Parser.apply) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "apply(")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (func) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ",")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (equa) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ")")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Equal.apply"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term func))) (let ((term ($Kind.Term.app term equa))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))))))))))))
(define (Kind.Parser.apply) ($Kind.Parser.apply))
(define ($Kind.Parser.arrow init xtyp) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "->")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.all ($Bool.false) "" "" xtyp (lambda (s) (lambda (x) body))))))))))))
(define (Kind.Parser.arrow) (lambda (init) (lambda (xtyp) ($Kind.Parser.arrow init xtyp))))
(define ($Kind.Parser.binder sep) ((($Monad.bind ($Parser.monad)) ($Parser.many1 ($Parser.first_of ($List.cons ($Kind.Parser.binder.homo sep ($Bool.true)) ($List.cons ($Kind.Parser.binder.homo sep ($Bool.false)) ($List.nil)))))) (lambda (lists) (($Monad.pure ($Parser.monad)) ($List.flatten lists)))))
(define (Kind.Parser.binder) (lambda (sep) ($Kind.Parser.binder sep)))
(define ($Kind.Parser.binder.homo sep eras) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text (let ((self0 eras)) (case self0 (#t (let () "<")) (#f (let () "(")))))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.until1 ($Kind.Parser.text (let ((self1 eras)) (case self1 (#t (let () ">")) (#f (let () ")"))))) ($Kind.Parser.item ($Kind.Parser.name_term sep)))) (lambda (bind) (($Monad.pure ($Parser.monad)) ($List.mapped bind (lambda (pair) (let ((self3 pair)) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Binder.new eras f3 f4)))))))))))))
(define (Kind.Parser.binder.homo) (lambda (sep) (lambda (eras) ($Kind.Parser.binder.homo sep eras))))
(define ($Kind.Parser.case) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "case ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.many1 ((($Monad.bind ($Parser.monad)) ($Parser.avoiding ($Kind.Parser.text "{") ($Kind.Parser.term))) (lambda (expr) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "as")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) (($Monad.pure ($Parser.monad)) name))))))))) (lambda (name) (let ((name ($Maybe.default name ($Kind.Term.extract_name expr)))) (($Monad.pure ($Parser.monad)) ($Pair.new name expr))))))))) (lambda (vals) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.case.with)) (lambda (wyth) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "{")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.until ($Kind.Parser.text "}") ($Kind.Parser.case.case))) (lambda (cses) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text "!"))) (lambda (smrt) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "default")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (term) (($Monad.pure ($Parser.monad)) term))))))) (lambda (dflt) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ($Kind.Parser.term))))) (lambda (moti) (let ((moti (let ((self9 moti)) (case (get self9 0) ('Maybe.none (let () (let ((self9 smrt)) (case (get self9 0) ('Maybe.none (let () ($Maybe.some ($Kind.Term.hol ($Bits.e))))) ('Maybe.some (let ((f9 (get self9 1))) ($Maybe.none))))))) ('Maybe.some (let ((f9 (get self9 1))) ($Maybe.some f9))))))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Parser.case.build vals wyth cses dflt moti orig))))))))))))))))))))))))
(define (Kind.Parser.case) ($Kind.Parser.case))
(define ($Kind.Parser.case.build vals wyth cses dflt moti orig) (let ((self0 vals)) (case (get self0 0) ('List.nil (let () (let ((self0 cses)) (case (get self0 0) ('List.nil (let () ($Debug.log ($String.concat "MISSING CASE" ($String.nil)) (lambda (-) ($Kind.Term.ref "missing_case"))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($Pair.snd f0))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((group ($Kind.Parser.case.group dflt cses))) (let ((name ($Pair.fst f0))) (let ((expr ($Pair.snd f0))) (let ((cses ($Kind.Map.map (lambda (cses) ($Kind.Parser.case.build f1 wyth cses dflt moti orig)) group))) ($Kind.Term.ori orig ($Kind.Term.cse ($Bits.e) expr name wyth cses moti)))))))))))
(define (Kind.Parser.case.build) (lambda (vals) (lambda (wyth) (lambda (cses) (lambda (dflt) (lambda (moti) (lambda (orig) ($Kind.Parser.case.build vals wyth cses dflt moti orig))))))))
(define ($Kind.Parser.case.case) ((($Monad.bind ($Parser.monad)) ($Parser.until ($Kind.Parser.text ":") ($Kind.Parser.name1))) (lambda (names) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (term) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ","))) (lambda (-) (($Monad.pure ($Parser.monad)) ($Pair.new names term)))))))))
(define (Kind.Parser.case.case) ($Kind.Parser.case.case))
(define ($Kind.Parser.case.group dflt cses) (let ((self0 cses)) (case (get self0 0) ('List.nil (let () (let ((self0 dflt)) (case (get self0 0) ('Maybe.none (let () ($Kind.Map.new))) ('Maybe.some (let ((f0 (get self0 1))) ($Kind.Map.set "_" ($List.cons ($Pair.new ($List.nil) f0) ($List.nil)) ($Kind.Map.new)))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((map ($Kind.Parser.case.group dflt f1))) (let ((self3 f0)) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('List.nil (let () map)) ('List.cons (let ((f5 (get self5 1))(f6 (get self5 2))) (let ((rest ($Maybe.default ($Kind.Map.get f5 map) ($List.nil)))) ($Kind.Map.set f5 ($List.cons ($Pair.new f6 f4) rest) map))))))))))))))))
(define (Kind.Parser.case.group) (lambda (dflt) (lambda (cses) ($Kind.Parser.case.group dflt cses))))
(define ($Kind.Parser.case.with) ($Parser.first_of ($List.cons ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "with ")) (lambda (-) ($Parser.many ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (type) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) (($Monad.pure ($Parser.monad)) type))))))))) (lambda (type) (($Monad.pure ($Parser.monad)) ($Kind.Ann.new name ($Kind.Term.ref name) type))))))))) ($List.cons (($Monad.pure ($Parser.monad)) ($List.nil)) ($List.nil)))))
(define (Kind.Parser.case.with) ($Kind.Parser.case.with))
(define ($Kind.Parser.chain) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "chain(")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (eql0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ",")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (eql1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ")")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Equal.chain"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term eql0))) (let ((term ($Kind.Term.app term eql1))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))))))))))))
(define (Kind.Parser.chain) ($Kind.Parser.chain))
(define ($Kind.Parser.char) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "'")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.char.single)) (lambda (chrx) ((($Monad.bind ($Parser.monad)) ((Parser.text) "'")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.chr chrx))))))))))))))
(define (Kind.Parser.char) ($Kind.Parser.char))
(define ($Kind.Parser.char.single) ($Parser.first_of ($List.cons ($Parser.first_of ($List.mapped ($Kind.Code.escapes) (lambda (esc) (let ((self1 esc)) (case (get self1 0) ('Pair.new (let ((f1 (get self1 1))(f2 (get self1 2))) ((($Monad.bind ($Parser.monad)) ((Parser.text) f1)) (lambda (-) (($Monad.pure ($Parser.monad)) f2)))))))))) ($List.cons (Parser.one) ($List.nil)))))
(define (Kind.Parser.char.single) ($Kind.Parser.char.single))
(define ($Kind.Parser.concat init lst0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "++")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (lst1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "List.concat"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term lst0))) (let ((term ($Kind.Term.app term lst1))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))
(define (Kind.Parser.concat) (lambda (init) (lambda (lst0) ($Kind.Parser.concat init lst0))))
(define ($Kind.Parser.cons init head) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "&")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (tail) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "List.cons"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term head))) (let ((term ($Kind.Term.app term tail))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))
(define (Kind.Parser.cons) (lambda (init) (lambda (head) ($Kind.Parser.cons init head))))
(define ($Kind.Parser.constructor namespace) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.binder ":"))) (lambda (args) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "~")) (lambda (-) ($Kind.Parser.binder "="))))) (lambda (inds) (let ((args ($Maybe.default args ($List.nil)))) (let ((inds ($Maybe.default inds ($List.nil)))) (($Monad.pure ($Parser.monad)) ($Kind.Constructor.new name args inds)))))))))))
(define (Kind.Parser.constructor) (lambda (namespace) ($Kind.Parser.constructor namespace)))
(define ($Kind.Parser.datatype) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "type ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.binder ":"))) (lambda (pars) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "~")) (lambda (-) ($Kind.Parser.binder ":"))))) (lambda (inds) (let ((pars ($Maybe.default pars ($List.nil)))) (let ((inds ($Maybe.default inds ($List.nil)))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "{")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.until ($Kind.Parser.text "}") ($Kind.Parser.item ($Kind.Parser.constructor name)))) (lambda (ctrs) (($Monad.pure ($Parser.monad)) ($Kind.Datatype.new name pars inds ctrs)))))))))))))))))
(define (Kind.Parser.datatype) ($Kind.Parser.datatype))
(define ($Kind.Parser.def) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "def ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "=")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (expr) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.def name expr (lambda (x) body)))))))))))))))))))))
(define (Kind.Parser.def) ($Kind.Parser.def))
(define ($Kind.Parser.default init val0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "<>")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (val1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Maybe.default"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term val0))) (let ((term ($Kind.Term.app term val1))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))
(define (Kind.Parser.default) (lambda (init) (lambda (val0) ($Kind.Parser.default init val0))))
(define ($Kind.Parser.div) (((Kind.Parser.op) "/") "Nat.div"))
(define (Kind.Parser.div) ($Kind.Parser.div))
(define ($Kind.Parser.do) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text "do "))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ((Parser.text) " {")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.do.statements name)) (lambda (term) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "}")) (lambda (-) (($Monad.pure ($Parser.monad)) term))))))))))))
(define (Kind.Parser.do) ($Kind.Parser.do))
(define ($Kind.Parser.do.statements monad_name) ($Parser.first_of ($List.cons ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Parser.first_of ($List.cons ($Kind.Parser.text "var ") ($List.cons ($Kind.Parser.text "get ") ($List.nil))))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "=")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (expr) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.do.statements monad_name)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.app ($Kind.Term.ref "Monad.bind") ($Kind.Term.ref monad_name)))) (let ((term ($Kind.Term.app term ($Kind.Term.ref ($String.concat monad_name ".monad"))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term expr))) (let ((term ($Kind.Term.app term ($Kind.Term.lam name (lambda (x) body))))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))))) ($List.cons ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "let ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "=")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (expr) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.do.statements monad_name)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.let name expr (lambda (x) body)))))))))))))))))))) ($List.cons ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "return ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (expr) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.app ($Kind.Term.ref "Monad.pure") ($Kind.Term.ref monad_name)))) (let ((term ($Kind.Term.app term ($Kind.Term.ref ($String.concat monad_name ".monad"))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term expr))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))) ($List.cons ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (expr) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.do.statements monad_name)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.app ($Kind.Term.ref "Monad.bind") ($Kind.Term.ref monad_name)))) (let ((term ($Kind.Term.app term ($Kind.Term.ref ($String.concat monad_name ".monad"))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term expr))) (let ((term ($Kind.Term.app term ($Kind.Term.lam "" (lambda (x) body))))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))) ($List.cons ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (expr) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) (($Monad.pure ($Parser.monad)) expr))))) ($List.nil))))))))
(define (Kind.Parser.do.statements) (lambda (monad_name) ($Kind.Parser.do.statements monad_name)))
(define ($Kind.Parser.eql) (((Kind.Parser.op) "=?") "Nat.eql"))
(define (Kind.Parser.eql) ($Kind.Parser.eql))
(define ($Kind.Parser.equality init val0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "==")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (val1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Equal"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term val0))) (let ((term ($Kind.Term.app term val1))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))
(define (Kind.Parser.equality) (lambda (init) (lambda (val0) ($Kind.Parser.equality init val0))))
(define ($Kind.Parser.file file code defs) ((($Monad.bind ($Parser.monad)) (Parser.is_eof)) (lambda (stop) (let ((self1 stop)) (case self1 (#t (let () (($Monad.pure ($Parser.monad)) defs))) (#f (let () ((($Monad.bind ($Parser.monad)) ($Parser.first_of ($List.cons ($Kind.Parser.file.def file code defs) ($List.cons ($Kind.Parser.file.adt file code defs) ($List.cons ($Kind.Parser.file.end file code defs) ($List.nil)))))) (lambda (defs) ($Kind.Parser.file file code defs))))))))))
(define (Kind.Parser.file) (lambda (file) (lambda (code) (lambda (defs) ($Kind.Parser.file file code defs)))))
(define ($Kind.Parser.file.adt file code defs) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.datatype)) (lambda (adt) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((self3 adt)) (case (get self3 0) ('Kind.Datatype.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))) (let ((term ($Kind.Datatype.build_term adt))) (let ((term ($Kind.Term.bind ($List.nil) (lambda (x) ($Bits.i x)) term))) (let ((type ($Kind.Datatype.build_type adt))) (let ((type ($Kind.Term.bind ($List.nil) (lambda (x) ($Bits.o x)) type))) (let ((arit ($Nat.add ($List.length f4) ($List.length f5)))) (let ((defs ($Kind.Map.def file code orig f3 term type ($Bool.false) arit ($Bool.false) defs))) (let ((defs ($List.fold f6 defs (lambda (ctr) (lambda (defs) (let ((typ_name f3)) (let ((ctr_arit ($Nat.add arit ($List.length (let ((self16 ctr)) (case (get self16 0) ('Kind.Constructor.new (let ((f16 (get self16 1))(f17 (get self16 2))(f18 (get self16 3))) f17)))))))) (let ((ctr_name ($String.flatten ($List.cons typ_name ($List.cons ($Kind.Name.read ".") ($List.cons (let ((self17 ctr)) (case (get self17 0) ('Kind.Constructor.new (let ((f17 (get self17 1))(f18 (get self17 2))(f19 (get self17 3))) f17)))) ($List.nil))))))) (let ((ctr_term ($Kind.Constructor.build_term adt ctr))) (let ((ctr_term ($Kind.Term.bind ($List.nil) (lambda (x) ($Bits.i x)) ctr_term))) (let ((ctr_type ($Kind.Constructor.build_type adt ctr))) (let ((ctr_type ($Kind.Term.bind ($List.nil) (lambda (x) ($Bits.o x)) ctr_type))) ($Kind.Map.def file code orig ctr_name ctr_term ctr_type ($Bool.true) ctr_arit ($Bool.false) defs))))))))))))) (($Monad.pure ($Parser.monad)) defs)))))))))))))))))))
(define (Kind.Parser.file.adt) (lambda (file) (lambda (code) (lambda (defs) ($Kind.Parser.file.adt file code defs)))))
(define ($Kind.Parser.file.def file code defs) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Parser.many ($Kind.Parser.binder ":"))) (lambda (args) (let ((args ($List.flatten args))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (type) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (term) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((arit ($List.length args))) (let ((type ($Kind.Parser.make_forall args type))) (let ((term ($Kind.Parser.make_lambda ($List.mapped args (lambda (x) (let ((self11 x)) (case (get self11 0) ('Kind.Binder.new (let ((f11 (get self11 1))(f12 (get self11 2))(f13 (get self11 3))) f12)))))) term))) (let ((type ($Kind.Term.bind ($List.nil) (lambda (x) ($Bits.i x)) type))) (let ((term ($Kind.Term.bind ($List.nil) (lambda (x) ($Bits.o x)) term))) (let ((defs ($Kind.Map.def file code orig name term type ($Bool.false) arit ($Bool.false) defs))) (($Monad.pure ($Parser.monad)) defs)))))))))))))))))))))))
(define (Kind.Parser.file.def) (lambda (file) (lambda (code) (lambda (defs) ($Kind.Parser.file.def file code defs)))))
(define ($Kind.Parser.file.end file code defs) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.spaces)) (lambda (-) ((($Monad.bind ($Parser.monad)) (Parser.eof)) (lambda (-) (($Monad.pure ($Parser.monad)) defs))))))
(define (Kind.Parser.file.end) (lambda (file) (lambda (code) (lambda (defs) ($Kind.Parser.file.end file code defs)))))
(define ($Kind.Parser.float.sign idx code) (let ((self0 code)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.error idx code "Expected '+' or '-'."))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((sidx ($Nat.succ idx))) (let ((self3 ($Bool.or ($U16.eql f0 43) ($U16.eql f0 45)))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 f0))) (#f (let () ($Parser.Reply.error idx code "Expected '+' ou '-'.")))))))))))
(define (Kind.Parser.float.sign) (lambda (idx) (lambda (code) ($Kind.Parser.float.sign idx code))))
(define ($Kind.Parser.float.str_digit idx code) (let ((self0 code)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.error idx code "Not a digit."))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((sidx ($Nat.succ idx))) (let ((digits ($List.cons 48 ($List.cons 49 ($List.cons 50 ($List.cons 51 ($List.cons 52 ($List.cons 52 ($List.cons 53 ($List.cons 54 ($List.cons 55 ($List.cons 56 ($List.cons 57 ($List.nil)))))))))))))) (let ((self4 ($List.any ((U16.eql) f0) digits))) (case self4 (#t (let () ($Parser.Reply.value sidx f1 f0))) (#f (let () ($Parser.Reply.error idx code "Not a digit."))))))))))))
(define (Kind.Parser.float.str_digit) (lambda (idx) (lambda (code) ($Kind.Parser.float.str_digit idx code))))
(define ($Kind.Parser.float.32) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) (Kind.Parser.float.sign))) (lambda (sign) (let ((sign ($Maybe.default sign 43))) ((($Monad.bind ($Parser.monad)) ($Parser.many1 (Kind.Parser.float.str_digit))) (lambda (digits) ((($Monad.bind ($Parser.monad)) ((Parser.text) ".")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.many1 (Kind.Parser.float.str_digit))) (lambda (frac) ((($Monad.bind ($Parser.monad)) ((Parser.text) "#32")) (lambda (-) (let ((float_str ($Kind.Term.str ($String.concat ($String.cons sign ($String.from_list digits)) ($String.concat "." ($String.from_list frac)))))) (let ((conv ($Kind.Term.ref "F32.parse"))) (let ((term ($Kind.Term.app conv float_str))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))
(define (Kind.Parser.float.32) ($Kind.Parser.float.32))
(define ($Kind.Parser.float.64) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) (Kind.Parser.float.sign))) (lambda (sign) (let ((sign ($Maybe.default sign 43))) ((($Monad.bind ($Parser.monad)) ($Parser.many1 (Kind.Parser.float.str_digit))) (lambda (digits) ((($Monad.bind ($Parser.monad)) ((Parser.text) ".")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.many1 (Kind.Parser.float.str_digit))) (lambda (frac) ((($Monad.bind ($Parser.monad)) ((Parser.text) "#64")) (lambda (-) (let ((float_str ($Kind.Term.str ($String.concat ($String.cons sign ($String.from_list digits)) ($String.concat "." ($String.from_list frac)))))) (let ((conv ($Kind.Term.ref "F64.parse"))) (let ((term ($Kind.Term.app conv float_str))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))
(define (Kind.Parser.float.64) ($Kind.Parser.float.64))
(define ($Kind.Parser.forall) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name)) (lambda (self) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.binder ":")) (lambda (bind) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text "->"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) (let ((term ($List.fold bind body (lambda (x) (lambda (t) (let ((self7 x)) (case (get self7 0) ('Kind.Binder.new (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) ($Kind.Term.all f7 "" f8 f9 (lambda (s) (lambda (x) t)))))))))))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) (let ((self7 term)) (case (get self7 0) ('Kind.Term.var (let ((f7 (get self7 1))(f8 (get self7 2))) term)) ('Kind.Term.ref (let ((f7 (get self7 1))) term)) ('Kind.Term.typ (let () term)) ('Kind.Term.all (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))) ($Kind.Term.ori orig ($Kind.Term.all f7 self f9 f10 f11)))) ('Kind.Term.lam (let ((f7 (get self7 1))(f8 (get self7 2))) term)) ('Kind.Term.app (let ((f7 (get self7 1))(f8 (get self7 2))) term)) ('Kind.Term.let (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) term)) ('Kind.Term.def (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) term)) ('Kind.Term.ann (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) term)) ('Kind.Term.gol (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) term)) ('Kind.Term.hol (let ((f7 (get self7 1))) term)) ('Kind.Term.nat (let ((f7 (get self7 1))) term)) ('Kind.Term.chr (let ((f7 (get self7 1))) term)) ('Kind.Term.str (let ((f7 (get self7 1))) term)) ('Kind.Term.cse (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))(f12 (get self7 6))) term)) ('Kind.Term.ori (let ((f7 (get self7 1))(f8 (get self7 2))) term)))))))))))))))))))
(define (Kind.Parser.forall) ($Kind.Parser.forall))
(define ($Kind.Parser.get) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "let ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "{")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name)) (lambda (nam0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ",")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name)) (lambda (nam1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "}")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "=")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (expr) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term expr)) (let ((term ($Kind.Term.app term ($Kind.Term.lam "" (lambda (x) ($Kind.Term.hol ($Bits.e))))))) (let ((term ($Kind.Term.app term ($Kind.Term.lam nam0 (lambda (x) ($Kind.Term.lam nam1 (lambda (y) body))))))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))))))))))))))))))
(define (Kind.Parser.get) ($Kind.Parser.get))
(define ($Kind.Parser.getwhile) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text "let "))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "{")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name)) (lambda (nam0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ",")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name)) (lambda (nam1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "}")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "=")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "while ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (cond) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (loop) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((moti ($Kind.Term.lam "" (lambda (x) ($Kind.Term.hol ($Bits.e)))))) (let ((term ($Kind.Term.ref "Function.while"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((init ($Kind.Term.ref "Pair.new"))) (let ((init ($Kind.Term.app init ($Kind.Term.hol ($Bits.e))))) (let ((init ($Kind.Term.app init ($Kind.Term.hol ($Bits.e))))) (let ((init ($Kind.Term.app init ($Kind.Term.ref nam0)))) (let ((init ($Kind.Term.app init ($Kind.Term.ref nam1)))) (let ((term ($Kind.Term.app term init))) (let ((term ($Kind.Term.app term ($Kind.Term.lam "s" (lambda (s) ($Kind.Term.app ($Kind.Term.app s moti) ($Kind.Term.lam nam0 (lambda (x) ($Kind.Term.lam nam1 (lambda (y) cond)))))))))) (let ((term ($Kind.Term.app term ($Kind.Term.lam "s" (lambda (s) ($Kind.Term.app ($Kind.Term.app s moti) ($Kind.Term.lam nam0 (lambda (x) ($Kind.Term.lam nam1 (lambda (y) loop)))))))))) (let ((term ($Kind.Term.app ($Kind.Term.app term moti) ($Kind.Term.lam nam0 (lambda (x) ($Kind.Term.lam nam1 (lambda (y) body))))))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))))))))))))))))))))))))))
(define (Kind.Parser.getwhile) ($Kind.Parser.getwhile))
(define ($Kind.Parser.getwhile.with) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "while ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (cond) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "with ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "{")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name)) (lambda (nam0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ",")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name)) (lambda (nam1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "}")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (loop) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((moti ($Kind.Term.lam "" (lambda (x) ($Kind.Term.hol ($Bits.e)))))) (let ((term ($Kind.Term.ref "Function.while"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((init ($Kind.Term.ref "Pair.new"))) (let ((init ($Kind.Term.app init ($Kind.Term.hol ($Bits.e))))) (let ((init ($Kind.Term.app init ($Kind.Term.hol ($Bits.e))))) (let ((init ($Kind.Term.app init ($Kind.Term.ref nam0)))) (let ((init ($Kind.Term.app init ($Kind.Term.ref nam1)))) (let ((term ($Kind.Term.app term init))) (let ((term ($Kind.Term.app term ($Kind.Term.lam "s" (lambda (s) ($Kind.Term.app ($Kind.Term.app s moti) ($Kind.Term.lam nam0 (lambda (x) ($Kind.Term.lam nam1 (lambda (y) cond)))))))))) (let ((term ($Kind.Term.app term ($Kind.Term.lam "s" (lambda (s) ($Kind.Term.app ($Kind.Term.app s moti) ($Kind.Term.lam nam0 (lambda (x) ($Kind.Term.lam nam1 (lambda (y) loop)))))))))) (let ((term ($Kind.Term.app ($Kind.Term.app term moti) ($Kind.Term.lam nam0 (lambda (x) ($Kind.Term.lam nam1 (lambda (y) body))))))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))))))))))))))))))))))))
(define (Kind.Parser.getwhile.with) ($Kind.Parser.getwhile.with))
(define ($Kind.Parser.get.omit) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "{")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name)) (lambda (nam0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ",")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name)) (lambda (nam1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "}")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "= ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (expr) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term expr)) (let ((term ($Kind.Term.app term ($Kind.Term.lam "" (lambda (x) ($Kind.Term.hol ($Bits.e))))))) (let ((term ($Kind.Term.app term ($Kind.Term.lam nam0 (lambda (x) ($Kind.Term.lam nam1 (lambda (y) body))))))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))))))))))))))))
(define (Kind.Parser.get.omit) ($Kind.Parser.get.omit))
(define ($Kind.Parser.goal) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "?")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Parser.many ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "-")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.nat)) (lambda (nat) (let ((bits ($Bits.reverse ($Bits.tail ($Bits.reverse ($Nat.to_bits nat)))))) (($Monad.pure ($Parser.monad)) bits)))))))) (lambda (dref) ((($Monad.bind ($Parser.monad)) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ((Parser.text) "-"))) (lambda (verb) (($Monad.pure ($Parser.monad)) ($Maybe.is_some verb))))) (lambda (verb) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.gol name dref verb))))))))))))))))
(define (Kind.Parser.goal) ($Kind.Parser.goal))
(define ($Kind.Parser.goal_rewrite) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "rewrite ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "in")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (type) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "with")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (iseq) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((moti ($Kind.Term.lam name (lambda (s) ($Kind.Term.lam "" (lambda (x) type)))))) (let ((term ($Kind.Term.ref "Equal.mirror"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term iseq))) (let ((term ($Kind.Term.app term moti))) (let ((term ($Kind.Term.app term body))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))))))))))
(define (Kind.Parser.goal_rewrite) ($Kind.Parser.goal_rewrite))
(define ($Kind.Parser.gte) (((Kind.Parser.op) ">=?") "Nat.gte"))
(define (Kind.Parser.gte) ($Kind.Parser.gte))
(define ($Kind.Parser.gtn) (((Kind.Parser.op) ">?") "Nat.gtn"))
(define (Kind.Parser.gtn) ($Kind.Parser.gtn))
(define ($Kind.Parser.hole) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "_")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.hol ($Bits.e)))))))))))
(define (Kind.Parser.hole) ($Kind.Parser.hole))
(define ($Kind.Parser.if) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "if ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (cond) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "then")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (tcse) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "else")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (fcse) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term cond)) (let ((term ($Kind.Term.app term ($Kind.Term.lam "" (lambda (x) ($Kind.Term.hol ($Bits.e))))))) (let ((term ($Kind.Term.app term tcse))) (let ((term ($Kind.Term.app term fcse))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))))
(define (Kind.Parser.if) ($Kind.Parser.if))
(define ($Kind.Parser.inequality init val0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "!=")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (val1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Equal"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term val0))) (let ((term ($Kind.Term.app term val1))) (let ((term ($Kind.Term.app ($Kind.Term.ref "Not") term))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))
(define (Kind.Parser.inequality) (lambda (init) (lambda (val0) ($Kind.Parser.inequality init val0))))
(define ($Kind.Parser.init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.spaces)) (lambda (-) ((($Monad.bind ($Parser.monad)) (Parser.get_index)) (lambda (from) (($Monad.pure ($Parser.monad)) from))))))
(define (Kind.Parser.init) ($Kind.Parser.init))
(define ($Kind.Parser.int) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.spaces)) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.first_of ($List.cons ($Kind.Parser.int_pos) ($List.cons ($Kind.Parser.int_neg) ($List.nil))))) (lambda (sgn_num) (let ((term (let ((self3 sgn_num)) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((ret ($Kind.Term.ref "Int.from_nat"))) (let ((ret ($Kind.Term.app ret ($Kind.Term.nat f4)))) (let ((self7 f3)) (case self7 (#t (let () ret)) (#f (let () (let ((inv ($Kind.Term.ref "Int.neg"))) ($Kind.Term.app inv ret)))))))))))))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))
(define (Kind.Parser.int) ($Kind.Parser.int))
(define ($Kind.Parser.int_neg) ((($Monad.bind ($Parser.monad)) ((Parser.text) "-")) (lambda (sgn) ((($Monad.bind ($Parser.monad)) ($Parser.many1 (Parser.digit))) (lambda (digits) (($Monad.pure ($Parser.monad)) ($Pair.new ($Bool.false) ($Nat.from_base 10 digits))))))))
(define (Kind.Parser.int_neg) ($Kind.Parser.int_neg))
(define ($Kind.Parser.int_pos) ((($Monad.bind ($Parser.monad)) ((Parser.text) "+")) (lambda (sgn) ((($Monad.bind ($Parser.monad)) ($Parser.many1 (Parser.digit))) (lambda (digits) (($Monad.pure ($Parser.monad)) ($Pair.new ($Bool.true) ($Nat.from_base 10 digits))))))))
(define (Kind.Parser.int_pos) ($Kind.Parser.int_pos))
(define ($Kind.Parser.item parser) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.spaces)) (lambda (-) ((($Monad.bind ($Parser.monad)) parser) (lambda (value) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ","))) (lambda (-) (($Monad.pure ($Parser.monad)) value))))))))
(define (Kind.Parser.item) (lambda (parser) ($Kind.Parser.item parser)))
(define ($Kind.Parser.lambda) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "(")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.until1 ($Kind.Parser.text ")") ($Kind.Parser.item ($Kind.Parser.name1)))) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((expr ($Kind.Parser.make_lambda name body))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig expr))))))))))))))
(define (Kind.Parser.lambda) ($Kind.Parser.lambda))
(define ($Kind.Parser.lambda.erased) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "<")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.until1 ($Kind.Parser.text ">") ($Kind.Parser.item ($Kind.Parser.name1)))) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((expr ($Kind.Parser.make_lambda name body))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig expr))))))))))))))
(define (Kind.Parser.lambda.erased) ($Kind.Parser.lambda.erased))
(define ($Kind.Parser.lambda.nameless) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "()")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((expr ($Kind.Term.lam "" (lambda (x) body)))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig expr))))))))))))
(define (Kind.Parser.lambda.nameless) ($Kind.Parser.lambda.nameless))
(define ($Kind.Parser.left) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "left(")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (expr) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ")")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Either.left"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term expr))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))
(define (Kind.Parser.left) ($Kind.Parser.left))
(define ($Kind.Parser.let) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "let ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "=")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (expr) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.let name expr (lambda (x) body)))))))))))))))))))))
(define (Kind.Parser.let) ($Kind.Parser.let))
(define ($Kind.Parser.letforin) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "let ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "=")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "for ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (elem) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "in")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (list) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (loop) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "List.for"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term list))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.ref name)))) (let ((lamb ($Kind.Term.lam elem (lambda (i) ($Kind.Term.lam name (lambda (x) loop)))))) (let ((term ($Kind.Term.app term lamb))) (let ((term ($Kind.Term.let name term (lambda (x) body)))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))))))))))))))))))
(define (Kind.Parser.letforin) ($Kind.Parser.letforin))
(define ($Kind.Parser.letforin.with) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "for ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (elem) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "in")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (list) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "with ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (loop) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "List.for"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term list))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.ref name)))) (let ((lamb ($Kind.Term.lam elem (lambda (i) ($Kind.Term.lam name (lambda (x) loop)))))) (let ((term ($Kind.Term.app term lamb))) (let ((term ($Kind.Term.let name term (lambda (x) body)))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))))))))))))))))
(define (Kind.Parser.letforin.with) ($Kind.Parser.letforin.with))
(define ($Kind.Parser.letforrange.nat) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "let ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "=")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "for ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (elem) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "from")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (idx0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "to")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (idx1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (loop) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Nat.for"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.ref name)))) (let ((term ($Kind.Term.app term idx0))) (let ((term ($Kind.Term.app term idx1))) (let ((lamb ($Kind.Term.lam elem (lambda (e) ($Kind.Term.lam name (lambda (s) loop)))))) (let ((term ($Kind.Term.app term lamb))) (let ((term ($Kind.Term.let name term (lambda (x) body)))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))))))))))))))))))))))
(define (Kind.Parser.letforrange.nat) ($Kind.Parser.letforrange.nat))
(define ($Kind.Parser.letforrange.nat.with) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "for ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (elem) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "from")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (idx0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "to")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (idx1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "with ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (loop) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Nat.for"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.ref name)))) (let ((term ($Kind.Term.app term idx0))) (let ((term ($Kind.Term.app term idx1))) (let ((lamb ($Kind.Term.lam elem (lambda (e) ($Kind.Term.lam name (lambda (s) loop)))))) (let ((term ($Kind.Term.app term lamb))) (let ((term ($Kind.Term.let name term (lambda (x) body)))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))))))))))))))))))))
(define (Kind.Parser.letforrange.nat.with) ($Kind.Parser.letforrange.nat.with))
(define ($Kind.Parser.letforrange.u32) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "let ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "=")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "for ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (elem) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "U32")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "from")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (idx0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "to")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (idx1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (loop) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "U32.for"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.ref name)))) (let ((term ($Kind.Term.app term idx0))) (let ((term ($Kind.Term.app term idx1))) (let ((lamb ($Kind.Term.lam elem (lambda (e) ($Kind.Term.lam name (lambda (s) loop)))))) (let ((term ($Kind.Term.app term lamb))) (let ((term ($Kind.Term.let name term (lambda (x) body)))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))))))))))))))))))))))))))
(define (Kind.Parser.letforrange.u32) ($Kind.Parser.letforrange.u32))
(define ($Kind.Parser.letforrange.u32.with) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "for ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (elem) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "U32")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "from")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (idx0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "to")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (idx1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "with ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (loop) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "U32.for"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.ref name)))) (let ((term ($Kind.Term.app term idx0))) (let ((term ($Kind.Term.app term idx1))) (let ((lamb ($Kind.Term.lam elem (lambda (e) ($Kind.Term.lam name (lambda (s) loop)))))) (let ((term ($Kind.Term.app term lamb))) (let ((term ($Kind.Term.let name term (lambda (x) body)))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))))))))))))))))))))))))
(define (Kind.Parser.letforrange.u32.with) ($Kind.Parser.letforrange.u32.with))
(define ($Kind.Parser.letter idx code) (let ((self0 code)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.error idx code "Unexpected eof."))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 ($Kind.Name.is_letter f0))) (case self2 (#t (let () ($Parser.Reply.value ($Nat.succ idx) f1 f0))) (#f (let () ($Parser.Reply.error idx code "Expected letter."))))))))))
(define (Kind.Parser.letter) (lambda (idx) (lambda (code) ($Kind.Parser.letter idx code))))
(define ($Kind.Parser.letwhile) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "let ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "=")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "while ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (cond) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (loop) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Function.while"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.ref name)))) (let ((term ($Kind.Term.app term ($Kind.Term.lam name (lambda (s) cond))))) (let ((term ($Kind.Term.app term ($Kind.Term.lam name (lambda (s) loop))))) (let ((term ($Kind.Term.let name term (lambda (x) body)))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))))))))))))
(define (Kind.Parser.letwhile) ($Kind.Parser.letwhile))
(define ($Kind.Parser.letwhile.with) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "while ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (cond) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "with ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (loop) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Function.while"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.ref name)))) (let ((term ($Kind.Term.app term ($Kind.Term.lam name (lambda (s) cond))))) (let ((term ($Kind.Term.app term ($Kind.Term.lam name (lambda (s) loop))))) (let ((term ($Kind.Term.let name term (lambda (x) body)))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))))))))))
(define (Kind.Parser.letwhile.with) ($Kind.Parser.letwhile.with))
(define ($Kind.Parser.let.omit) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "= ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (expr) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (body) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.let name expr (lambda (x) body)))))))))))))))))))
(define (Kind.Parser.let.omit) ($Kind.Parser.let.omit))
(define ($Kind.Parser.list) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "[")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.until ($Kind.Parser.text "]") ($Kind.Parser.item ($Kind.Parser.term)))) (lambda (vals) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($List.fold vals ($Kind.Term.ori orig ($Kind.Term.app ($Kind.Term.ref ($Kind.Name.read "List.nil")) ($Kind.Term.hol ($Bits.e)))) (lambda (x) (lambda (xs) (let ((term ($Kind.Term.ref ($Kind.Name.read "List.cons")))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term x))) (let ((term ($Kind.Term.app term xs))) ($Kind.Term.ori orig term))))))))))))))))))
(define (Kind.Parser.list) ($Kind.Parser.list))
(define ($Kind.Parser.list_get init list) ((($Monad.bind ($Parser.monad)) ((Parser.text) "[")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (indx) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "]")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "List.get"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term indx))) (let ((term ($Kind.Term.app term list))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))
(define (Kind.Parser.list_get) (lambda (init) (lambda (list) ($Kind.Parser.list_get init list))))
(define ($Kind.Parser.list_set init list) ((($Monad.bind ($Parser.monad)) ((Parser.text) "[")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (indx) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "]")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "<-")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (xval) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "List.set"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term indx))) (let ((term ($Kind.Term.app term xval))) (let ((term ($Kind.Term.app term list))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))))))))
(define (Kind.Parser.list_set) (lambda (init) (lambda (list) ($Kind.Parser.list_set init list))))
(define ($Kind.Parser.log) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "log(")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.until ($Kind.Parser.text ")") ($Kind.Parser.item ($Kind.Parser.term)))) (lambda (strs) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (cont) (let ((term ($Kind.Term.ref "Debug.log"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((args ($List.fold strs ($Kind.Term.ref "String.nil") (lambda (x) (lambda (xs) (let ((arg ($Kind.Term.ref "String.concat"))) (let ((arg ($Kind.Term.app arg x))) (let ((arg ($Kind.Term.app arg xs))) arg)))))))) (let ((term ($Kind.Term.app term args))) (let ((term ($Kind.Term.app term ($Kind.Term.lam "" (lambda (x) cont))))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))))))
(define (Kind.Parser.log) ($Kind.Parser.log))
(define ($Kind.Parser.lte) (((Kind.Parser.op) "<=?") "Nat.lte"))
(define (Kind.Parser.lte) ($Kind.Parser.lte))
(define ($Kind.Parser.ltn) (((Kind.Parser.op) "<?") "Nat.ltn"))
(define (Kind.Parser.ltn) ($Kind.Parser.ltn))
(define ($Kind.Parser.machine_integer.signed size) (let ((size_str ($Nat.show size))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.spaces)) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.int)) (lambda (intx) ((($Monad.bind ($Parser.monad)) ((Parser.text) ($String.concat "#" size_str))) (lambda (-) (let ((term ($Kind.Term.ref ($String.concat "Int.to_i" size_str)))) (let ((term ($Kind.Term.app term intx))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))))
(define (Kind.Parser.machine_integer.signed) (lambda (size) ($Kind.Parser.machine_integer.signed size)))
(define ($Kind.Parser.machine_integer.unsigned size) (let ((size_str ($Nat.show size))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.spaces)) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.nat)) (lambda (natx) ((($Monad.bind ($Parser.monad)) ((Parser.text) ($String.concat "#" ($Nat.show size)))) (lambda (-) (let ((term ($Kind.Term.ref ($String.concat "Nat.to_u" ($Nat.show size))))) (let ((term ($Kind.Term.app term natx))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))))
(define (Kind.Parser.machine_integer.unsigned) (lambda (size) ($Kind.Parser.machine_integer.unsigned size)))
(define ($Kind.Parser.make_forall binds body) (let ((self0 binds)) (case (get self0 0) ('List.nil (let () body)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Binder.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all f2 "" f3 f4 (lambda (s) (lambda (x) ($Kind.Parser.make_forall f1 body)))))))))))))
(define (Kind.Parser.make_forall) (lambda (binds) (lambda (body) ($Kind.Parser.make_forall binds body))))
(define ($Kind.Parser.make_lambda names body) (let ((self0 names)) (case (get self0 0) ('List.nil (let () body)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.lam f0 (lambda (x) ($Kind.Parser.make_lambda f1 body))))))))
(define (Kind.Parser.make_lambda) (lambda (names) (lambda (body) ($Kind.Parser.make_lambda names body))))
(define ($Kind.Parser.map) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "{")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.until ($Kind.Parser.text "}") ($Kind.Parser.item ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (key) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (val) (($Monad.pure ($Parser.monad)) ($Pair.new key val))))))))))) (lambda (vals) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((list ($List.fold vals ($Kind.Term.ori orig ($Kind.Term.app ($Kind.Term.ref "List.nil") ($Kind.Term.hol ($Bits.e)))) (lambda (kv) (lambda (xs) (let ((self6 kv)) (case (get self6 0) ('Pair.new (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((pair ($Kind.Term.ref "Pair.new"))) (let ((pair ($Kind.Term.app pair ($Kind.Term.hol ($Bits.e))))) (let ((pair ($Kind.Term.app pair ($Kind.Term.hol ($Bits.e))))) (let ((pair ($Kind.Term.app pair f6))) (let ((pair ($Kind.Term.app pair f7))) (let ((term ($Kind.Term.ref "List.cons"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term pair))) (let ((term ($Kind.Term.app term xs))) ($Kind.Term.ori orig term))))))))))))))))))) (let ((term ($Kind.Term.ref "Map.from_list"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term list))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))
(define (Kind.Parser.map) ($Kind.Parser.map))
(define ($Kind.Parser.map_get init map) ((($Monad.bind ($Parser.monad)) ((Parser.text) "{")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (indx) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "}")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Map.get"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term indx))) (let ((term ($Kind.Term.app term map))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))
(define (Kind.Parser.map_get) (lambda (init) (lambda (map) ($Kind.Parser.map_get init map))))
(define ($Kind.Parser.map_set init map) ((($Monad.bind ($Parser.monad)) ((Parser.text) "{")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (indx) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "}")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "<-")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (xval) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Map.set"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term indx))) (let ((term ($Kind.Term.app term xval))) (let ((term ($Kind.Term.app term map))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))))))))
(define (Kind.Parser.map_set) (lambda (init) (lambda (map) ($Kind.Parser.map_set init map))))
(define ($Kind.Parser.mirror) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "mirror(")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (equa) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ")")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Equal.mirror"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term equa))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))))))
(define (Kind.Parser.mirror) ($Kind.Parser.mirror))
(define ($Kind.Parser.mod) (((Kind.Parser.op) "%") "Nat.mod"))
(define (Kind.Parser.mod) ($Kind.Parser.mod))
(define ($Kind.Parser.mul) (((Kind.Parser.op) "*") "Nat.mul"))
(define (Kind.Parser.mul) ($Kind.Parser.mul))
(define ($Kind.Parser.name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.spaces)) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.many (Kind.Parser.letter))) (lambda (chrs) (($Monad.pure ($Parser.monad)) ($List.fold chrs ($String.nil) (String.cons))))))))
(define (Kind.Parser.name) ($Kind.Parser.name))
(define ($Kind.Parser.name1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.spaces)) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.many1 (Kind.Parser.letter))) (lambda (chrs) (($Monad.pure ($Parser.monad)) ($List.fold chrs ($String.nil) (String.cons))))))))
(define (Kind.Parser.name1) ($Kind.Parser.name1))
(define ($Kind.Parser.name_term sep) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text sep)) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (type) (($Monad.pure ($Parser.monad)) ($Pair.new name type)))))))))
(define (Kind.Parser.name_term) (lambda (sep) ($Kind.Parser.name_term sep)))
(define ($Kind.Parser.nat) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.spaces)) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.first_of ($List.cons ($Parser.hex_nat) ($List.cons ($Parser.nat) ($List.nil))))) (lambda (natx) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.nat natx))))))))))))
(define (Kind.Parser.nat) ($Kind.Parser.nat))
(define ($Kind.Parser.not) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "not(")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (expr) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ")")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Bool.not"))) (let ((term ($Kind.Term.app term expr))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))
(define (Kind.Parser.not) ($Kind.Parser.not))
(define ($Kind.Parser.op sym ref init val0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text sym)) (lambda (-) ((($Monad.bind ($Parser.monad)) ((Parser.text) " ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (val1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref ref))) (let ((term ($Kind.Term.app term val0))) (let ((term ($Kind.Term.app term val1))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))
(define (Kind.Parser.op) (lambda (sym) (lambda (ref) (lambda (init) (lambda (val0) ($Kind.Parser.op sym ref init val0))))))
(define ($Kind.Parser.open) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "open ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.spaces)) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (expr) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "as")) (lambda (-) ($Kind.Parser.name1))))) (lambda (name) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ";"))) (lambda (-) (let ((name (let ((self6 name)) (case (get self6 0) ('Maybe.none (let () (let ((self6 ($Kind.Term.reduce expr ($Kind.Map.new)))) (case (get self6 0) ('Kind.Term.var (let ((f6 (get self6 1))(f7 (get self6 2))) f6)) ('Kind.Term.ref (let ((f6 (get self6 1))) f6)) ('Kind.Term.typ (let () ($Kind.Name.read "self"))) ('Kind.Term.all (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))(f9 (get self6 4))(f10 (get self6 5))) ($Kind.Name.read "self"))) ('Kind.Term.lam (let ((f6 (get self6 1))(f7 (get self6 2))) ($Kind.Name.read "self"))) ('Kind.Term.app (let ((f6 (get self6 1))(f7 (get self6 2))) ($Kind.Name.read "self"))) ('Kind.Term.let (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Kind.Name.read "self"))) ('Kind.Term.def (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Kind.Name.read "self"))) ('Kind.Term.ann (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Kind.Name.read "self"))) ('Kind.Term.gol (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) ($Kind.Name.read "self"))) ('Kind.Term.hol (let ((f6 (get self6 1))) ($Kind.Name.read "self"))) ('Kind.Term.nat (let ((f6 (get self6 1))) ($Kind.Name.read "self"))) ('Kind.Term.chr (let ((f6 (get self6 1))) ($Kind.Name.read "self"))) ('Kind.Term.str (let ((f6 (get self6 1))) ($Kind.Name.read "self"))) ('Kind.Term.cse (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))(f9 (get self6 4))(f10 (get self6 5))(f11 (get self6 6))) ($Kind.Name.read "self"))) ('Kind.Term.ori (let ((f6 (get self6 1))(f7 (get self6 2))) ($Kind.Name.read "self"))))))) ('Maybe.some (let ((f6 (get self6 1))) f6)))))) (let ((wyth ($List.nil))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (rest) (let ((cses ($Kind.Map.set "_" rest ($Kind.Map.new)))) (let ((moti ($Maybe.some ($Kind.Term.hol ($Bits.e))))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.cse ($Bits.e) expr name wyth cses moti))))))))))))))))))))))))
(define (Kind.Parser.open) ($Kind.Parser.open))
(define ($Kind.Parser.or) (((Kind.Parser.op) "||") "Bool.or"))
(define (Kind.Parser.or) ($Kind.Parser.or))
(define ($Kind.Parser.pair) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "{")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (val0) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ","))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (val1) ((($Monad.bind ($Parser.monad)) ((Parser.maybe) ($Kind.Parser.text ","))) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "}")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Pair.new"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term val0))) (let ((term ($Kind.Term.app term val1))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))))))))))))
(define (Kind.Parser.pair) ($Kind.Parser.pair))
(define ($Kind.Parser.parenthesis) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "(")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (term) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ")")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))
(define (Kind.Parser.parenthesis) ($Kind.Parser.parenthesis))
(define ($Kind.Parser.reference) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((self3 ($String.eql name "case"))) (case self3 (#t (let () ((Parser.fail) "Reserved keyword."))) (#f (let () (let ((self3 ($String.eql name "do"))) (case self3 (#t (let () ((Parser.fail) "Reserved keyword."))) (#f (let () (let ((self3 ($String.eql name "if"))) (case self3 (#t (let () ((Parser.fail) "Reserved keyword."))) (#f (let () (let ((self3 ($String.eql name "with"))) (case self3 (#t (let () ((Parser.fail) "Reserved keyword."))) (#f (let () (let ((self3 ($String.eql name "let"))) (case self3 (#t (let () ((Parser.fail) "Reserved keyword."))) (#f (let () (let ((self3 ($String.eql name "def"))) (case self3 (#t (let () ((Parser.fail) "Reserved keyword."))) (#f (let () (let ((self3 ($String.eql name "Type"))) (case self3 (#t (let () (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.typ))))) (#f (let () (let ((self3 ($String.eql name "true"))) (case self3 (#t (let () (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.ref "Bool.true"))))) (#f (let () (let ((self3 ($String.eql name "false"))) (case self3 (#t (let () (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.ref "Bool.false"))))) (#f (let () (let ((self3 ($String.eql name "unit"))) (case self3 (#t (let () (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.ref "Unit.new"))))) (#f (let () (let ((self3 ($String.eql name "none"))) (case self3 (#t (let () (let ((term ($Kind.Term.ref "Maybe.none"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))) (#f (let () (let ((self3 ($String.eql name "refl"))) (case self3 (#t (let () (let ((term ($Kind.Term.ref "Equal.refl"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))) (#f (let () (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.ref name))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define (Kind.Parser.reference) ($Kind.Parser.reference))
(define ($Kind.Parser.rewrite init subt) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "::")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "rewrite")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "in")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (type) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "with")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (iseq) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Equal.rewrite"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term iseq))) (let ((term ($Kind.Term.app term ($Kind.Term.lam name (lambda (x) type))))) (let ((term ($Kind.Term.app term subt))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))))))))))))))
(define (Kind.Parser.rewrite) (lambda (init) (lambda (subt) ($Kind.Parser.rewrite init subt))))
(define ($Kind.Parser.right) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "right(")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (expr) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ")")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Either.right"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term expr))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))
(define (Kind.Parser.right) ($Kind.Parser.right))
(define ($Kind.Parser.sigma init val0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "~")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (val1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Sigma.new"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term val0))) (let ((term ($Kind.Term.app term val1))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))
(define (Kind.Parser.sigma) (lambda (init) (lambda (val0) ($Kind.Parser.sigma init val0))))
(define ($Kind.Parser.sigma.type) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "[")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (typ0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "]")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (typ1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Sigma"))) (let ((term ($Kind.Term.app term typ0))) (let ((term ($Kind.Term.app term ($Kind.Term.lam name (lambda (x) typ1))))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))))))))))
(define (Kind.Parser.sigma.type) ($Kind.Parser.sigma.type))
(define ($Kind.Parser.some) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "some(")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (expr) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ")")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "Maybe.some"))) (let ((term ($Kind.Term.app term ($Kind.Term.hol ($Bits.e))))) (let ((term ($Kind.Term.app term expr))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))))
(define (Kind.Parser.some) ($Kind.Parser.some))
(define ($Kind.Parser.spaces) ($Parser.many ($Parser.first_of ($List.cons ((Parser.text) " ") ($List.cons ((Parser.text) "\x9;") ($List.cons ((Parser.text) "\xA;") ($List.cons ((($Monad.bind ($Parser.monad)) ((Parser.text) "//")) (lambda (-) (let ((endl_or_eof ($Parser.first_of ($List.cons ((Parser.text) "\xA;") ($List.cons (Parser.eof) ($List.nil)))))) ((($Monad.bind ($Parser.monad)) ($Parser.until endl_or_eof (Parser.one))) (lambda (-) (($Monad.pure ($Parser.monad)) ($Unit.new))))))) ($List.nil))))))))
(define (Kind.Parser.spaces) ($Kind.Parser.spaces))
(define ($Kind.Parser.stop from) ((($Monad.bind ($Parser.monad)) (Parser.get_index)) (lambda (upto) (let ((orig ($Pair.new from upto))) (($Monad.pure ($Parser.monad)) orig)))))
(define (Kind.Parser.stop) (lambda (from) ($Kind.Parser.stop from)))
(define ($Kind.Parser.string delim) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ($String.cons delim ($String.nil)))) (lambda (-) ((($Monad.bind ($Parser.monad)) (((Kind.Parser.string.go) delim) "")) (lambda (strx) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig ($Kind.Term.str strx))))))))))))
(define (Kind.Parser.string) (lambda (delim) ($Kind.Parser.string delim)))
(define ($Kind.Parser.string.go delim str idx code) (let ((self0 code)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.error idx code "Non-terminating string."))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 ($U16.eql f0 delim))) (case self2 (#t (let () ($Parser.Reply.value ($Nat.succ idx) f1 ($String.reverse str)))) (#f (let () (let ((self2 ((($Kind.Parser.char.single) idx) code))) (case (get self2 0) ('Parser.Reply.error (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Parser.Reply.error f2 f3 f4))) ('Parser.Reply.value (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Parser.string.go delim ($String.cons f4 str) f2 f3))))))))))))))
(define (Kind.Parser.string.go) (lambda (delim) (lambda (str) (lambda (idx) (lambda (code) ($Kind.Parser.string.go delim str idx code))))))
(define ($Kind.Parser.string_concat init str0) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "|")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (str1) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref "String.concat"))) (let ((term ($Kind.Term.app term str0))) (let ((term ($Kind.Term.app term str1))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))
(define (Kind.Parser.string_concat) (lambda (init) (lambda (str0) ($Kind.Parser.string_concat init str0))))
(define ($Kind.Parser.sub) (((Kind.Parser.op) "-") "Nat.sub"))
(define (Kind.Parser.sub) ($Kind.Parser.sub))
(define ($Kind.Parser.suffix init term idx code) (let ((suffix_parser ($Parser.first_of ($List.cons ($Kind.Parser.application init term) ($List.cons ($Kind.Parser.application.erased init term) ($List.cons ($Kind.Parser.list_set init term) ($List.cons ($Kind.Parser.list_get init term) ($List.cons ($Kind.Parser.map_set init term) ($List.cons ($Kind.Parser.map_get init term) ($List.cons ($Kind.Parser.arrow init term) ($List.cons ((($Kind.Parser.add) init) term) ($List.cons ((($Kind.Parser.sub) init) term) ($List.cons ((($Kind.Parser.mul) init) term) ($List.cons ((($Kind.Parser.div) init) term) ($List.cons ((($Kind.Parser.mod) init) term) ($List.cons ((($Kind.Parser.ltn) init) term) ($List.cons ((($Kind.Parser.lte) init) term) ($List.cons ((($Kind.Parser.eql) init) term) ($List.cons ((($Kind.Parser.gte) init) term) ($List.cons ((($Kind.Parser.gtn) init) term) ($List.cons ((($Kind.Parser.and) init) term) ($List.cons ((($Kind.Parser.or) init) term) ($List.cons ($Kind.Parser.default init term) ($List.cons ($Kind.Parser.cons init term) ($List.cons ($Kind.Parser.concat init term) ($List.cons ($Kind.Parser.string_concat init term) ($List.cons ($Kind.Parser.sigma init term) ($List.cons ($Kind.Parser.equality init term) ($List.cons ($Kind.Parser.inequality init term) ($List.cons ($Kind.Parser.rewrite init term) ($List.cons ($Kind.Parser.annotation init term) ($List.cons ($Kind.Parser.application.hole init term) ($List.nil))))))))))))))))))))))))))))))))) (let ((self1 ((suffix_parser idx) code))) (case (get self1 0) ('Parser.Reply.error (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Parser.Reply.value idx code term))) ('Parser.Reply.value (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Kind.Parser.suffix init f3 f1 f2)))))))
(define (Kind.Parser.suffix) (lambda (init) (lambda (term) (lambda (idx) (lambda (code) ($Kind.Parser.suffix init term idx code))))))
(define ($Kind.Parser.switch) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "switch ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (cond) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "{")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.until ($Kind.Parser.text "}") ($Kind.Parser.switch.case))) (lambda (cses) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "default ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (dflt) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($List.fold cses dflt (lambda (cse) (lambda (rest) (let ((self10 cse)) (case (get self10 0) ('Pair.new (let ((f10 (get self10 1))(f11 (get self10 2))) (let ((term ($Kind.Term.app cond f10))) (let ((term ($Kind.Term.app term ($Kind.Term.lam "" (lambda (x) ($Kind.Term.hol ($Bits.e))))))) (let ((term ($Kind.Term.app term f11))) (let ((term ($Kind.Term.app term rest))) term))))))))))))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term))))))))))))))))))))
(define (Kind.Parser.switch) ($Kind.Parser.switch))
(define ($Kind.Parser.switch.case) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (key) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (val) (($Monad.pure ($Parser.monad)) ($Pair.new key val)))))))))
(define (Kind.Parser.switch.case) ($Kind.Parser.switch.case))
(define ($Kind.Parser.term) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Parser.first_of ($List.cons ($Kind.Parser.forall) ($List.cons ($Kind.Parser.lambda) ($List.cons ($Kind.Parser.lambda.erased) ($List.cons ($Kind.Parser.lambda.nameless) ($List.cons ($Kind.Parser.parenthesis) ($List.cons ($Kind.Parser.letforrange.u32) ($List.cons ($Kind.Parser.letforrange.u32.with) ($List.cons ($Kind.Parser.letforrange.nat) ($List.cons ($Kind.Parser.letforrange.nat.with) ($List.cons ($Kind.Parser.letforin) ($List.cons ($Kind.Parser.letforin.with) ($List.cons ($Kind.Parser.letwhile) ($List.cons ($Kind.Parser.letwhile.with) ($List.cons ($Kind.Parser.let) ($List.cons ($Kind.Parser.let.omit) ($List.cons ($Kind.Parser.getwhile) ($List.cons ($Kind.Parser.getwhile.with) ($List.cons ($Kind.Parser.get) ($List.cons ($Kind.Parser.get.omit) ($List.cons ($Kind.Parser.def) ($List.cons ($Kind.Parser.goal_rewrite) ($List.cons ($Kind.Parser.if) ($List.cons ($Kind.Parser.char) ($List.cons ($Kind.Parser.string 34) ($List.cons ($Kind.Parser.string 96) ($List.cons ($Kind.Parser.pair) ($List.cons ($Kind.Parser.sigma.type) ($List.cons ($Kind.Parser.some) ($List.cons ($Kind.Parser.not) ($List.cons ($Kind.Parser.left) ($List.cons ($Kind.Parser.right) ($List.cons ($Kind.Parser.apply) ($List.cons ($Kind.Parser.chain) ($List.cons ($Kind.Parser.mirror) ($List.cons ($Kind.Parser.list) ($List.cons ($Kind.Parser.map) ($List.cons ($Kind.Parser.log) ($List.cons ($Kind.Parser.do) ($List.cons ($Kind.Parser.case) ($List.cons ($Kind.Parser.open) ($List.cons ($Kind.Parser.without) ($List.cons ($Kind.Parser.switch) ($List.cons ($Kind.Parser.goal) ($List.cons ($Kind.Parser.hole) ($List.cons ($Kind.Parser.float.64) ($List.cons ($Kind.Parser.float.32) ($List.cons ($Kind.Parser.machine_integer.signed 256) ($List.cons ($Kind.Parser.machine_integer.signed 128) ($List.cons ($Kind.Parser.machine_integer.signed 64) ($List.cons ($Kind.Parser.machine_integer.signed 32) ($List.cons ($Kind.Parser.machine_integer.signed 16) ($List.cons ($Kind.Parser.machine_integer.signed 8) ($List.cons ($Kind.Parser.int) ($List.cons ($Kind.Parser.machine_integer.unsigned 256) ($List.cons ($Kind.Parser.machine_integer.unsigned 128) ($List.cons ($Kind.Parser.machine_integer.unsigned 64) ($List.cons ($Kind.Parser.machine_integer.unsigned 32) ($List.cons ($Kind.Parser.machine_integer.unsigned 16) ($List.cons ($Kind.Parser.machine_integer.unsigned 8) ($List.cons ($Kind.Parser.u64) ($List.cons ($Kind.Parser.u32) ($List.cons ($Kind.Parser.u16) ($List.cons ($Kind.Parser.u8) ($List.cons ($Kind.Parser.nat) ($List.cons ($Kind.Parser.reference) ($List.nil)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (lambda (term) (((Kind.Parser.suffix) init) term))))))
(define (Kind.Parser.term) ($Kind.Parser.term))
(define ($Kind.Parser.text text) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.spaces)) (lambda (-) ((Parser.text) text))))
(define (Kind.Parser.text) (lambda (text) ($Kind.Parser.text text)))
(define ($Kind.Parser.u16) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.spaces)) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.nat)) (lambda (natx) ((($Monad.bind ($Parser.monad)) ((Parser.text) "s")) (lambda (-) (let ((term ($Kind.Term.ref "Nat.to_u16"))) (let ((term ($Kind.Term.app term ($Kind.Term.nat natx)))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))
(define (Kind.Parser.u16) ($Kind.Parser.u16))
(define ($Kind.Parser.u32) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.spaces)) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.nat)) (lambda (natx) ((($Monad.bind ($Parser.monad)) ((Parser.text) "u")) (lambda (-) (let ((term ($Kind.Term.ref "Nat.to_u32"))) (let ((term ($Kind.Term.app term ($Kind.Term.nat natx)))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))
(define (Kind.Parser.u32) ($Kind.Parser.u32))
(define ($Kind.Parser.u64) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.spaces)) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.nat)) (lambda (natx) ((($Monad.bind ($Parser.monad)) ((Parser.text) "l")) (lambda (-) (let ((term ($Kind.Term.ref "Nat.to_u64"))) (let ((term ($Kind.Term.app term ($Kind.Term.nat natx)))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))
(define (Kind.Parser.u64) ($Kind.Parser.u64))
(define ($Kind.Parser.u8) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.spaces)) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.nat)) (lambda (natx) ((($Monad.bind ($Parser.monad)) ((Parser.text) "b")) (lambda (-) (let ((term ($Kind.Term.ref "Nat.to_u8"))) (let ((term ($Kind.Term.app term ($Kind.Term.nat natx)))) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))
(define (Kind.Parser.u8) ($Kind.Parser.u8))
(define ($Kind.Parser.without) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.init)) (lambda (init) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text "without ")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.name1)) (lambda (name) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.text ":")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (dflt) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.term)) (lambda (rest) ((($Monad.bind ($Parser.monad)) ($Kind.Parser.stop init)) (lambda (orig) (let ((term ($Kind.Term.ref name))) (let ((term ($Kind.Term.app term ($Kind.Term.lam "" (lambda (x) ($Kind.Term.hol ($Bits.e))))))) (let ((term ($Kind.Term.app term dflt))) (let ((term ($Kind.Term.app term ($Kind.Term.lam name (lambda (x) rest))))) (($Monad.pure ($Parser.monad)) ($Kind.Term.ori orig term)))))))))))))))))))))
(define (Kind.Parser.without) ($Kind.Parser.without))
(define ($Kind.Path) '())
(define (Kind.Path) ($Kind.Path))
(define ($Kind.Path.i path x) (path ($Bits.i x)))
(define (Kind.Path.i) (lambda (path) (lambda (x) ($Kind.Path.i path x))))
(define ($Kind.Path.nil x) x)
(define (Kind.Path.nil) (lambda (x) ($Kind.Path.nil x)))
(define ($Kind.Path.o path x) (path ($Bits.o x)))
(define (Kind.Path.o) (lambda (path) (lambda (x) ($Kind.Path.o path x))))
(define ($Kind.Path.to_bits path) (path ($Bits.e)))
(define (Kind.Path.to_bits) (lambda (path) ($Kind.Path.to_bits path)))
(define ($Kind.Status) '())
(define (Kind.Status) ($Kind.Status))
(define ($Kind.Status.done cached) (vector 'Kind.Status.done cached))
(define (Kind.Status.done) (lambda (cached) ($Kind.Status.done cached)))
(define ($Kind.Status.fail errors) (vector 'Kind.Status.fail errors))
(define (Kind.Status.fail) (lambda (errors) ($Kind.Status.fail errors)))
(define ($Kind.Status.init) (vector 'Kind.Status.init))
(define (Kind.Status.init) ($Kind.Status.init))
(define ($Kind.Status.wait) (vector 'Kind.Status.wait))
(define (Kind.Status.wait) ($Kind.Status.wait))
(define ($Kind.Synth.file file defs) ((($Monad.bind ($IO.monad)) ($IO.get_file file)) (lambda (code) (let ((read ($Kind.Defs.read file code defs))) (let ((self2 read)) (case (get self2 0) ('Either.left (let ((f2 (get self2 1))) (($Monad.pure ($IO.monad)) ($Either.left f2)))) ('Either.right (let ((f2 (get self2 1))) (let ((file_defs f2)) (let ((file_keys ($BitsMap.keys file_defs))) (let ((file_nams ($List.mapped file_keys (Kind.Name.from_bits)))) ((($Monad.bind ($IO.monad)) ($Kind.Synth.many file_nams file_defs)) (lambda (defs) (($Monad.pure ($IO.monad)) ($Either.right ($Pair.new file_nams defs))))))))))))))))
(define (Kind.Synth.file) (lambda (file) (lambda (defs) ($Kind.Synth.file file defs))))
(define ($Kind.Synth.files_of name) ($List.reverse ($Kind.Synth.files_of.make ($String.split name ".") "")))
(define (Kind.Synth.files_of) (lambda (name) ($Kind.Synth.files_of name)))
(define ($Kind.Synth.files_of.make names last) (let ((self0 names)) (case (get self0 0) ('List.nil (let () ($List.nil))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((head ($String.concat last ($String.concat f0 ".kind")))) (let ((tail ($Kind.Synth.files_of.make f1 ($String.concat last ($String.concat f0 "/"))))) ($List.cons head tail))))))))
(define (Kind.Synth.files_of.make) (lambda (names) (lambda (last) ($Kind.Synth.files_of.make names last))))
(define ($Kind.Synth.fix file code orig name term type isct arit defs errs fixd) (let ((self0 errs)) (case (get self0 0) ('List.nil (let () (let ((self0 fixd)) (case self0 (#t (let () (let ((type ($Kind.Term.bind ($List.nil) (lambda (x) ($Bits.i x)) type))) (let ((term ($Kind.Term.bind ($List.nil) (lambda (x) ($Bits.o x)) term))) (let ((defs ($Kind.Map.set name ($Kind.Def.new file code orig name term type isct arit ($Kind.Status.init)) defs))) (($Monad.pure ($IO.monad)) ($Maybe.some defs))))))) (#f (let () (($Monad.pure ($IO.monad)) ($Maybe.none)))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Error.type_mismatch (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))) ($Kind.Synth.fix file code orig name term type isct arit defs f1 fixd))) ('Kind.Error.show_goal (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))) ($Kind.Synth.fix file code orig name term type isct arit defs f1 fixd))) ('Kind.Error.waiting (let ((f2 (get self2 1))) ((($Monad.bind ($IO.monad)) ($Kind.Synth.one f2 defs)) (lambda (new_defs) (let ((self4 new_defs)) (case (get self4 0) ('Maybe.none (let () ($Kind.Synth.fix file code orig name term type isct arit defs f1 fixd))) ('Maybe.some (let ((f4 (get self4 1))) ($Kind.Synth.fix file code orig name term type isct arit f4 f1 ($Bool.true)))))))))) ('Kind.Error.indirect (let ((f2 (get self2 1))) ($Kind.Synth.fix file code orig name term type isct arit defs f1 fixd))) ('Kind.Error.patch (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Bits.e (let () (($Monad.pure ($IO.monad)) ($Maybe.none)))) ('Bits.o (let ((f4 (get self4 1))) (let ((term ($Kind.Term.patch_at f4 term (lambda (x) f3)))) ($Kind.Synth.fix file code orig name term type isct arit defs f1 ($Bool.true))))) ('Bits.i (let ((f4 (get self4 1))) (let ((type ($Kind.Term.patch_at f4 type (lambda (x) f3)))) ($Kind.Synth.fix file code orig name term type isct arit defs f1 ($Bool.true))))))))) ('Kind.Error.undefined_reference (let ((f2 (get self2 1))(f3 (get self2 2))) ((($Monad.bind ($IO.monad)) ($Kind.Synth.one f3 defs)) (lambda (new_defs) (let ((self5 new_defs)) (case (get self5 0) ('Maybe.none (let () ($Kind.Synth.fix file code orig name term type isct arit defs f1 fixd))) ('Maybe.some (let ((f5 (get self5 1))) ($Kind.Synth.fix file code orig name term type isct arit f5 f1 ($Bool.true)))))))))) ('Kind.Error.cant_infer (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Synth.fix file code orig name term type isct arit defs f1 fixd))))))))))
(define (Kind.Synth.fix) (lambda (file) (lambda (code) (lambda (orig) (lambda (name) (lambda (term) (lambda (type) (lambda (isct) (lambda (arit) (lambda (defs) (lambda (errs) (lambda (fixd) ($Kind.Synth.fix file code orig name term type isct arit defs errs fixd)))))))))))))
(define ($Kind.Synth.load name defs) ((($Monad.bind ($IO.monad)) ($Kind.Synth.load.cached ($List.cons name ($List.nil)) defs)) (lambda (cached_defs) (let ((self1 cached_defs)) (case (get self1 0) ('Maybe.none (let () ($Kind.Synth.load.go name ($Kind.Synth.files_of name) defs))) ('Maybe.some (let ((f1 (get self1 1))) (($Monad.pure ($IO.monad)) ($Maybe.some f1)))))))))
(define (Kind.Synth.load) (lambda (name) (lambda (defs) ($Kind.Synth.load name defs))))
(define ($Kind.Synth.load.cached names defs) (let ((self0 names)) (case (get self0 0) ('List.nil (let () (($Monad.pure ($IO.monad)) ($Maybe.some defs)))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($Kind.Synth.load.cached.is_loop f0 defs))) (case self2 (#t (let () ($Kind.Synth.load.cached f1 defs))) (#f (let () (let ((name f0)) ((($Monad.bind ($IO.monad)) ($Kind.Synth.load.cached.def name)) (lambda (defn) (let ((self4 defn)) (case (get self4 0) ('Maybe.none (let () (($Monad.pure ($IO.monad)) ($Maybe.none)))) ('Maybe.some (let ((f4 (get self4 1))) (let ((self5 f4)) (case (get self5 0) ('Kind.Def.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))(f8 (get self5 4))(f9 (get self5 5))(f10 (get self5 6))(f11 (get self5 7))(f12 (get self5 8))(f13 (get self5 9))) (let ((defs ($Kind.Map.set name f4 defs))) (let ((deps ($Kind.Map.new))) (let ((deps ($Kind.Core.dependencies.go f9 deps))) (let ((deps ($Kind.Core.dependencies.go f10 deps))) (let ((deps ($Kind.Map.keys deps))) ((($Monad.bind ($IO.monad)) ($Kind.Synth.load.cached deps defs)) (lambda (defs) (let ((self20 defs)) (case (get self20 0) ('Maybe.none (let () (($Monad.pure ($IO.monad)) ($Maybe.none)))) ('Maybe.some (let ((f20 (get self20 1))) ($Kind.Synth.load.cached f1 f20))))))))))))))))))))))))))))))))
(define (Kind.Synth.load.cached) (lambda (names) (lambda (defs) ($Kind.Synth.load.cached names defs))))
(define ($Kind.Synth.load.cached.def name) ((($Monad.bind ($IO.monad)) ($IO.get_file ($String.concat ".cache/" ($String.concat name ".file")))) (lambda (cache_file) (let ((self1 ($Bool.not ($String.is_empty cache_file)))) (case self1 (#t (let () ((($Monad.bind ($IO.monad)) ($IO.get_file ($String.concat ".cache/" ($String.concat name ".time")))) (lambda (cache_time) ((($Monad.bind ($IO.monad)) ($IO.get_file_mtime cache_file)) (lambda (cache_file_time) (let ((self3 ($String.eql cache_time cache_file_time))) (case self3 (#t (let () ((($Monad.bind ($IO.monad)) ($IO.get_file ($String.concat ".cache/" ($String.concat name ".term")))) (lambda (cache_term) ((($Monad.bind ($IO.monad)) ($IO.get_file ($String.concat ".cache/" ($String.concat name ".type")))) (lambda (cache_type) ((($Monad.bind ($IO.monad)) ($IO.get_file ($String.concat ".cache/" ($String.concat name ".isct")))) (lambda (cache_isct) ((($Monad.bind ($IO.monad)) ($IO.get_file ($String.concat ".cache/" ($String.concat name ".arit")))) (lambda (cache_arit) (($Monad.pure ($IO.monad)) (let ((file cache_file)) (let ((code "<cached>")) (let ((orig ($Pair.new 0 0))) ((($Monad.bind ($Maybe.monad)) ($Kind.Core.read cache_term)) (lambda (term) ((($Monad.bind ($Maybe.monad)) ($Kind.Core.read cache_type)) (lambda (type) ((($Monad.bind ($Maybe.monad)) ($Bool.read cache_isct)) (lambda (isct) ((($Monad.bind ($Maybe.monad)) ($Maybe.some ($Nat.read cache_arit))) (lambda (arit) (let ((stat ($Kind.Status.done ($Bool.true)))) (($Monad.pure ($Maybe.monad)) ($Kind.Def.new file code orig name term type isct arit stat))))))))))))))))))))))))) (#f (let () (($Monad.pure ($IO.monad)) ($Maybe.none)))))))))))) (#f (let () (($Monad.pure ($IO.monad)) ($Maybe.none)))))))))
(define (Kind.Synth.load.cached.def) (lambda (name) ($Kind.Synth.load.cached.def name)))
(define ($Kind.Synth.load.cached.is_loop name defs) (let ((self0 ($Kind.Map.get name defs))) (case (get self0 0) ('Maybe.none (let () ($Bool.false))) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 f0)) (case (get self1 0) ('Kind.Def.new (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))(f7 (get self1 7))(f8 (get self1 8))(f9 (get self1 9))) (let ((self10 f9)) (case (get self10 0) ('Kind.Status.init (let () ($Bool.false))) ('Kind.Status.wait (let () ($Bool.false))) ('Kind.Status.done (let ((f10 (get self10 1))) f10)) ('Kind.Status.fail (let ((f10 (get self10 1))) ($Bool.false))))))))))))))
(define (Kind.Synth.load.cached.is_loop) (lambda (name) (lambda (defs) ($Kind.Synth.load.cached.is_loop name defs))))
(define ($Kind.Synth.load.go name files defs) (let ((self0 files)) (case (get self0 0) ('List.nil (let () (($Monad.pure ($IO.monad)) ($Maybe.none)))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ((($Monad.bind ($IO.monad)) ($IO.get_file f0)) (lambda (code) (let ((read ($Kind.Defs.read f0 code defs))) (let ((self4 read)) (case (get self4 0) ('Either.left (let ((f4 (get self4 1))) ($Kind.Synth.load.go name f1 defs))) ('Either.right (let ((f4 (get self4 1))) (let ((defs f4)) (let ((self6 ($Kind.Map.get name defs))) (case (get self6 0) ('Maybe.none (let () ($Kind.Synth.load.go name f1 defs))) ('Maybe.some (let ((f6 (get self6 1))) (($Monad.pure ($IO.monad)) ($Maybe.some defs)))))))))))))))))))
(define (Kind.Synth.load.go) (lambda (name) (lambda (files) (lambda (defs) ($Kind.Synth.load.go name files defs)))))
(define ($Kind.Synth.many names defs) (let ((self0 names)) (case (get self0 0) ('List.nil (let () (($Monad.pure ($IO.monad)) defs))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ((($Monad.bind ($IO.monad)) ($Kind.Synth.one f0 defs)) (lambda (new_defs) (let ((self3 new_defs)) (case (get self3 0) ('Maybe.none (let () ($Kind.Synth.many f1 defs))) ('Maybe.some (let ((f3 (get self3 1))) ($Kind.Synth.many f1 f3))))))))))))
(define (Kind.Synth.many) (lambda (names) (lambda (defs) ($Kind.Synth.many names defs))))
(define ($Kind.Synth.one name defs) (let ((self0 ($Kind.Map.get name defs))) (case (get self0 0) ('Maybe.none (let () ((($Monad.bind ($IO.monad)) ($IO.get_time)) (lambda (time_a) ((($Monad.bind ($IO.monad)) ($Kind.Synth.load name defs)) (lambda (loaded) (let ((self2 loaded)) (case (get self2 0) ('Maybe.none (let () (($Monad.pure ($IO.monad)) ($Maybe.none)))) ('Maybe.some (let ((f2 (get self2 1))) ((($Monad.bind ($IO.monad)) ($IO.get_time)) (lambda (time_b) ((($Monad.bind ($IO.monad)) ($Kind.Synth.one name f2)) (lambda (result) ((($Monad.bind ($IO.monad)) ($IO.get_time)) (lambda (time_c) (($Monad.pure ($IO.monad)) result))))))))))))))))) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 f0)) (case (get self1 0) ('Kind.Def.new (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))(f7 (get self1 7))(f8 (get self1 8))(f9 (get self1 9))) (let ((file f1)) (let ((code f2)) (let ((orig f3)) (let ((name f4)) (let ((term f5)) (let ((type f6)) (let ((isct f7)) (let ((arit f8)) (let ((stat f9)) (let ((self19 stat)) (case (get self19 0) ('Kind.Status.init (let () (let ((defs ($Kind.Map.set name ($Kind.Def.new file code orig name term type isct arit ($Kind.Status.wait)) defs))) (let ((checked ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check type ($Maybe.some ($Kind.Term.typ)) defs ($List.nil) ($Kind.MPath.i ($Kind.MPath.nil)) ($Maybe.none))) (lambda (chk_type) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check term ($Maybe.some type) defs ($List.nil) ($Kind.MPath.o ($Kind.MPath.nil)) ($Maybe.none))) (lambda (chk_term) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))))) (let ((self21 checked)) (case (get self21 0) ('Kind.Check.result (let ((f21 (get self21 1))(f22 (get self21 2))) (let ((self23 ($List.is_empty f22))) (case self23 (#t (let () (let ((defs ($Kind.Map.def file code orig name term type isct arit ($Bool.true) defs))) (($Monad.pure ($IO.monad)) ($Maybe.some defs))))) (#f (let () ((($Monad.bind ($IO.monad)) ($Kind.Synth.fix file code orig name term type isct arit defs f22 ($Bool.false))) (lambda (fixed) (let ((self24 fixed)) (case (get self24 0) ('Maybe.none (let () (let ((stat ($Kind.Status.fail f22))) (let ((defs ($Kind.Map.set name ($Kind.Def.new file code orig name term type isct arit stat) defs))) (($Monad.pure ($IO.monad)) ($Maybe.some defs)))))) ('Maybe.some (let ((f24 (get self24 1))) ($Kind.Synth.one name f24))))))))))))))))))) ('Kind.Status.wait (let () (($Monad.pure ($IO.monad)) ($Maybe.some defs)))) ('Kind.Status.done (let ((f19 (get self19 1))) (($Monad.pure ($IO.monad)) ($Maybe.some defs)))) ('Kind.Status.fail (let ((f19 (get self19 1))) (($Monad.pure ($IO.monad)) ($Maybe.some defs))))))))))))))))))))))))
(define (Kind.Synth.one) (lambda (name) (lambda (defs) ($Kind.Synth.one name defs))))
(define ($Kind.Term) '())
(define (Kind.Term) ($Kind.Term))
(define ($Kind.Term.SmartMotive.make name expr type moti size defs) (let ((vals ($Kind.Term.SmartMotive.vals expr type defs))) (let ((nams ($Kind.Term.SmartMotive.nams name type defs))) (let ((subs ($List.zip nams vals))) ($List.fold subs moti (lambda (sub) (lambda (moti) (let ((self5 sub)) (case (get self5 0) ('Pair.new (let ((f5 (get self5 1))(f6 (get self5 2))) ($Kind.Term.SmartMotive.replace moti f6 ($Kind.Term.ref f5) size))))))))))))
(define (Kind.Term.SmartMotive.make) (lambda (name) (lambda (expr) (lambda (type) (lambda (moti) (lambda (size) (lambda (defs) ($Kind.Term.SmartMotive.make name expr type moti size defs))))))))
(define ($Kind.Term.SmartMotive.nams name type defs) (let ((self0 ($Kind.Term.reduce type defs))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.nil))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($List.nil))) ('Kind.Term.typ (let () ($List.nil))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Kind.Term.SmartMotive.nams.cont name f3 ($List.nil) defs))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.nil))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.nil))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.nil))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.nil))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.nil))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.nil))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($List.nil))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($List.nil))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($List.nil))) ('Kind.Term.str (let ((f0 (get self0 1))) ($List.nil))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) ($List.nil))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.nil))))))
(define (Kind.Term.SmartMotive.nams) (lambda (name) (lambda (type) (lambda (defs) ($Kind.Term.SmartMotive.nams name type defs)))))
(define ($Kind.Term.SmartMotive.nams.cont name term binds defs) (let ((self0 ($Kind.Term.reduce term defs))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons name ($List.tail binds)))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($List.cons name ($List.tail binds)))) ('Kind.Term.typ (let () ($List.cons name ($List.tail binds)))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Kind.Term.SmartMotive.nams.cont name ((f4 ($Kind.Term.ref f1)) ($Kind.Term.ref f2)) ($List.cons ($String.flatten ($List.cons name ($List.cons "." ($List.cons f2 ($List.nil))))) binds) defs))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons name ($List.tail binds)))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons name ($List.tail binds)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons name ($List.tail binds)))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons name ($List.tail binds)))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons name ($List.tail binds)))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons name ($List.tail binds)))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($List.cons name ($List.tail binds)))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($List.cons name ($List.tail binds)))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($List.cons name ($List.tail binds)))) ('Kind.Term.str (let ((f0 (get self0 1))) ($List.cons name ($List.tail binds)))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) ($List.cons name ($List.tail binds)))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons name ($List.tail binds)))))))
(define (Kind.Term.SmartMotive.nams.cont) (lambda (name) (lambda (term) (lambda (binds) (lambda (defs) ($Kind.Term.SmartMotive.nams.cont name term binds defs))))))
(define ($Kind.Term.SmartMotive.replace term from to lv) (let ((self0 ($Kind.Term.identical term from lv))) (case self0 (#t (let () to)) (#f (let () (let ((self0 term)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.var f0 f1))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Term.ref f0))) ('Kind.Term.typ (let () ($Kind.Term.typ))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((xtyp ($Kind.Term.SmartMotive.replace f3 from to lv))) (let ((body ((f4 ($Kind.Term.ref f1)) ($Kind.Term.ref f2)))) (let ((body ($Kind.Term.SmartMotive.replace body from to ($Nat.succ ($Nat.succ lv))))) ($Kind.Term.all f0 f1 f2 xtyp (lambda (s) (lambda (x) body)))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((body (f1 ($Kind.Term.ref f0)))) (let ((body ($Kind.Term.SmartMotive.replace body from to ($Nat.succ lv)))) ($Kind.Term.lam f0 (lambda (x) body)))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((func ($Kind.Term.SmartMotive.replace f0 from to lv))) (let ((argm ($Kind.Term.SmartMotive.replace f1 from to lv))) ($Kind.Term.app func argm))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((expr ($Kind.Term.SmartMotive.replace f1 from to lv))) (let ((body (f2 ($Kind.Term.ref f0)))) (let ((body ($Kind.Term.SmartMotive.replace body from to ($Nat.succ lv)))) ($Kind.Term.let f0 expr (lambda (x) body))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((expr ($Kind.Term.SmartMotive.replace f1 from to lv))) (let ((body (f2 ($Kind.Term.ref f0)))) (let ((body ($Kind.Term.SmartMotive.replace body from to ($Nat.succ lv)))) ($Kind.Term.def f0 expr (lambda (x) body))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((term ($Kind.Term.SmartMotive.replace f1 from to lv))) (let ((type ($Kind.Term.SmartMotive.replace f2 from to lv))) ($Kind.Term.ann f0 term type))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) term)) ('Kind.Term.hol (let ((f0 (get self0 1))) term)) ('Kind.Term.nat (let ((f0 (get self0 1))) term)) ('Kind.Term.chr (let ((f0 (get self0 1))) term)) ('Kind.Term.str (let ((f0 (get self0 1))) term)) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) term)) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.SmartMotive.replace f1 from to lv))))))))))
(define (Kind.Term.SmartMotive.replace) (lambda (term) (lambda (from) (lambda (to) (lambda (lv) ($Kind.Term.SmartMotive.replace term from to lv))))))
(define ($Kind.Term.SmartMotive.vals expr type defs) (let ((self0 ($Kind.Term.reduce type defs))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr type ($List.nil) defs))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr type ($List.nil) defs))) ('Kind.Term.typ (let () ($Kind.Term.SmartMotive.vals.cont expr type ($List.nil) defs))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Kind.Term.SmartMotive.vals expr ((f4 ($Kind.Term.typ)) ($Kind.Term.typ)) defs))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr type ($List.nil) defs))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr type ($List.nil) defs))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.SmartMotive.vals.cont expr type ($List.nil) defs))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.SmartMotive.vals.cont expr type ($List.nil) defs))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.SmartMotive.vals.cont expr type ($List.nil) defs))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.SmartMotive.vals.cont expr type ($List.nil) defs))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr type ($List.nil) defs))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr type ($List.nil) defs))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr type ($List.nil) defs))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.SmartMotive.vals.cont expr type ($List.nil) defs))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) ($Kind.Term.SmartMotive.vals.cont expr type ($List.nil) defs))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr type ($List.nil) defs))))))
(define (Kind.Term.SmartMotive.vals) (lambda (expr) (lambda (type) (lambda (defs) ($Kind.Term.SmartMotive.vals expr type defs)))))
(define ($Kind.Term.SmartMotive.vals.cont expr term args defs) (let ((self0 ($Kind.Term.reduce term defs))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons expr ($List.tail ($List.reverse args))))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($List.cons expr ($List.tail ($List.reverse args))))) ('Kind.Term.typ (let () ($List.cons expr ($List.tail ($List.reverse args))))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($List.cons expr ($List.tail ($List.reverse args))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons expr ($List.tail ($List.reverse args))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.SmartMotive.vals.cont expr f0 ($List.cons f1 args) defs))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons expr ($List.tail ($List.reverse args))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons expr ($List.tail ($List.reverse args))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons expr ($List.tail ($List.reverse args))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($List.cons expr ($List.tail ($List.reverse args))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($List.cons expr ($List.tail ($List.reverse args))))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($List.cons expr ($List.tail ($List.reverse args))))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($List.cons expr ($List.tail ($List.reverse args))))) ('Kind.Term.str (let ((f0 (get self0 1))) ($List.cons expr ($List.tail ($List.reverse args))))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) ($List.cons expr ($List.tail ($List.reverse args))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons expr ($List.tail ($List.reverse args))))))))
(define (Kind.Term.SmartMotive.vals.cont) (lambda (expr) (lambda (term) (lambda (args) (lambda (defs) ($Kind.Term.SmartMotive.vals.cont expr term args defs))))))
(define ($Kind.Term.all eras self name xtyp body) (vector 'Kind.Term.all eras self name xtyp body))
(define (Kind.Term.all) (lambda (eras) (lambda (self) (lambda (name) (lambda (xtyp) (lambda (body) ($Kind.Term.all eras self name xtyp body)))))))
(define ($Kind.Term.ann done term type) (vector 'Kind.Term.ann done term type))
(define (Kind.Term.ann) (lambda (done) (lambda (term) (lambda (type) ($Kind.Term.ann done term type)))))
(define ($Kind.Term.app func argm) (vector 'Kind.Term.app func argm))
(define (Kind.Term.app) (lambda (func) (lambda (argm) ($Kind.Term.app func argm))))
(define ($Kind.Term.bind vars path term) (let ((self0 term)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($List.at_last f1 vars))) (case (get self2 0) ('Maybe.none (let () ($Kind.Term.var f0 f1))) ('Maybe.some (let ((f2 (get self2 1))) ($Pair.snd f2))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Context.find f0 vars))) (case (get self1 0) ('Maybe.none (let () ($Kind.Term.ref f0))) ('Maybe.some (let ((f1 (get self1 1))) f1)))))) ('Kind.Term.typ (let () ($Kind.Term.typ))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((vlen ($List.length vars))) ($Kind.Term.all f0 f1 f2 ($Kind.Term.bind vars ((Kind.Path.o) path) f3) (lambda (s) (lambda (x) ($Kind.Term.bind ($List.cons ($Pair.new f2 x) ($List.cons ($Pair.new f1 s) vars)) ((Kind.Path.i) path) ((f4 ($Kind.Term.var f1 vlen)) ($Kind.Term.var f2 ($Nat.succ vlen)))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((vlen ($List.length vars))) ($Kind.Term.lam f0 (lambda (x) ($Kind.Term.bind ($List.cons ($Pair.new f0 x) vars) ((Kind.Path.o) path) (f1 ($Kind.Term.var f0 vlen)))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.app ($Kind.Term.bind vars ((Kind.Path.o) path) f0) ($Kind.Term.bind vars ((Kind.Path.i) path) f1)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((vlen ($List.length vars))) ($Kind.Term.let f0 ($Kind.Term.bind vars ((Kind.Path.o) path) f1) (lambda (x) ($Kind.Term.bind ($List.cons ($Pair.new f0 x) vars) ((Kind.Path.i) path) (f2 ($Kind.Term.var f0 vlen)))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((vlen ($List.length vars))) ($Kind.Term.def f0 ($Kind.Term.bind vars ((Kind.Path.o) path) f1) (lambda (x) ($Kind.Term.bind ($List.cons ($Pair.new f0 x) vars) ((Kind.Path.i) path) (f2 ($Kind.Term.var f0 vlen)))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.ann f0 ($Kind.Term.bind vars ((Kind.Path.o) path) f1) ($Kind.Term.bind vars ((Kind.Path.i) path) f2)))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.gol f0 f1 f2))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.hol ($Kind.Path.to_bits path)))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.nat f0))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.chr f0))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.str f0))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((expr ($Kind.Term.bind vars ((Kind.Path.o) path) f1))) (let ((name f2)) (let ((wyth ($List.mapped f3 (lambda (with_var) (let ((self9 with_var)) (case (get self9 0) ('Kind.Ann.new (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((with_var_term ($Kind.Term.bind vars path f10))) (let ((with_var_type (let ((self13 f11)) (case (get self13 0) ('Maybe.none (let () ($Maybe.none))) ('Maybe.some (let ((f13 (get self13 1))) ($Maybe.some ($Kind.Term.bind vars path f13)))))))) ($Kind.Ann.new f9 with_var_term with_var_type))))))))))) (let ((cses f4)) (let ((moti f5)) ($Kind.Term.cse ($Kind.Path.to_bits path) expr name wyth cses moti)))))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.ori f0 ($Kind.Term.bind vars path f1)))))))
(define (Kind.Term.bind) (lambda (vars) (lambda (path) (lambda (term) ($Kind.Term.bind vars path term)))))
(define ($Kind.Term.check term type defs ctx path orig) ((($Monad.bind ($Kind.Check.monad)) (let ((self0 term)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($List.at_last f1 ctx))) (case (get self2 0) ('Maybe.none (let () ($Kind.Check.result type ($List.cons ($Kind.Error.undefined_reference orig f0) ($List.nil))))) ('Maybe.some (let ((f2 (get self2 1))) (($Monad.pure ($Kind.Check.monad)) (let ((self3 f2)) (case (get self3 0) ('Pair.new (let ((f3 (get self3 1))(f4 (get self3 2))) f4))))))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Map.get f0 defs))) (case (get self1 0) ('Maybe.none (let () ($Kind.Check.result type ($List.cons ($Kind.Error.undefined_reference orig f0) ($List.nil))))) ('Maybe.some (let ((f1 (get self1 1))) (let ((self2 f1)) (case (get self2 0) ('Kind.Def.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))(f7 (get self2 6))(f8 (get self2 7))(f9 (get self2 8))(f10 (get self2 9))) (let ((ref_name f5)) (let ((ref_type f7)) (let ((ref_term f6)) (let ((ref_stat f10)) (let ((self15 ref_stat)) (case (get self15 0) ('Kind.Status.init (let () ($Kind.Check.result ($Maybe.some ref_type) ($List.cons ($Kind.Error.waiting ref_name) ($List.nil))))) ('Kind.Status.wait (let () ($Kind.Check.result ($Maybe.some ref_type) ($List.nil)))) ('Kind.Status.done (let ((f15 (get self15 1))) ($Kind.Check.result ($Maybe.some ref_type) ($List.nil)))) ('Kind.Status.fail (let ((f15 (get self15 1))) ($Kind.Check.result ($Maybe.some ref_type) ($List.cons ($Kind.Error.indirect ref_name) ($List.nil))))))))))))))))))))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Kind.Term.typ)))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((ctx_size ($List.length ctx))) (let ((self_var ($Kind.Term.var f1 ctx_size))) (let ((body_var ($Kind.Term.var f2 ($Nat.succ ctx_size)))) (let ((body_ctx ($List.cons ($Pair.new f2 f3) ($List.cons ($Pair.new f1 term) ctx)))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check f3 ($Maybe.some ($Kind.Term.typ)) defs ctx ($Kind.MPath.o path) orig)) (lambda (-) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check ((f4 self_var) body_var) ($Maybe.some ($Kind.Term.typ)) defs body_ctx ($Kind.MPath.i path) orig)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Kind.Term.typ)))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 type)) (case (get self2 0) ('Maybe.none (let () (let ((lam_type ($Kind.Term.hol ($Bits.e)))) (let ((lam_term ($Kind.Term.ann ($Bool.false) term lam_type))) ($Kind.Check.result type ($List.cons ($Kind.Error.patch ($Kind.MPath.to_bits path) lam_term) ($List.nil))))))) ('Maybe.some (let ((f2 (get self2 1))) (let ((typv ($Kind.Term.reduce f2 defs))) (let ((self4 typv)) (case (get self4 0) ('Kind.Term.var (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right f2))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil))))))) ('Kind.Term.ref (let ((f4 (get self4 1))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right f2))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil))))))) ('Kind.Term.typ (let () (let ((expected ($Either.left "function"))) (let ((detected ($Either.right f2))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil))))))) ('Kind.Term.all (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))(f7 (get self4 4))(f8 (get self4 5))) (let ((ctx_size ($List.length ctx))) (let ((self_var term)) (let ((body_var ($Kind.Term.var f0 ctx_size))) (let ((body_typ ((f8 self_var) body_var))) (let ((body_ctx ($List.cons ($Pair.new f0 f7) ctx))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check (f1 body_var) ($Maybe.some body_typ) defs body_ctx ($Kind.MPath.o path) orig)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) f2)))))))))) ('Kind.Term.lam (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right f2))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil))))))) ('Kind.Term.app (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right f2))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil))))))) ('Kind.Term.let (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right f2))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil))))))) ('Kind.Term.def (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right f2))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil))))))) ('Kind.Term.ann (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right f2))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil))))))) ('Kind.Term.gol (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right f2))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil))))))) ('Kind.Term.hol (let ((f4 (get self4 1))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right f2))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil))))))) ('Kind.Term.nat (let ((f4 (get self4 1))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right f2))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil))))))) ('Kind.Term.chr (let ((f4 (get self4 1))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right f2))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil))))))) ('Kind.Term.str (let ((f4 (get self4 1))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right f2))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil))))))) ('Kind.Term.cse (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))(f7 (get self4 4))(f8 (get self4 5))(f9 (get self4 6))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right f2))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil))))))) ('Kind.Term.ori (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right f2))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil)))))))))))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check f0 ($Maybe.none) defs ctx ($Kind.MPath.o path) orig)) (lambda (func_typ) (let ((func_typ ($Kind.Term.reduce func_typ defs))) (let ((self4 func_typ)) (case (get self4 0) ('Kind.Term.var (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right func_typ))) (let ((orig (let ((self8 f0)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))(f9 (get self8 2))) orig)) ('Kind.Term.ref (let ((f8 (get self8 1))) orig)) ('Kind.Term.typ (let () orig)) ('Kind.Term.all (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))) orig)) ('Kind.Term.lam (let ((f8 (get self8 1))(f9 (get self8 2))) orig)) ('Kind.Term.app (let ((f8 (get self8 1))(f9 (get self8 2))) orig)) ('Kind.Term.let (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.def (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.ann (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.gol (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.hol (let ((f8 (get self8 1))) orig)) ('Kind.Term.nat (let ((f8 (get self8 1))) orig)) ('Kind.Term.chr (let ((f8 (get self8 1))) orig)) ('Kind.Term.str (let ((f8 (get self8 1))) orig)) ('Kind.Term.cse (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))(f13 (get self8 6))) orig)) ('Kind.Term.ori (let ((f8 (get self8 1))(f9 (get self8 2))) ($Maybe.some f8))))))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil)))))))) ('Kind.Term.ref (let ((f4 (get self4 1))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right func_typ))) (let ((orig (let ((self7 f0)) (case (get self7 0) ('Kind.Term.var (let ((f7 (get self7 1))(f8 (get self7 2))) orig)) ('Kind.Term.ref (let ((f7 (get self7 1))) orig)) ('Kind.Term.typ (let () orig)) ('Kind.Term.all (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))) orig)) ('Kind.Term.lam (let ((f7 (get self7 1))(f8 (get self7 2))) orig)) ('Kind.Term.app (let ((f7 (get self7 1))(f8 (get self7 2))) orig)) ('Kind.Term.let (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.def (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.ann (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.gol (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.hol (let ((f7 (get self7 1))) orig)) ('Kind.Term.nat (let ((f7 (get self7 1))) orig)) ('Kind.Term.chr (let ((f7 (get self7 1))) orig)) ('Kind.Term.str (let ((f7 (get self7 1))) orig)) ('Kind.Term.cse (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))(f12 (get self7 6))) orig)) ('Kind.Term.ori (let ((f7 (get self7 1))(f8 (get self7 2))) ($Maybe.some f7))))))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil)))))))) ('Kind.Term.typ (let () (let ((expected ($Either.left "function"))) (let ((detected ($Either.right func_typ))) (let ((orig (let ((self6 f0)) (case (get self6 0) ('Kind.Term.var (let ((f6 (get self6 1))(f7 (get self6 2))) orig)) ('Kind.Term.ref (let ((f6 (get self6 1))) orig)) ('Kind.Term.typ (let () orig)) ('Kind.Term.all (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))(f9 (get self6 4))(f10 (get self6 5))) orig)) ('Kind.Term.lam (let ((f6 (get self6 1))(f7 (get self6 2))) orig)) ('Kind.Term.app (let ((f6 (get self6 1))(f7 (get self6 2))) orig)) ('Kind.Term.let (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) orig)) ('Kind.Term.def (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) orig)) ('Kind.Term.ann (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) orig)) ('Kind.Term.gol (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) orig)) ('Kind.Term.hol (let ((f6 (get self6 1))) orig)) ('Kind.Term.nat (let ((f6 (get self6 1))) orig)) ('Kind.Term.chr (let ((f6 (get self6 1))) orig)) ('Kind.Term.str (let ((f6 (get self6 1))) orig)) ('Kind.Term.cse (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))(f9 (get self6 4))(f10 (get self6 5))(f11 (get self6 6))) orig)) ('Kind.Term.ori (let ((f6 (get self6 1))(f7 (get self6 2))) ($Maybe.some f6))))))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil)))))))) ('Kind.Term.all (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))(f7 (get self4 4))(f8 (get self4 5))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check f1 ($Maybe.some f7) defs ctx ($Kind.MPath.i path) orig)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ((f8 f0) f1)))))) ('Kind.Term.lam (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right func_typ))) (let ((orig (let ((self8 f0)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))(f9 (get self8 2))) orig)) ('Kind.Term.ref (let ((f8 (get self8 1))) orig)) ('Kind.Term.typ (let () orig)) ('Kind.Term.all (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))) orig)) ('Kind.Term.lam (let ((f8 (get self8 1))(f9 (get self8 2))) orig)) ('Kind.Term.app (let ((f8 (get self8 1))(f9 (get self8 2))) orig)) ('Kind.Term.let (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.def (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.ann (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.gol (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.hol (let ((f8 (get self8 1))) orig)) ('Kind.Term.nat (let ((f8 (get self8 1))) orig)) ('Kind.Term.chr (let ((f8 (get self8 1))) orig)) ('Kind.Term.str (let ((f8 (get self8 1))) orig)) ('Kind.Term.cse (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))(f13 (get self8 6))) orig)) ('Kind.Term.ori (let ((f8 (get self8 1))(f9 (get self8 2))) ($Maybe.some f8))))))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil)))))))) ('Kind.Term.app (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right func_typ))) (let ((orig (let ((self8 f0)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))(f9 (get self8 2))) orig)) ('Kind.Term.ref (let ((f8 (get self8 1))) orig)) ('Kind.Term.typ (let () orig)) ('Kind.Term.all (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))) orig)) ('Kind.Term.lam (let ((f8 (get self8 1))(f9 (get self8 2))) orig)) ('Kind.Term.app (let ((f8 (get self8 1))(f9 (get self8 2))) orig)) ('Kind.Term.let (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.def (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.ann (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.gol (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.hol (let ((f8 (get self8 1))) orig)) ('Kind.Term.nat (let ((f8 (get self8 1))) orig)) ('Kind.Term.chr (let ((f8 (get self8 1))) orig)) ('Kind.Term.str (let ((f8 (get self8 1))) orig)) ('Kind.Term.cse (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))(f13 (get self8 6))) orig)) ('Kind.Term.ori (let ((f8 (get self8 1))(f9 (get self8 2))) ($Maybe.some f8))))))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil)))))))) ('Kind.Term.let (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right func_typ))) (let ((orig (let ((self9 f0)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) orig)) ('Kind.Term.ref (let ((f9 (get self9 1))) orig)) ('Kind.Term.typ (let () orig)) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) orig)) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) orig)) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) orig)) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.hol (let ((f9 (get self9 1))) orig)) ('Kind.Term.nat (let ((f9 (get self9 1))) orig)) ('Kind.Term.chr (let ((f9 (get self9 1))) orig)) ('Kind.Term.str (let ((f9 (get self9 1))) orig)) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) orig)) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) ($Maybe.some f9))))))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil)))))))) ('Kind.Term.def (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right func_typ))) (let ((orig (let ((self9 f0)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) orig)) ('Kind.Term.ref (let ((f9 (get self9 1))) orig)) ('Kind.Term.typ (let () orig)) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) orig)) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) orig)) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) orig)) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.hol (let ((f9 (get self9 1))) orig)) ('Kind.Term.nat (let ((f9 (get self9 1))) orig)) ('Kind.Term.chr (let ((f9 (get self9 1))) orig)) ('Kind.Term.str (let ((f9 (get self9 1))) orig)) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) orig)) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) ($Maybe.some f9))))))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil)))))))) ('Kind.Term.ann (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right func_typ))) (let ((orig (let ((self9 f0)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) orig)) ('Kind.Term.ref (let ((f9 (get self9 1))) orig)) ('Kind.Term.typ (let () orig)) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) orig)) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) orig)) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) orig)) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.hol (let ((f9 (get self9 1))) orig)) ('Kind.Term.nat (let ((f9 (get self9 1))) orig)) ('Kind.Term.chr (let ((f9 (get self9 1))) orig)) ('Kind.Term.str (let ((f9 (get self9 1))) orig)) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) orig)) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) ($Maybe.some f9))))))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil)))))))) ('Kind.Term.gol (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right func_typ))) (let ((orig (let ((self9 f0)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) orig)) ('Kind.Term.ref (let ((f9 (get self9 1))) orig)) ('Kind.Term.typ (let () orig)) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) orig)) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) orig)) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) orig)) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) orig)) ('Kind.Term.hol (let ((f9 (get self9 1))) orig)) ('Kind.Term.nat (let ((f9 (get self9 1))) orig)) ('Kind.Term.chr (let ((f9 (get self9 1))) orig)) ('Kind.Term.str (let ((f9 (get self9 1))) orig)) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) orig)) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) ($Maybe.some f9))))))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil)))))))) ('Kind.Term.hol (let ((f4 (get self4 1))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right func_typ))) (let ((orig (let ((self7 f0)) (case (get self7 0) ('Kind.Term.var (let ((f7 (get self7 1))(f8 (get self7 2))) orig)) ('Kind.Term.ref (let ((f7 (get self7 1))) orig)) ('Kind.Term.typ (let () orig)) ('Kind.Term.all (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))) orig)) ('Kind.Term.lam (let ((f7 (get self7 1))(f8 (get self7 2))) orig)) ('Kind.Term.app (let ((f7 (get self7 1))(f8 (get self7 2))) orig)) ('Kind.Term.let (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.def (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.ann (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.gol (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.hol (let ((f7 (get self7 1))) orig)) ('Kind.Term.nat (let ((f7 (get self7 1))) orig)) ('Kind.Term.chr (let ((f7 (get self7 1))) orig)) ('Kind.Term.str (let ((f7 (get self7 1))) orig)) ('Kind.Term.cse (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))(f12 (get self7 6))) orig)) ('Kind.Term.ori (let ((f7 (get self7 1))(f8 (get self7 2))) ($Maybe.some f7))))))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil)))))))) ('Kind.Term.nat (let ((f4 (get self4 1))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right func_typ))) (let ((orig (let ((self7 f0)) (case (get self7 0) ('Kind.Term.var (let ((f7 (get self7 1))(f8 (get self7 2))) orig)) ('Kind.Term.ref (let ((f7 (get self7 1))) orig)) ('Kind.Term.typ (let () orig)) ('Kind.Term.all (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))) orig)) ('Kind.Term.lam (let ((f7 (get self7 1))(f8 (get self7 2))) orig)) ('Kind.Term.app (let ((f7 (get self7 1))(f8 (get self7 2))) orig)) ('Kind.Term.let (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.def (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.ann (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.gol (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.hol (let ((f7 (get self7 1))) orig)) ('Kind.Term.nat (let ((f7 (get self7 1))) orig)) ('Kind.Term.chr (let ((f7 (get self7 1))) orig)) ('Kind.Term.str (let ((f7 (get self7 1))) orig)) ('Kind.Term.cse (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))(f12 (get self7 6))) orig)) ('Kind.Term.ori (let ((f7 (get self7 1))(f8 (get self7 2))) ($Maybe.some f7))))))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil)))))))) ('Kind.Term.chr (let ((f4 (get self4 1))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right func_typ))) (let ((orig (let ((self7 f0)) (case (get self7 0) ('Kind.Term.var (let ((f7 (get self7 1))(f8 (get self7 2))) orig)) ('Kind.Term.ref (let ((f7 (get self7 1))) orig)) ('Kind.Term.typ (let () orig)) ('Kind.Term.all (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))) orig)) ('Kind.Term.lam (let ((f7 (get self7 1))(f8 (get self7 2))) orig)) ('Kind.Term.app (let ((f7 (get self7 1))(f8 (get self7 2))) orig)) ('Kind.Term.let (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.def (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.ann (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.gol (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.hol (let ((f7 (get self7 1))) orig)) ('Kind.Term.nat (let ((f7 (get self7 1))) orig)) ('Kind.Term.chr (let ((f7 (get self7 1))) orig)) ('Kind.Term.str (let ((f7 (get self7 1))) orig)) ('Kind.Term.cse (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))(f12 (get self7 6))) orig)) ('Kind.Term.ori (let ((f7 (get self7 1))(f8 (get self7 2))) ($Maybe.some f7))))))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil)))))))) ('Kind.Term.str (let ((f4 (get self4 1))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right func_typ))) (let ((orig (let ((self7 f0)) (case (get self7 0) ('Kind.Term.var (let ((f7 (get self7 1))(f8 (get self7 2))) orig)) ('Kind.Term.ref (let ((f7 (get self7 1))) orig)) ('Kind.Term.typ (let () orig)) ('Kind.Term.all (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))) orig)) ('Kind.Term.lam (let ((f7 (get self7 1))(f8 (get self7 2))) orig)) ('Kind.Term.app (let ((f7 (get self7 1))(f8 (get self7 2))) orig)) ('Kind.Term.let (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.def (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.ann (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.gol (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) orig)) ('Kind.Term.hol (let ((f7 (get self7 1))) orig)) ('Kind.Term.nat (let ((f7 (get self7 1))) orig)) ('Kind.Term.chr (let ((f7 (get self7 1))) orig)) ('Kind.Term.str (let ((f7 (get self7 1))) orig)) ('Kind.Term.cse (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))(f12 (get self7 6))) orig)) ('Kind.Term.ori (let ((f7 (get self7 1))(f8 (get self7 2))) ($Maybe.some f7))))))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil)))))))) ('Kind.Term.cse (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))(f7 (get self4 4))(f8 (get self4 5))(f9 (get self4 6))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right func_typ))) (let ((orig (let ((self12 f0)) (case (get self12 0) ('Kind.Term.var (let ((f12 (get self12 1))(f13 (get self12 2))) orig)) ('Kind.Term.ref (let ((f12 (get self12 1))) orig)) ('Kind.Term.typ (let () orig)) ('Kind.Term.all (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))(f15 (get self12 4))(f16 (get self12 5))) orig)) ('Kind.Term.lam (let ((f12 (get self12 1))(f13 (get self12 2))) orig)) ('Kind.Term.app (let ((f12 (get self12 1))(f13 (get self12 2))) orig)) ('Kind.Term.let (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) orig)) ('Kind.Term.def (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) orig)) ('Kind.Term.ann (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) orig)) ('Kind.Term.gol (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) orig)) ('Kind.Term.hol (let ((f12 (get self12 1))) orig)) ('Kind.Term.nat (let ((f12 (get self12 1))) orig)) ('Kind.Term.chr (let ((f12 (get self12 1))) orig)) ('Kind.Term.str (let ((f12 (get self12 1))) orig)) ('Kind.Term.cse (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))(f15 (get self12 4))(f16 (get self12 5))(f17 (get self12 6))) orig)) ('Kind.Term.ori (let ((f12 (get self12 1))(f13 (get self12 2))) ($Maybe.some f12))))))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil)))))))) ('Kind.Term.ori (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((expected ($Either.left "function"))) (let ((detected ($Either.right func_typ))) (let ((orig (let ((self8 f0)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))(f9 (get self8 2))) orig)) ('Kind.Term.ref (let ((f8 (get self8 1))) orig)) ('Kind.Term.typ (let () orig)) ('Kind.Term.all (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))) orig)) ('Kind.Term.lam (let ((f8 (get self8 1))(f9 (get self8 2))) orig)) ('Kind.Term.app (let ((f8 (get self8 1))(f9 (get self8 2))) orig)) ('Kind.Term.let (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.def (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.ann (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.gol (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) orig)) ('Kind.Term.hol (let ((f8 (get self8 1))) orig)) ('Kind.Term.nat (let ((f8 (get self8 1))) orig)) ('Kind.Term.chr (let ((f8 (get self8 1))) orig)) ('Kind.Term.str (let ((f8 (get self8 1))) orig)) ('Kind.Term.cse (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))(f13 (get self8 6))) orig)) ('Kind.Term.ori (let ((f8 (get self8 1))(f9 (get self8 2))) ($Maybe.some f8))))))) ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig expected detected ctx) ($List.nil))))))))))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((ctx_size ($List.length ctx))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check f1 ($Maybe.none) defs ctx ($Kind.MPath.o path) orig)) (lambda (expr_typ) (let ((body_val (f2 ($Kind.Term.var f0 ctx_size)))) (let ((body_ctx ($List.cons ($Pair.new f0 expr_typ) ctx))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check body_val type defs body_ctx ($Kind.MPath.i path) orig)) (lambda (body_typ) (($Monad.pure ($Kind.Check.monad)) body_typ)))))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((ctx_size ($List.length ctx))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check f1 ($Maybe.none) defs ctx ($Kind.MPath.o path) orig)) (lambda (expr_typ) (let ((body_val (f2 ($Kind.Term.ann ($Bool.true) f1 expr_typ)))) (let ((body_ctx ($List.cons ($Pair.new f0 expr_typ) ctx))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check body_val type defs body_ctx ($Kind.MPath.i path) orig)) (lambda (body_typ) (($Monad.pure ($Kind.Check.monad)) body_typ)))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 f0)) (case self3 (#t (let () (($Monad.pure ($Kind.Check.monad)) f2))) (#f (let () ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check f1 ($Maybe.some f2) defs ctx ($Kind.MPath.o path) orig)) (lambda (-) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check f2 ($Maybe.some ($Kind.Term.typ)) defs ctx ($Kind.MPath.i path) orig)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) f2))))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Check.result type ($List.cons ($Kind.Error.show_goal f0 f1 f2 type ctx) ($List.nil))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Check.result type ($List.nil)))) ('Kind.Term.nat (let ((f0 (get self0 1))) (($Monad.pure ($Kind.Check.monad)) ($Kind.Term.ref "Nat")))) ('Kind.Term.chr (let ((f0 (get self0 1))) (($Monad.pure ($Kind.Check.monad)) ($Kind.Term.ref "Char")))) ('Kind.Term.str (let ((f0 (get self0 1))) (($Monad.pure ($Kind.Check.monad)) ($Kind.Term.ref "String")))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((expr f1)) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check expr ($Maybe.none) defs ctx ($Kind.MPath.o path) orig)) (lambda (etyp) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check.infer_with_types f3 defs ctx path orig)) (lambda (wyth) (let ((dsug ($Kind.Term.desugar_cse f1 f2 wyth f4 f5 etyp type defs ctx))) (let ((self10 dsug)) (case (get self10 0) ('Maybe.none (let () ($Kind.Check.result type ($List.cons ($Kind.Error.cant_infer orig term ctx) ($List.nil))))) ('Maybe.some (let ((f10 (get self10 1))) ($Kind.Check.result type ($List.cons ($Kind.Error.patch ($Kind.MPath.to_bits path) f10) ($List.nil))))))))))))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.check f1 type defs ctx path ($Maybe.some f0))))))) (lambda (infr) (let ((self1 type)) (case (get self1 0) ('Maybe.none (let () ($Kind.Check.result ($Maybe.some infr) ($List.nil)))) ('Maybe.some (let ((f1 (get self1 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.go f1 infr defs ($List.length ctx) ($BitsSet.mut.new ($Unit.new)))) (lambda (eqls) (let ((self3 eqls)) (case self3 (#t (let () (($Monad.pure ($Kind.Check.monad)) f1))) (#f (let () ($Kind.Check.result type ($List.cons ($Kind.Error.type_mismatch orig ($Either.right f1) ($Either.right infr) ctx) ($List.nil))))))))))))))))
(define (Kind.Term.check) (lambda (term) (lambda (type) (lambda (defs) (lambda (ctx) (lambda (path) (lambda (orig) ($Kind.Term.check term type defs ctx path orig))))))))
(define ($Kind.Term.check.infer_with_types vars defs ctx path orig) (let ((self0 vars)) (case (get self0 0) ('List.nil (let () (($Monad.pure ($Kind.Check.monad)) ($List.nil)))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Ann.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ((($Monad.bind ($Kind.Check.monad)) (let ((self5 f4)) (case (get self5 0) ('Maybe.none (let () ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check f3 ($Maybe.none) defs ctx path orig)) (lambda (infer) (($Monad.pure ($Kind.Check.monad)) ($Maybe.some infer)))))) ('Maybe.some (let ((f5 (get self5 1))) (($Monad.pure ($Kind.Check.monad)) ($Maybe.some f5))))))) (lambda (type) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.check.infer_with_types f1 defs ctx path orig)) (lambda (rest) (($Monad.pure ($Kind.Check.monad)) ($List.cons ($Kind.Ann.new f2 f3 type) rest)))))))))))))))
(define (Kind.Term.check.infer_with_types) (lambda (vars) (lambda (defs) (lambda (ctx) (lambda (path) (lambda (orig) ($Kind.Term.check.infer_with_types vars defs ctx path orig)))))))
(define ($Kind.Term.chr chrx) (vector 'Kind.Term.chr chrx))
(define (Kind.Term.chr) (lambda (chrx) ($Kind.Term.chr chrx)))
(define ($Kind.Term.cse path expr name with cses moti) (vector 'Kind.Term.cse path expr name with cses moti))
(define (Kind.Term.cse) (lambda (path) (lambda (expr) (lambda (name) (lambda (with) (lambda (cses) (lambda (moti) ($Kind.Term.cse path expr name with cses moti))))))))
(define ($Kind.Term.def name expr body) (vector 'Kind.Term.def name expr body))
(define (Kind.Term.def) (lambda (name) (lambda (expr) (lambda (body) ($Kind.Term.def name expr body)))))
(define ($Kind.Term.desugar_cse expr name wyth cses moti etyp rtyp defs ctxt) (let ((self0 ($Kind.Term.reduce etyp defs))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Maybe.none))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Maybe.none))) ('Kind.Term.typ (let () ($Maybe.none))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((moti ($Kind.Term.desugar_cse.motive wyth moti name expr etyp rtyp defs ($List.length ctxt)))) (let ((argm ($Kind.Term.desugar_cse.argument name ($List.nil) f3 moti defs))) (let ((expr ($Kind.Term.app expr argm))) (let ((type ((f4 ($Kind.Term.var f1 0)) ($Kind.Term.var f2 0)))) ($Maybe.some ($Kind.Term.desugar_cse.cases expr name wyth cses type defs ctxt)))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($Maybe.none))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Maybe.none))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Maybe.none))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Maybe.none))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Maybe.none))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Maybe.none))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Maybe.none))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Maybe.none))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Maybe.none))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Maybe.none))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) ($Maybe.none))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Maybe.none))))))
(define (Kind.Term.desugar_cse) (lambda (expr) (lambda (name) (lambda (wyth) (lambda (cses) (lambda (moti) (lambda (etyp) (lambda (rtyp) (lambda (defs) (lambda (ctxt) ($Kind.Term.desugar_cse expr name wyth cses moti etyp rtyp defs ctxt)))))))))))
(define ($Kind.Term.desugar_cse.argument name wyth type body defs) (let ((self0 ($Kind.Term.reduce type defs))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 wyth)) (case (get self2 0) ('List.nil (let () body)) ('List.cons (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) ($Kind.Term.lam f4 (lambda (x) ($Kind.Term.desugar_cse.argument name f3 type body defs))))))))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 wyth)) (case (get self1 0) ('List.nil (let () body)) ('List.cons (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x) ($Kind.Term.desugar_cse.argument name f2 type body defs))))))))))))) ('Kind.Term.typ (let () (let ((self0 wyth)) (case (get self0 0) ('List.nil (let () body)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Ann.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.lam f2 (lambda (x) ($Kind.Term.desugar_cse.argument name f1 type body defs))))))))))))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Kind.Term.lam (let ((self5 ($String.is_empty f2))) (case self5 (#t (let () name)) (#f (let () ($String.flatten ($List.cons name ($List.cons "." ($List.cons f2 ($List.nil))))))))) (lambda (x) ($Kind.Term.desugar_cse.argument name wyth ((f4 ($Kind.Term.var f1 0)) ($Kind.Term.var f2 0)) body defs))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 wyth)) (case (get self2 0) ('List.nil (let () body)) ('List.cons (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) ($Kind.Term.lam f4 (lambda (x) ($Kind.Term.desugar_cse.argument name f3 type body defs))))))))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 wyth)) (case (get self2 0) ('List.nil (let () body)) ('List.cons (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) ($Kind.Term.lam f4 (lambda (x) ($Kind.Term.desugar_cse.argument name f3 type body defs))))))))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 wyth)) (case (get self3 0) ('List.nil (let () body)) ('List.cons (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Kind.Term.lam f5 (lambda (x) ($Kind.Term.desugar_cse.argument name f4 type body defs))))))))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 wyth)) (case (get self3 0) ('List.nil (let () body)) ('List.cons (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Kind.Term.lam f5 (lambda (x) ($Kind.Term.desugar_cse.argument name f4 type body defs))))))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 wyth)) (case (get self3 0) ('List.nil (let () body)) ('List.cons (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Kind.Term.lam f5 (lambda (x) ($Kind.Term.desugar_cse.argument name f4 type body defs))))))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 wyth)) (case (get self3 0) ('List.nil (let () body)) ('List.cons (let ((f3 (get self3 1))(f4 (get self3 2))) (let ((self5 f3)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Kind.Term.lam f5 (lambda (x) ($Kind.Term.desugar_cse.argument name f4 type body defs))))))))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) (let ((self1 wyth)) (case (get self1 0) ('List.nil (let () body)) ('List.cons (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x) ($Kind.Term.desugar_cse.argument name f2 type body defs))))))))))))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((self1 wyth)) (case (get self1 0) ('List.nil (let () body)) ('List.cons (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x) ($Kind.Term.desugar_cse.argument name f2 type body defs))))))))))))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((self1 wyth)) (case (get self1 0) ('List.nil (let () body)) ('List.cons (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x) ($Kind.Term.desugar_cse.argument name f2 type body defs))))))))))))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((self1 wyth)) (case (get self1 0) ('List.nil (let () body)) ('List.cons (let ((f1 (get self1 1))(f2 (get self1 2))) (let ((self3 f1)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Kind.Term.lam f3 (lambda (x) ($Kind.Term.desugar_cse.argument name f2 type body defs))))))))))))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((self6 wyth)) (case (get self6 0) ('List.nil (let () body)) ('List.cons (let ((f6 (get self6 1))(f7 (get self6 2))) (let ((self8 f6)) (case (get self8 0) ('Kind.Ann.new (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) ($Kind.Term.lam f8 (lambda (x) ($Kind.Term.desugar_cse.argument name f7 type body defs))))))))))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 wyth)) (case (get self2 0) ('List.nil (let () body)) ('List.cons (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f2)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) ($Kind.Term.lam f4 (lambda (x) ($Kind.Term.desugar_cse.argument name f3 type body defs))))))))))))))))
(define (Kind.Term.desugar_cse.argument) (lambda (name) (lambda (wyth) (lambda (type) (lambda (body) (lambda (defs) ($Kind.Term.desugar_cse.argument name wyth type body defs)))))))
(define ($Kind.Term.desugar_cse.cases expr name wyth cses type defs ctxt) (let ((self0 ($Kind.Term.reduce type defs))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((expr ($List.for wyth expr (lambda (defn) (lambda (expr) ($Kind.Term.app expr (let ((self4 defn)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) f5)))))))))) expr))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((expr ($List.for wyth expr (lambda (defn) (lambda (expr) ($Kind.Term.app expr (let ((self3 defn)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) f4)))))))))) expr))) ('Kind.Term.typ (let () (let ((expr ($List.for wyth expr (lambda (defn) (lambda (expr) ($Kind.Term.app expr (let ((self2 defn)) (case (get self2 0) ('Kind.Ann.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) f3)))))))))) expr))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((argm ($Maybe.or ($Kind.Map.get f2 cses) ($Kind.Map.get "_" cses)))) (let ((argm ($Maybe.default argm ($Kind.Term.ref ($String.concat name ($String.concat "_" ($String.concat f2 "_case"))))))) (let ((argm ($Kind.Term.desugar_cse.argument name wyth f3 argm defs))) (let ((expr ($Kind.Term.app expr argm))) (let ((type ((f4 ($Kind.Term.var f1 0)) ($Kind.Term.var f2 0)))) ($Kind.Term.desugar_cse.cases expr name wyth cses type defs ctxt)))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((expr ($List.for wyth expr (lambda (defn) (lambda (expr) ($Kind.Term.app expr (let ((self4 defn)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) f5)))))))))) expr))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((expr ($List.for wyth expr (lambda (defn) (lambda (expr) ($Kind.Term.app expr (let ((self4 defn)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) f5)))))))))) expr))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((expr ($List.for wyth expr (lambda (defn) (lambda (expr) ($Kind.Term.app expr (let ((self5 defn)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) f6)))))))))) expr))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((expr ($List.for wyth expr (lambda (defn) (lambda (expr) ($Kind.Term.app expr (let ((self5 defn)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) f6)))))))))) expr))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((expr ($List.for wyth expr (lambda (defn) (lambda (expr) ($Kind.Term.app expr (let ((self5 defn)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) f6)))))))))) expr))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((expr ($List.for wyth expr (lambda (defn) (lambda (expr) ($Kind.Term.app expr (let ((self5 defn)) (case (get self5 0) ('Kind.Ann.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) f6)))))))))) expr))) ('Kind.Term.hol (let ((f0 (get self0 1))) (let ((expr ($List.for wyth expr (lambda (defn) (lambda (expr) ($Kind.Term.app expr (let ((self3 defn)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) f4)))))))))) expr))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((expr ($List.for wyth expr (lambda (defn) (lambda (expr) ($Kind.Term.app expr (let ((self3 defn)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) f4)))))))))) expr))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((expr ($List.for wyth expr (lambda (defn) (lambda (expr) ($Kind.Term.app expr (let ((self3 defn)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) f4)))))))))) expr))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((expr ($List.for wyth expr (lambda (defn) (lambda (expr) ($Kind.Term.app expr (let ((self3 defn)) (case (get self3 0) ('Kind.Ann.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) f4)))))))))) expr))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((expr ($List.for wyth expr (lambda (defn) (lambda (expr) ($Kind.Term.app expr (let ((self8 defn)) (case (get self8 0) ('Kind.Ann.new (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) f9)))))))))) expr))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((expr ($List.for wyth expr (lambda (defn) (lambda (expr) ($Kind.Term.app expr (let ((self4 defn)) (case (get self4 0) ('Kind.Ann.new (let ((f4 (get self4 1))(f5 (get self4 2))(f6 (get self4 3))) f5)))))))))) expr))))))
(define (Kind.Term.desugar_cse.cases) (lambda (expr) (lambda (name) (lambda (wyth) (lambda (cses) (lambda (type) (lambda (defs) (lambda (ctxt) ($Kind.Term.desugar_cse.cases expr name wyth cses type defs ctxt)))))))))
(define ($Kind.Term.desugar_cse.motive wyth moti name expr etyp rtyp defs size) (let ((done ($Kind.Term.desugar_cse.motive.go wyth moti name expr etyp rtyp defs size))) (let ((self1 moti)) (case (get self1 0) ('Maybe.none (let () ($Kind.Term.SmartMotive.make name expr etyp done size defs))) ('Maybe.some (let ((f1 (get self1 1))) done))))))
(define (Kind.Term.desugar_cse.motive) (lambda (wyth) (lambda (moti) (lambda (name) (lambda (expr) (lambda (etyp) (lambda (rtyp) (lambda (defs) (lambda (size) ($Kind.Term.desugar_cse.motive wyth moti name expr etyp rtyp defs size))))))))))
(define ($Kind.Term.desugar_cse.motive.go wyth moti name expr etyp rtyp defs size) (let ((self0 wyth)) (case (get self0 0) ('List.nil (let () (let ((self0 moti)) (case (get self0 0) ('Maybe.none (let () (let ((self0 rtyp)) (case (get self0 0) ('Maybe.none (let () ($Kind.Term.hol ($Bits.e)))) ('Maybe.some (let ((f0 (get self0 1))) ($Kind.Term.normalize f0 ($Kind.Map.new)))))))) ('Maybe.some (let ((f0 (get self0 1))) f0)))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Ann.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Kind.Term.all ($Bool.false) "" f2 ($Maybe.default f4 ($Kind.Term.hol ($Bits.e))) (lambda (s) (lambda (x) ($Kind.Term.desugar_cse.motive f1 moti name expr etyp rtyp defs ($Nat.succ ($Nat.succ size)))))))))))))))
(define (Kind.Term.desugar_cse.motive.go) (lambda (wyth) (lambda (moti) (lambda (name) (lambda (expr) (lambda (etyp) (lambda (rtyp) (lambda (defs) (lambda (size) ($Kind.Term.desugar_cse.motive.go wyth moti name expr etyp rtyp defs size))))))))))
(define ($Kind.Term.equal a b defs) '())
(define (Kind.Term.equal) (lambda (a) (lambda (b) (lambda (defs) ($Kind.Term.equal a b defs)))))
(define ($Kind.Term.equal.extra_holes a b) (let ((self0 ($Kind.Term.equal.extra_holes.funari a 0))) (case (get self0 0) ('Maybe.none (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.equal.extra_holes.funari b 0))) (case (get self1 0) ('Maybe.none (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Maybe.some (let ((f1 (get self1 1))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((self4 f1)) (case (get self4 0) ('Pair.new (let ((f4 (get self4 1))(f5 (get self4 2))) (let ((same_fun ($String.eql f2 f4))) (let ((same_ari ($Nat.eql f3 f5))) (let ((self8 ($Bool.and same_fun same_ari))) (case self8 (#t (let () ($Kind.Term.equal.extra_holes.filler a b))) (#f (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))))))))))))))))))))))
(define (Kind.Term.equal.extra_holes) (lambda (a) (lambda (b) ($Kind.Term.equal.extra_holes a b))))
(define ($Kind.Term.equal.extra_holes.filler a b) (let ((self0 a)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 b)) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))(f3 (get self2 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ref (let ((f2 (get self2 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.all (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.lam (let ((f2 (get self2 1))(f3 (get self2 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.app (let ((f2 (get self2 1))(f3 (get self2 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.let (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.def (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ann (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.gol (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.hol (let ((f2 (get self2 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.hole f2 a)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))) ('Kind.Term.nat (let ((f2 (get self2 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.chr (let ((f2 (get self2 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.str (let ((f2 (get self2 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.cse (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))(f7 (get self2 6))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ori (let ((f2 (get self2 1))(f3 (get self2 2))) ($Kind.Term.equal.extra_holes.filler a f3))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 b)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))(f2 (get self1 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ref (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.all (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.lam (let ((f1 (get self1 1))(f2 (get self1 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.app (let ((f1 (get self1 1))(f2 (get self1 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.let (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.def (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ann (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.gol (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.hol (let ((f1 (get self1 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.hole f1 a)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))) ('Kind.Term.nat (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.chr (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.str (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.cse (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ori (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Term.equal.extra_holes.filler a f2))))))) ('Kind.Term.typ (let () (let ((self0 b)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ref (let ((f0 (get self0 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.hol (let ((f0 (get self0 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.hole f0 a)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))) ('Kind.Term.nat (let ((f0 (get self0 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.chr (let ((f0 (get self0 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.str (let ((f0 (get self0 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.equal.extra_holes.filler a f1))))))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((self5 b)) (case (get self5 0) ('Kind.Term.var (let ((f5 (get self5 1))(f6 (get self5 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ref (let ((f5 (get self5 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.all (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))(f8 (get self5 4))(f9 (get self5 5))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.lam (let ((f5 (get self5 1))(f6 (get self5 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.app (let ((f5 (get self5 1))(f6 (get self5 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.let (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.def (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ann (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.gol (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.hol (let ((f5 (get self5 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.hole f5 a)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))) ('Kind.Term.nat (let ((f5 (get self5 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.chr (let ((f5 (get self5 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.str (let ((f5 (get self5 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.cse (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))(f8 (get self5 4))(f9 (get self5 5))(f10 (get self5 6))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ori (let ((f5 (get self5 1))(f6 (get self5 2))) ($Kind.Term.equal.extra_holes.filler a f6))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 b)) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))(f3 (get self2 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ref (let ((f2 (get self2 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.all (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.lam (let ((f2 (get self2 1))(f3 (get self2 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.app (let ((f2 (get self2 1))(f3 (get self2 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.let (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.def (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ann (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.gol (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.hol (let ((f2 (get self2 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.hole f2 a)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))) ('Kind.Term.nat (let ((f2 (get self2 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.chr (let ((f2 (get self2 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.str (let ((f2 (get self2 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.cse (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))(f7 (get self2 6))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ori (let ((f2 (get self2 1))(f3 (get self2 2))) ($Kind.Term.equal.extra_holes.filler a f3))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 b)) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))(f3 (get self2 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ref (let ((f2 (get self2 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.all (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.lam (let ((f2 (get self2 1))(f3 (get self2 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.app (let ((f2 (get self2 1))(f3 (get self2 2))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.extra_holes.filler f0 f2)) (lambda (-) ($Kind.Term.equal.extra_holes.filler f1 f3))))) ('Kind.Term.let (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.def (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ann (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.gol (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.hol (let ((f2 (get self2 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.hole f2 a)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))) ('Kind.Term.nat (let ((f2 (get self2 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.chr (let ((f2 (get self2 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.str (let ((f2 (get self2 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.cse (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))(f7 (get self2 6))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ori (let ((f2 (get self2 1))(f3 (get self2 2))) ($Kind.Term.equal.extra_holes.filler a f3))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 b)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))(f4 (get self3 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ref (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.all (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.lam (let ((f3 (get self3 1))(f4 (get self3 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.app (let ((f3 (get self3 1))(f4 (get self3 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.let (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.def (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ann (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.gol (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.hol (let ((f3 (get self3 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.hole f3 a)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))) ('Kind.Term.nat (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.chr (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.str (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.cse (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))(f8 (get self3 6))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ori (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Term.equal.extra_holes.filler a f4))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 b)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))(f4 (get self3 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ref (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.all (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.lam (let ((f3 (get self3 1))(f4 (get self3 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.app (let ((f3 (get self3 1))(f4 (get self3 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.let (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.def (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ann (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.gol (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.hol (let ((f3 (get self3 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.hole f3 a)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))) ('Kind.Term.nat (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.chr (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.str (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.cse (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))(f8 (get self3 6))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ori (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Term.equal.extra_holes.filler a f4))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 b)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))(f4 (get self3 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ref (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.all (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.lam (let ((f3 (get self3 1))(f4 (get self3 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.app (let ((f3 (get self3 1))(f4 (get self3 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.let (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.def (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ann (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.gol (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.hol (let ((f3 (get self3 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.hole f3 a)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))) ('Kind.Term.nat (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.chr (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.str (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.cse (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))(f8 (get self3 6))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ori (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Term.equal.extra_holes.filler a f4))))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 b)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))(f4 (get self3 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ref (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.all (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.lam (let ((f3 (get self3 1))(f4 (get self3 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.app (let ((f3 (get self3 1))(f4 (get self3 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.let (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.def (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ann (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.gol (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.hol (let ((f3 (get self3 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.hole f3 a)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))) ('Kind.Term.nat (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.chr (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.str (let ((f3 (get self3 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.cse (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))(f8 (get self3 6))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ori (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Term.equal.extra_holes.filler a f4))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.hole f0 b)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((self1 b)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))(f2 (get self1 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ref (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.all (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.lam (let ((f1 (get self1 1))(f2 (get self1 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.app (let ((f1 (get self1 1))(f2 (get self1 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.let (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.def (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ann (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.gol (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.hol (let ((f1 (get self1 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.hole f1 a)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))) ('Kind.Term.nat (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.chr (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.str (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.cse (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ori (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Term.equal.extra_holes.filler a f2))))))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((self1 b)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))(f2 (get self1 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ref (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.all (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.lam (let ((f1 (get self1 1))(f2 (get self1 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.app (let ((f1 (get self1 1))(f2 (get self1 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.let (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.def (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ann (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.gol (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.hol (let ((f1 (get self1 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.hole f1 a)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))) ('Kind.Term.nat (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.chr (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.str (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.cse (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ori (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Term.equal.extra_holes.filler a f2))))))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((self1 b)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))(f2 (get self1 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ref (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.all (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.lam (let ((f1 (get self1 1))(f2 (get self1 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.app (let ((f1 (get self1 1))(f2 (get self1 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.let (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.def (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ann (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.gol (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.hol (let ((f1 (get self1 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.hole f1 a)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))) ('Kind.Term.nat (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.chr (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.str (let ((f1 (get self1 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.cse (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ori (let ((f1 (get self1 1))(f2 (get self1 2))) ($Kind.Term.equal.extra_holes.filler a f2))))))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((self6 b)) (case (get self6 0) ('Kind.Term.var (let ((f6 (get self6 1))(f7 (get self6 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ref (let ((f6 (get self6 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.all (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))(f9 (get self6 4))(f10 (get self6 5))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.lam (let ((f6 (get self6 1))(f7 (get self6 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.app (let ((f6 (get self6 1))(f7 (get self6 2))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.let (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.def (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ann (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.gol (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.hol (let ((f6 (get self6 1))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.hole f6 a)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))))) ('Kind.Term.nat (let ((f6 (get self6 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.chr (let ((f6 (get self6 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.str (let ((f6 (get self6 1))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.cse (let ((f6 (get self6 1))(f7 (get self6 2))(f8 (get self6 3))(f9 (get self6 4))(f10 (get self6 5))(f11 (get self6 6))) (($Monad.pure ($Kind.Check.monad)) ($Unit.new)))) ('Kind.Term.ori (let ((f6 (get self6 1))(f7 (get self6 2))) ($Kind.Term.equal.extra_holes.filler a f7))))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.equal.extra_holes.filler f1 b))))))
(define (Kind.Term.equal.extra_holes.filler) (lambda (a) (lambda (b) ($Kind.Term.equal.extra_holes.filler a b))))
(define ($Kind.Term.equal.extra_holes.funari term arity) (let ((self0 term)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Maybe.some ($Pair.new f0 arity)))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Maybe.some ($Pair.new f0 arity)))) ('Kind.Term.typ (let () ($Maybe.none))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Maybe.none))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($Maybe.none))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.equal.extra_holes.funari f0 ($Nat.succ arity)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Maybe.none))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Maybe.none))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Maybe.none))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Maybe.none))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Maybe.none))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Maybe.none))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Maybe.none))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Maybe.none))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) ($Maybe.none))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.equal.extra_holes.funari f1 arity))))))
(define (Kind.Term.equal.extra_holes.funari) (lambda (term) (lambda (arity) ($Kind.Term.equal.extra_holes.funari term arity))))
(define ($Kind.Term.equal.go a b defs lv seen) (let ((ah ($Kind.Term.serialize ($Kind.Term.reduce a ($Kind.Map.new)) lv ($Bool.false)))) (let ((bh ($Kind.Term.serialize ($Kind.Term.reduce b ($Kind.Map.new)) lv ($Bool.true)))) (let ((self2 ($Bits.eql ah bh))) (case self2 (#t (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.true)))) (#f (let () (let ((a1 ($Kind.Term.reduce a defs))) (let ((b1 ($Kind.Term.reduce b defs))) (let ((ah ($Kind.Term.serialize a1 lv ($Bool.false)))) (let ((bh ($Kind.Term.serialize b1 lv ($Bool.true)))) (let ((self6 ($Bits.eql ah bh))) (case self6 (#t (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.true)))) (#f (let () (let ((id ($Bits.concat ah bh))) (let ((self7 ($BitsSet.mut.has id seen))) (case self7 (#t (let () ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.extra_holes a b)) (lambda (-) (($Monad.pure ($Kind.Check.monad)) ($Bool.true)))))) (#f (let () (let ((self7 a1)) (case (get self7 0) ('Kind.Term.var (let ((f7 (get self7 1))(f8 (get self7 2))) (let ((self9 b1)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ref (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.hol (let ((f9 (get self9 1))) ($Kind.Term.equal.hole f9 a))) ('Kind.Term.nat (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.chr (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.str (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))))))) ('Kind.Term.ref (let ((f7 (get self7 1))) (let ((self8 b1)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ref (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.all (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.lam (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.app (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.let (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.def (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ann (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.gol (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.hol (let ((f8 (get self8 1))) ($Kind.Term.equal.hole f8 a))) ('Kind.Term.nat (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.chr (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.str (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.cse (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))(f13 (get self8 6))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ori (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))))))) ('Kind.Term.typ (let () (let ((self7 b1)) (case (get self7 0) ('Kind.Term.var (let ((f7 (get self7 1))(f8 (get self7 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ref (let ((f7 (get self7 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.all (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.lam (let ((f7 (get self7 1))(f8 (get self7 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.app (let ((f7 (get self7 1))(f8 (get self7 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.let (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.def (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ann (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.gol (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.hol (let ((f7 (get self7 1))) ($Kind.Term.equal.hole f7 a))) ('Kind.Term.nat (let ((f7 (get self7 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.chr (let ((f7 (get self7 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.str (let ((f7 (get self7 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.cse (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))(f12 (get self7 6))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ori (let ((f7 (get self7 1))(f8 (get self7 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))))))) ('Kind.Term.all (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))) (let ((self12 b1)) (case (get self12 0) ('Kind.Term.var (let ((f12 (get self12 1))(f13 (get self12 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ref (let ((f12 (get self12 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.all (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))(f15 (get self12 4))(f16 (get self12 5))) (let ((seen ($BitsSet.mut.set id seen))) (let ((a1_body ((f11 ($Kind.Term.var f8 lv)) ($Kind.Term.var f9 ($Nat.succ lv))))) (let ((b1_body ((f16 ($Kind.Term.var f13 lv)) ($Kind.Term.var f14 ($Nat.succ lv))))) (let ((eq_self ($String.eql f8 f13))) (let ((eq_eras ($Bool.eql f7 f12))) (let ((self22 ($Bool.and eq_self eq_eras))) (case self22 (#t (let () ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.go f10 f15 defs lv seen)) (lambda (eq_type) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.go a1_body b1_body defs ($Nat.succ ($Nat.succ lv)) seen)) (lambda (eq_body) (($Monad.pure ($Kind.Check.monad)) ($Bool.and eq_type eq_body)))))))) (#f (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false))))))))))))) ('Kind.Term.lam (let ((f12 (get self12 1))(f13 (get self12 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.app (let ((f12 (get self12 1))(f13 (get self12 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.let (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.def (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ann (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.gol (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.hol (let ((f12 (get self12 1))) ($Kind.Term.equal.hole f12 a))) ('Kind.Term.nat (let ((f12 (get self12 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.chr (let ((f12 (get self12 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.str (let ((f12 (get self12 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.cse (let ((f12 (get self12 1))(f13 (get self12 2))(f14 (get self12 3))(f15 (get self12 4))(f16 (get self12 5))(f17 (get self12 6))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ori (let ((f12 (get self12 1))(f13 (get self12 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))))))) ('Kind.Term.lam (let ((f7 (get self7 1))(f8 (get self7 2))) (let ((self9 b1)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ref (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) (let ((seen ($BitsSet.mut.set id seen))) (let ((a1_body (f8 ($Kind.Term.var f7 lv)))) (let ((b1_body (f10 ($Kind.Term.var f9 lv)))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.go a1_body b1_body defs ($Nat.succ lv) seen)) (lambda (eq_body) (($Monad.pure ($Kind.Check.monad)) eq_body)))))))) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.hol (let ((f9 (get self9 1))) ($Kind.Term.equal.hole f9 a))) ('Kind.Term.nat (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.chr (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.str (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))))))) ('Kind.Term.app (let ((f7 (get self7 1))(f8 (get self7 2))) (let ((self9 b1)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ref (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) (let ((seen ($BitsSet.mut.set id seen))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.go f7 f9 defs lv seen)) (lambda (eq_func) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.go f8 f10 defs lv seen)) (lambda (eq_argm) (($Monad.pure ($Kind.Check.monad)) ($Bool.and eq_func eq_argm))))))))) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.hol (let ((f9 (get self9 1))) ($Kind.Term.equal.hole f9 a))) ('Kind.Term.nat (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.chr (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.str (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))))))) ('Kind.Term.let (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) (let ((self10 b1)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ref (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.all (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.lam (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.app (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.let (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (let ((seen ($BitsSet.mut.set id seen))) (let ((a1_body (f9 ($Kind.Term.var f7 lv)))) (let ((b1_body (f12 ($Kind.Term.var f10 lv)))) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.go f8 f11 defs lv seen)) (lambda (eq_expr) ((($Monad.bind ($Kind.Check.monad)) ($Kind.Term.equal.go a1_body b1_body defs ($Nat.succ lv) seen)) (lambda (eq_body) (($Monad.pure ($Kind.Check.monad)) ($Bool.and eq_expr eq_body))))))))))) ('Kind.Term.def (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ann (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.gol (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.hol (let ((f10 (get self10 1))) ($Kind.Term.equal.hole f10 a))) ('Kind.Term.nat (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.chr (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.str (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.cse (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))(f15 (get self10 6))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ori (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))))))) ('Kind.Term.def (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) (let ((self10 b1)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ref (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.all (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.lam (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.app (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.let (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.def (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ann (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.gol (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.hol (let ((f10 (get self10 1))) ($Kind.Term.equal.hole f10 a))) ('Kind.Term.nat (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.chr (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.str (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.cse (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))(f15 (get self10 6))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ori (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))))))) ('Kind.Term.ann (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) (let ((self10 b1)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ref (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.all (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.lam (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.app (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.let (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.def (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ann (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.gol (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.hol (let ((f10 (get self10 1))) ($Kind.Term.equal.hole f10 a))) ('Kind.Term.nat (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.chr (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.str (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.cse (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))(f15 (get self10 6))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ori (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))))))) ('Kind.Term.gol (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))) (let ((self10 b1)) (case (get self10 0) ('Kind.Term.var (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ref (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.all (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.lam (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.app (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.let (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.def (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ann (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.gol (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.hol (let ((f10 (get self10 1))) ($Kind.Term.equal.hole f10 a))) ('Kind.Term.nat (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.chr (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.str (let ((f10 (get self10 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.cse (let ((f10 (get self10 1))(f11 (get self10 2))(f12 (get self10 3))(f13 (get self10 4))(f14 (get self10 5))(f15 (get self10 6))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ori (let ((f10 (get self10 1))(f11 (get self10 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))))))) ('Kind.Term.hol (let ((f7 (get self7 1))) ($Kind.Term.equal.hole f7 b))) ('Kind.Term.nat (let ((f7 (get self7 1))) (let ((self8 b1)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ref (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.all (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.lam (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.app (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.let (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.def (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ann (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.gol (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.hol (let ((f8 (get self8 1))) ($Kind.Term.equal.hole f8 a))) ('Kind.Term.nat (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.chr (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.str (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.cse (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))(f13 (get self8 6))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ori (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))))))) ('Kind.Term.chr (let ((f7 (get self7 1))) (let ((self8 b1)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ref (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.all (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.lam (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.app (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.let (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.def (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ann (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.gol (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.hol (let ((f8 (get self8 1))) ($Kind.Term.equal.hole f8 a))) ('Kind.Term.nat (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.chr (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.str (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.cse (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))(f13 (get self8 6))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ori (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))))))) ('Kind.Term.str (let ((f7 (get self7 1))) (let ((self8 b1)) (case (get self8 0) ('Kind.Term.var (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ref (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.all (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.lam (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.app (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.let (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.def (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ann (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.gol (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.hol (let ((f8 (get self8 1))) ($Kind.Term.equal.hole f8 a))) ('Kind.Term.nat (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.chr (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.str (let ((f8 (get self8 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.cse (let ((f8 (get self8 1))(f9 (get self8 2))(f10 (get self8 3))(f11 (get self8 4))(f12 (get self8 5))(f13 (get self8 6))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ori (let ((f8 (get self8 1))(f9 (get self8 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))))))) ('Kind.Term.cse (let ((f7 (get self7 1))(f8 (get self7 2))(f9 (get self7 3))(f10 (get self7 4))(f11 (get self7 5))(f12 (get self7 6))) (let ((self13 b1)) (case (get self13 0) ('Kind.Term.var (let ((f13 (get self13 1))(f14 (get self13 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ref (let ((f13 (get self13 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.all (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))(f16 (get self13 4))(f17 (get self13 5))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.lam (let ((f13 (get self13 1))(f14 (get self13 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.app (let ((f13 (get self13 1))(f14 (get self13 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.let (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.def (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ann (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.gol (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.hol (let ((f13 (get self13 1))) ($Kind.Term.equal.hole f13 a))) ('Kind.Term.nat (let ((f13 (get self13 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.chr (let ((f13 (get self13 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.str (let ((f13 (get self13 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.cse (let ((f13 (get self13 1))(f14 (get self13 2))(f15 (get self13 3))(f16 (get self13 4))(f17 (get self13 5))(f18 (get self13 6))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ori (let ((f13 (get self13 1))(f14 (get self13 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))))))) ('Kind.Term.ori (let ((f7 (get self7 1))(f8 (get self7 2))) (let ((self9 b1)) (case (get self9 0) ('Kind.Term.var (let ((f9 (get self9 1))(f10 (get self9 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ref (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.typ (let () (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.all (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.lam (let ((f9 (get self9 1))(f10 (get self9 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.app (let ((f9 (get self9 1))(f10 (get self9 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.let (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.def (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ann (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.gol (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.hol (let ((f9 (get self9 1))) ($Kind.Term.equal.hole f9 a))) ('Kind.Term.nat (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.chr (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.str (let ((f9 (get self9 1))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.cse (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))(f12 (get self9 4))(f13 (get self9 5))(f14 (get self9 6))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false)))) ('Kind.Term.ori (let ((f9 (get self9 1))(f10 (get self9 2))) (($Monad.pure ($Kind.Check.monad)) ($Bool.false))))))))))))))))))))))))))))))
(define (Kind.Term.equal.go) (lambda (a) (lambda (b) (lambda (defs) (lambda (lv) (lambda (seen) ($Kind.Term.equal.go a b defs lv seen)))))))
(define ($Kind.Term.equal.hole path term) (let ((self0 term)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($Kind.Term.has_holes term))) (case self2 (#t (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) (#f (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.cons ($Kind.Error.patch path ($Kind.Term.normalize term ($Kind.Map.new))) ($List.nil))))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.has_holes term))) (case self1 (#t (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) (#f (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.cons ($Kind.Error.patch path ($Kind.Term.normalize term ($Kind.Map.new))) ($List.nil))))))))) ('Kind.Term.typ (let () (let ((self0 ($Kind.Term.has_holes term))) (case self0 (#t (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) (#f (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.cons ($Kind.Error.patch path ($Kind.Term.normalize term ($Kind.Map.new))) ($List.nil))))))))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((self5 ($Kind.Term.has_holes term))) (case self5 (#t (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) (#f (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.cons ($Kind.Error.patch path ($Kind.Term.normalize term ($Kind.Map.new))) ($List.nil))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($Kind.Term.has_holes term))) (case self2 (#t (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) (#f (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.cons ($Kind.Error.patch path ($Kind.Term.normalize term ($Kind.Map.new))) ($List.nil))))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($Kind.Term.has_holes term))) (case self2 (#t (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) (#f (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.cons ($Kind.Error.patch path ($Kind.Term.normalize term ($Kind.Map.new))) ($List.nil))))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Term.has_holes term))) (case self3 (#t (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) (#f (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.cons ($Kind.Error.patch path ($Kind.Term.normalize term ($Kind.Map.new))) ($List.nil))))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Term.has_holes term))) (case self3 (#t (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) (#f (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.cons ($Kind.Error.patch path ($Kind.Term.normalize term ($Kind.Map.new))) ($List.nil))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Term.has_holes term))) (case self3 (#t (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) (#f (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.cons ($Kind.Error.patch path ($Kind.Term.normalize term ($Kind.Map.new))) ($List.nil))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 ($Kind.Term.has_holes term))) (case self3 (#t (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) (#f (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.cons ($Kind.Error.patch path ($Kind.Term.normalize term ($Kind.Map.new))) ($List.nil))))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.has_holes term))) (case self1 (#t (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) (#f (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.cons ($Kind.Error.patch path ($Kind.Term.normalize term ($Kind.Map.new))) ($List.nil))))))))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.has_holes term))) (case self1 (#t (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) (#f (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.cons ($Kind.Error.patch path ($Kind.Term.normalize term ($Kind.Map.new))) ($List.nil))))))))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((self1 ($Kind.Term.has_holes term))) (case self1 (#t (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) (#f (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.cons ($Kind.Error.patch path ($Kind.Term.normalize term ($Kind.Map.new))) ($List.nil))))))))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((self6 ($Kind.Term.has_holes term))) (case self6 (#t (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) (#f (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.cons ($Kind.Error.patch path ($Kind.Term.normalize term ($Kind.Map.new))) ($List.nil))))))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($Kind.Term.has_holes term))) (case self2 (#t (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.nil)))) (#f (let () ($Kind.Check.result ($Maybe.some ($Bool.true)) ($List.cons ($Kind.Error.patch path ($Kind.Term.normalize term ($Kind.Map.new))) ($List.nil))))))))))))
(define (Kind.Term.equal.hole) (lambda (path) (lambda (term) ($Kind.Term.equal.hole path term))))
(define ($Kind.Term.expand dref term defs) (let ((term ($Kind.Term.normalize term ($Kind.Map.new)))) (let ((term ($List.for dref term (lambda (path) (lambda (term) (let ((term ($Kind.Term.expand_at path term defs))) (let ((term ($Kind.Term.normalize term ($Kind.Map.new)))) (let ((term ($Kind.Term.expand_ct term defs 0))) (let ((term ($Kind.Term.normalize term ($Kind.Map.new)))) term))))))))) term)))
(define (Kind.Term.expand) (lambda (dref) (lambda (term) (lambda (defs) ($Kind.Term.expand dref term defs)))))
(define ($Kind.Term.expand_at path term defs) ($Kind.Term.patch_at path term (lambda (term) (let ((self1 term)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))(f2 (get self1 2))) term)) ('Kind.Term.ref (let ((f1 (get self1 1))) (let ((self2 ($Kind.Map.get f1 defs))) (case (get self2 0) ('Maybe.none (let () ($Kind.Term.ref f1))) ('Maybe.some (let ((f2 (get self2 1))) (let ((self3 f2)) (case (get self3 0) ('Kind.Def.new (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))(f8 (get self3 6))(f9 (get self3 7))(f10 (get self3 8))(f11 (get self3 9))) f7)))))))))) ('Kind.Term.typ (let () term)) ('Kind.Term.all (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))) term)) ('Kind.Term.lam (let ((f1 (get self1 1))(f2 (get self1 2))) term)) ('Kind.Term.app (let ((f1 (get self1 1))(f2 (get self1 2))) term)) ('Kind.Term.let (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) term)) ('Kind.Term.def (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) term)) ('Kind.Term.ann (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) term)) ('Kind.Term.gol (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) term)) ('Kind.Term.hol (let ((f1 (get self1 1))) term)) ('Kind.Term.nat (let ((f1 (get self1 1))) term)) ('Kind.Term.chr (let ((f1 (get self1 1))) term)) ('Kind.Term.str (let ((f1 (get self1 1))) term)) ('Kind.Term.cse (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))) term)) ('Kind.Term.ori (let ((f1 (get self1 1))(f2 (get self1 2))) term)))))))
(define (Kind.Term.expand_at) (lambda (path) (lambda (term) (lambda (defs) ($Kind.Term.expand_at path term defs)))))
(define ($Kind.Term.expand_ct term defs arity) (let ((self0 term)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.var f0 f1))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Map.get f0 defs))) (case (get self1 0) ('Maybe.none (let () ($Kind.Term.ref f0))) ('Maybe.some (let ((f1 (get self1 1))) (let ((self2 f1)) (case (get self2 0) ('Kind.Def.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))(f7 (get self2 6))(f8 (get self2 7))(f9 (get self2 8))(f10 (get self2 9))) (let ((self11 ($Bool.and f8 ($Nat.gtn arity f9)))) (case self11 (#t (let () f6)) (#f (let () ($Kind.Term.ref f0))))))))))))))) ('Kind.Term.typ (let () ($Kind.Term.typ))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Kind.Term.all f0 f1 f2 ($Kind.Term.expand_ct f3 defs 0) (lambda (s) (lambda (x) ($Kind.Term.expand_ct ((f4 s) x) defs 0)))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.lam f0 (lambda (x) ($Kind.Term.expand_ct (f1 x) defs 0))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.app ($Kind.Term.expand_ct f0 defs ($Nat.succ arity)) ($Kind.Term.expand_ct f1 defs 0)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.let f0 ($Kind.Term.expand_ct f1 defs 0) (lambda (x) ($Kind.Term.expand_ct (f2 x) defs 0))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.def f0 ($Kind.Term.expand_ct f1 defs 0) (lambda (x) ($Kind.Term.expand_ct (f2 x) defs 0))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.ann f0 ($Kind.Term.expand_ct f1 defs 0) ($Kind.Term.expand_ct f2 defs 0)))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.gol f0 f1 f2))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.hol f0))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.nat f0))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.chr f0))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.str f0))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) term)) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.ori f0 f1))))))
(define (Kind.Term.expand_ct) (lambda (term) (lambda (defs) (lambda (arity) ($Kind.Term.expand_ct term defs arity)))))
(define ($Kind.Term.extract_name term) (let ((term ($Kind.Term.reduce term ($Kind.Map.new)))) (let ((self1 term)) (case (get self1 0) ('Kind.Term.var (let ((f1 (get self1 1))(f2 (get self1 2))) f1)) ('Kind.Term.ref (let ((f1 (get self1 1))) f1)) ('Kind.Term.typ (let () "self")) ('Kind.Term.all (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))) "self")) ('Kind.Term.lam (let ((f1 (get self1 1))(f2 (get self1 2))) "self")) ('Kind.Term.app (let ((f1 (get self1 1))(f2 (get self1 2))) "self")) ('Kind.Term.let (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) "self")) ('Kind.Term.def (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) "self")) ('Kind.Term.ann (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) "self")) ('Kind.Term.gol (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) "self")) ('Kind.Term.hol (let ((f1 (get self1 1))) "self")) ('Kind.Term.nat (let ((f1 (get self1 1))) "self")) ('Kind.Term.chr (let ((f1 (get self1 1))) "self")) ('Kind.Term.str (let ((f1 (get self1 1))) "self")) ('Kind.Term.cse (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))(f4 (get self1 4))(f5 (get self1 5))(f6 (get self1 6))) "self")) ('Kind.Term.ori (let ((f1 (get self1 1))(f2 (get self1 2))) "self"))))))
(define (Kind.Term.extract_name) (lambda (term) ($Kind.Term.extract_name term)))
(define ($Kind.Term.gol name dref verb) (vector 'Kind.Term.gol name dref verb))
(define (Kind.Term.gol) (lambda (name) (lambda (dref) (lambda (verb) ($Kind.Term.gol name dref verb)))))
(define ($Kind.Term.has_holes term) (let ((self0 term)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Bool.false))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Bool.false))) ('Kind.Term.typ (let () ($Bool.false))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Bool.or ($Kind.Term.has_holes f3) ($Kind.Term.has_holes ((f4 ($Kind.Term.typ)) ($Kind.Term.typ)))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.has_holes (f1 ($Kind.Term.typ))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Bool.or ($Kind.Term.has_holes f0) ($Kind.Term.has_holes f1)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Bool.or ($Kind.Term.has_holes f1) ($Kind.Term.has_holes (f2 ($Kind.Term.typ)))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Bool.or ($Kind.Term.has_holes f1) ($Kind.Term.has_holes (f2 ($Kind.Term.typ)))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Bool.or ($Kind.Term.has_holes f1) ($Kind.Term.has_holes f2)))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Bool.false))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Bool.true))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Bool.false))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Bool.false))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Bool.false))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) ($Bool.false))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.has_holes f1))))))
(define (Kind.Term.has_holes) (lambda (term) ($Kind.Term.has_holes term)))
(define ($Kind.Term.hol path) (vector 'Kind.Term.hol path))
(define (Kind.Term.hol) (lambda (path) ($Kind.Term.hol path)))
(define ($Kind.Term.identical a b lv) (let ((ah ($Kind.Term.serialize a lv ($Bool.false)))) (let ((bh ($Kind.Term.serialize b lv ($Bool.true)))) ($Bits.eql ah bh))))
(define (Kind.Term.identical) (lambda (a) (lambda (b) (lambda (lv) ($Kind.Term.identical a b lv)))))
(define ($Kind.Term.lam name body) (vector 'Kind.Term.lam name body))
(define (Kind.Term.lam) (lambda (name) (lambda (body) ($Kind.Term.lam name body))))
(define ($Kind.Term.let name expr body) (vector 'Kind.Term.let name expr body))
(define (Kind.Term.let) (lambda (name) (lambda (expr) (lambda (body) ($Kind.Term.let name expr body)))))
(define ($Kind.Term.nat natx) (vector 'Kind.Term.nat natx))
(define (Kind.Term.nat) (lambda (natx) ($Kind.Term.nat natx)))
(define ($Kind.Term.normalize term defs) (let ((self0 ($Kind.Term.reduce term defs))) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.var f0 f1))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Term.ref f0))) ('Kind.Term.typ (let () ($Kind.Term.typ))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Kind.Term.all f0 f1 f2 ($Kind.Term.normalize f3 defs) (lambda (s) (lambda (x) ($Kind.Term.normalize ((f4 s) x) defs)))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.lam f0 (lambda (x) ($Kind.Term.normalize (f1 x) defs))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.app ($Kind.Term.normalize f0 defs) ($Kind.Term.normalize f1 defs)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.let f0 ($Kind.Term.normalize f1 defs) (lambda (x) ($Kind.Term.normalize (f2 x) defs))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.def f0 ($Kind.Term.normalize f1 defs) (lambda (x) ($Kind.Term.normalize (f2 x) defs))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.ann f0 ($Kind.Term.normalize f1 defs) ($Kind.Term.normalize f2 defs)))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.gol f0 f1 f2))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.hol f0))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.nat f0))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.chr f0))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.str f0))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) term)) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.normalize f1 defs))))))
(define (Kind.Term.normalize) (lambda (term) (lambda (defs) ($Kind.Term.normalize term defs))))
(define ($Kind.Term.ori orig expr) (vector 'Kind.Term.ori orig expr))
(define (Kind.Term.ori) (lambda (orig) (lambda (expr) ($Kind.Term.ori orig expr))))
(define ($Kind.Term.patch_at path term fn) (let ((self0 term)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 path)) (case (get self2 0) ('Bits.e (let () (fn term))) ('Bits.o (let ((f2 (get self2 1))) term)) ('Bits.i (let ((f2 (get self2 1))) term)))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 path)) (case (get self1 0) ('Bits.e (let () (fn term))) ('Bits.o (let ((f1 (get self1 1))) term)) ('Bits.i (let ((f1 (get self1 1))) term)))))) ('Kind.Term.typ (let () (let ((self0 path)) (case (get self0 0) ('Bits.e (let () (fn term))) ('Bits.o (let ((f0 (get self0 1))) term)) ('Bits.i (let ((f0 (get self0 1))) term)))))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((self5 path)) (case (get self5 0) ('Bits.e (let () (fn term))) ('Bits.o (let ((f5 (get self5 1))) ($Kind.Term.all f0 f1 f2 ($Kind.Term.patch_at f5 f3 fn) f4))) ('Bits.i (let ((f5 (get self5 1))) ($Kind.Term.all f0 f1 f2 f3 (lambda (s) (lambda (x) ($Kind.Term.patch_at f5 ((f4 s) x) fn)))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 path)) (case (get self2 0) ('Bits.e (let () (fn term))) ('Bits.o (let ((f2 (get self2 1))) ($Kind.Term.lam f0 (lambda (x) ($Kind.Term.patch_at ($Bits.tail path) (f1 x) fn))))) ('Bits.i (let ((f2 (get self2 1))) ($Kind.Term.lam f0 (lambda (x) ($Kind.Term.patch_at ($Bits.tail path) (f1 x) fn))))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 path)) (case (get self2 0) ('Bits.e (let () (fn term))) ('Bits.o (let ((f2 (get self2 1))) ($Kind.Term.app ($Kind.Term.patch_at f2 f0 fn) f1))) ('Bits.i (let ((f2 (get self2 1))) ($Kind.Term.app f0 ($Kind.Term.patch_at f2 f1 fn)))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 path)) (case (get self3 0) ('Bits.e (let () (fn term))) ('Bits.o (let ((f3 (get self3 1))) ($Kind.Term.let f0 ($Kind.Term.patch_at f3 f1 fn) f2))) ('Bits.i (let ((f3 (get self3 1))) ($Kind.Term.let f0 f1 (lambda (x) ($Kind.Term.patch_at f3 (f2 x) fn))))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 path)) (case (get self3 0) ('Bits.e (let () (fn term))) ('Bits.o (let ((f3 (get self3 1))) ($Kind.Term.def f0 ($Kind.Term.patch_at f3 f1 fn) f2))) ('Bits.i (let ((f3 (get self3 1))) ($Kind.Term.def f0 f1 (lambda (x) ($Kind.Term.patch_at f3 (f2 x) fn))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 path)) (case (get self3 0) ('Bits.e (let () (fn term))) ('Bits.o (let ((f3 (get self3 1))) ($Kind.Term.ann f0 ($Kind.Term.patch_at f3 f1 fn) f2))) ('Bits.i (let ((f3 (get self3 1))) ($Kind.Term.ann f0 f1 ($Kind.Term.patch_at f3 f2 fn)))))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((self3 path)) (case (get self3 0) ('Bits.e (let () (fn term))) ('Bits.o (let ((f3 (get self3 1))) term)) ('Bits.i (let ((f3 (get self3 1))) term)))))) ('Kind.Term.hol (let ((f0 (get self0 1))) (let ((self1 path)) (case (get self1 0) ('Bits.e (let () (fn term))) ('Bits.o (let ((f1 (get self1 1))) term)) ('Bits.i (let ((f1 (get self1 1))) term)))))) ('Kind.Term.nat (let ((f0 (get self0 1))) (let ((self1 path)) (case (get self1 0) ('Bits.e (let () (fn term))) ('Bits.o (let ((f1 (get self1 1))) term)) ('Bits.i (let ((f1 (get self1 1))) term)))))) ('Kind.Term.chr (let ((f0 (get self0 1))) (let ((self1 path)) (case (get self1 0) ('Bits.e (let () (fn term))) ('Bits.o (let ((f1 (get self1 1))) term)) ('Bits.i (let ((f1 (get self1 1))) term)))))) ('Kind.Term.str (let ((f0 (get self0 1))) (let ((self1 path)) (case (get self1 0) ('Bits.e (let () (fn term))) ('Bits.o (let ((f1 (get self1 1))) term)) ('Bits.i (let ((f1 (get self1 1))) term)))))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((self6 path)) (case (get self6 0) ('Bits.e (let () (fn term))) ('Bits.o (let ((f6 (get self6 1))) term)) ('Bits.i (let ((f6 (get self6 1))) term)))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.ori f0 ($Kind.Term.patch_at path f1 fn)))))))
(define (Kind.Term.patch_at) (lambda (path) (lambda (term) (lambda (fn) ($Kind.Term.patch_at path term fn)))))
(define ($Kind.Term.reduce term defs) (let ((self0 term)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) term)) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($Kind.Map.get f0 defs))) (case (get self1 0) ('Maybe.none (let () ($Kind.Term.ref f0))) ('Maybe.some (let ((f1 (get self1 1))) (let ((self2 f1)) (case (get self2 0) ('Kind.Def.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))(f7 (get self2 6))(f8 (get self2 7))(f9 (get self2 8))(f10 (get self2 9))) ($Kind.Term.reduce f6 defs))))))))))) ('Kind.Term.typ (let () term)) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) term)) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) term)) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((func ($Kind.Term.reduce f0 defs))) (let ((self3 func)) (case (get self3 0) ('Kind.Term.var (let ((f3 (get self3 1))(f4 (get self3 2))) term)) ('Kind.Term.ref (let ((f3 (get self3 1))) term)) ('Kind.Term.typ (let () term)) ('Kind.Term.all (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))) term)) ('Kind.Term.lam (let ((f3 (get self3 1))(f4 (get self3 2))) ($Kind.Term.reduce (f4 f1) defs))) ('Kind.Term.app (let ((f3 (get self3 1))(f4 (get self3 2))) term)) ('Kind.Term.let (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) term)) ('Kind.Term.def (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) term)) ('Kind.Term.ann (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) term)) ('Kind.Term.gol (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) term)) ('Kind.Term.hol (let ((f3 (get self3 1))) term)) ('Kind.Term.nat (let ((f3 (get self3 1))) term)) ('Kind.Term.chr (let ((f3 (get self3 1))) term)) ('Kind.Term.str (let ((f3 (get self3 1))) term)) ('Kind.Term.cse (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))(f6 (get self3 4))(f7 (get self3 5))(f8 (get self3 6))) term)) ('Kind.Term.ori (let ((f3 (get self3 1))(f4 (get self3 2))) term))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.reduce (f2 f1) defs))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.reduce (f2 f1) defs))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.reduce f1 defs))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) term)) ('Kind.Term.hol (let ((f0 (get self0 1))) term)) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.reduce ($Kind.Term.unroll_nat f0) defs))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.reduce ($Kind.Term.unroll_chr f0) defs))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.reduce ($Kind.Term.unroll_str f0) defs))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) term)) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.reduce f1 defs))))))
(define (Kind.Term.reduce) (lambda (term) (lambda (defs) ($Kind.Term.reduce term defs))))
(define ($Kind.Term.ref name) (vector 'Kind.Term.ref name))
(define (Kind.Term.ref) (lambda (name) ($Kind.Term.ref name)))
(define ($Kind.Term.serialize term depth side) (let ((diff (let ((self0 side)) (case self0 (#t (let () (Bits.o))) (#f (let () (Bits.i))))))) ($Kind.Term.serialize.go term depth depth diff ($Bits.e))))
(define (Kind.Term.serialize) (lambda (term) (lambda (depth) (lambda (side) ($Kind.Term.serialize term depth side)))))
(define ($Kind.Term.serialize.go term depth init diff x) (let ((self0 term)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 ($Nat.gte f1 init))) (case self2 (#t (let () (let ((name ((Bits.concat) ($Nat.to_bits ($Nat.pred ($Nat.sub depth f1)))))) ($Bits.o ($Bits.o ($Bits.i (name x))))))) (#f (let () (let ((name ((Bits.concat) ($Nat.to_bits f1)))) ($Bits.o ($Bits.i ($Bits.o (name x))))))))))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((name ((Bits.concat) ($Kind.Name.to_bits f0)))) ($Bits.o ($Bits.o ($Bits.o (name x))))))) ('Kind.Term.typ (let () ($Bits.o ($Bits.i ($Bits.i x))))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((eras (let ((self5 f0)) (case self5 (#t (let () (Bits.i))) (#f (let () (Bits.o))))))) (let ((self ((Bits.concat) ($Kind.Name.to_bits f1)))) (let ((xtyp (((((Kind.Term.serialize.go) f3) depth) init) diff))) (let ((body (((((Kind.Term.serialize.go) ((f4 ($Kind.Term.var f1 depth)) ($Kind.Term.var f2 ($Nat.succ depth)))) ($Nat.succ ($Nat.succ depth))) init) diff))) ($Bits.i ($Bits.o ($Bits.o (eras (self (xtyp (body x))))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((body (((((Kind.Term.serialize.go) (f1 ($Kind.Term.var f0 depth))) ($Nat.succ depth)) init) diff))) ($Bits.i ($Bits.o ($Bits.i (body x))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((func (((((Kind.Term.serialize.go) f0) depth) init) diff))) (let ((argm (((((Kind.Term.serialize.go) f1) depth) init) diff))) ($Bits.i ($Bits.i ($Bits.o (func (argm x))))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((expr (((((Kind.Term.serialize.go) f1) depth) init) diff))) (let ((body (((((Kind.Term.serialize.go) (f2 ($Kind.Term.var f0 depth))) ($Nat.succ depth)) init) diff))) ($Bits.i ($Bits.i ($Bits.i (expr (body x))))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.serialize.go (f2 f1) depth init diff x))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.serialize.go f1 depth init diff x))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((name ((Bits.concat) ($Kind.Name.to_bits f0)))) ($Bits.o ($Bits.o ($Bits.o (name x))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) x)) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.serialize.go ($Kind.Term.unroll_nat f0) depth init diff x))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.serialize.go ($Kind.Term.unroll_chr f0) depth init diff x))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.serialize.go ($Kind.Term.unroll_str f0) depth init diff x))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (diff x))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.serialize.go f1 depth init diff x))))))
(define (Kind.Term.serialize.go) (lambda (term) (lambda (depth) (lambda (init) (lambda (diff) (lambda (x) ($Kind.Term.serialize.go term depth init diff x)))))))
(define ($Kind.Term.show term) ($Kind.Term.show.go term ($Maybe.none)))
(define (Kind.Term.show) (lambda (term) ($Kind.Term.show term)))
(define ($Kind.Term.show.app term path args) (let ((self0 term)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.show.app.done term path args))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term path args))) ('Kind.Term.typ (let () ($Kind.Term.show.app.done term path args))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Kind.Term.show.app.done term path args))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.show.app.done term path args))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.show.app f0 ($Kind.MPath.o path) ($List.cons ($Kind.Term.show.go f1 ($Kind.MPath.i path)) args)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.show.app.done term path args))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.show.app.done term path args))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.show.app.done term path args))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Kind.Term.show.app.done term path args))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term path args))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term path args))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term path args))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Kind.Term.show.app.done term path args))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) ($Kind.Term.show.app.done term path args))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.show.app f1 path args))))))
(define (Kind.Term.show.app) (lambda (term) (lambda (path) (lambda (args) ($Kind.Term.show.app term path args)))))
(define ($Kind.Term.show.app.done term path args) (let ((arity ($List.length args))) (let ((self1 ($Bool.and ($Kind.Term.show.is_ref term "Equal") ($Nat.eql arity 3)))) (case self1 (#t (let () (let ((func ($Kind.Term.show.go term path))) (let ((eq_lft ($Maybe.default ($List.at 1 args) "?"))) (let ((eq_rgt ($Maybe.default ($List.at 2 args) "?"))) ($String.flatten ($List.cons eq_lft ($List.cons " == " ($List.cons eq_rgt ($List.nil)))))))))) (#f (let () (let ((func ($Kind.Term.show.go term path))) (let ((wrap (let ((self2 func)) (case (= (string-length self2) 0) (#t (let () ($Bool.false))) (#f (let ((f2 (char->integer (string-ref self2 0)))(f3 (let ((_str_ self2)) (substring _str_ 1 (string-length _str_))))) ($U16.eql f2 40))))))) (let ((args ($String.join "," args))) (let ((func (let ((self4 wrap)) (case self4 (#t (let () ($String.flatten ($List.cons "(" ($List.cons func ($List.cons ")" ($List.nil))))))) (#f (let () func)))))) ($String.flatten ($List.cons func ($List.cons "(" ($List.cons args ($List.cons ")" ($List.nil))))))))))))))))
(define (Kind.Term.show.app.done) (lambda (term) (lambda (path) (lambda (args) ($Kind.Term.show.app.done term path args)))))
(define ($Kind.Term.show.as_nat term) ($Maybe.mapped ($Kind.Term.show.as_nat.go term) (Nat.show)))
(define (Kind.Term.show.as_nat) (lambda (term) ($Kind.Term.show.as_nat term)))
(define ($Kind.Term.show.as_nat.go term) (let ((self0 term)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Maybe.none))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((self1 ($String.eql f0 "Nat.zero"))) (case self1 (#t (let () ($Maybe.some 0))) (#f (let () ($Maybe.none))))))) ('Kind.Term.typ (let () ($Maybe.none))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Maybe.none))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($Maybe.none))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Kind.Term.var (let ((f2 (get self2 1))(f3 (get self2 2))) ($Maybe.none))) ('Kind.Term.ref (let ((f2 (get self2 1))) (let ((self3 ($String.eql f2 "Nat.succ"))) (case self3 (#t (let () ((($Monad.bind ($Maybe.monad)) ($Kind.Term.show.as_nat.go f1)) (lambda (pred) (($Monad.pure ($Maybe.monad)) ($Nat.succ pred)))))) (#f (let () ($Maybe.none))))))) ('Kind.Term.typ (let () ($Maybe.none))) ('Kind.Term.all (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))) ($Maybe.none))) ('Kind.Term.lam (let ((f2 (get self2 1))(f3 (get self2 2))) ($Maybe.none))) ('Kind.Term.app (let ((f2 (get self2 1))(f3 (get self2 2))) ($Maybe.none))) ('Kind.Term.let (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Maybe.none))) ('Kind.Term.def (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Maybe.none))) ('Kind.Term.ann (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Maybe.none))) ('Kind.Term.gol (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) ($Maybe.none))) ('Kind.Term.hol (let ((f2 (get self2 1))) ($Maybe.none))) ('Kind.Term.nat (let ((f2 (get self2 1))) ($Maybe.none))) ('Kind.Term.chr (let ((f2 (get self2 1))) ($Maybe.none))) ('Kind.Term.str (let ((f2 (get self2 1))) ($Maybe.none))) ('Kind.Term.cse (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))(f5 (get self2 4))(f6 (get self2 5))(f7 (get self2 6))) ($Maybe.none))) ('Kind.Term.ori (let ((f2 (get self2 1))(f3 (get self2 2))) ($Maybe.none))))))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Maybe.none))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Maybe.none))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Maybe.none))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Maybe.none))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Maybe.none))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Maybe.none))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Maybe.none))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Maybe.none))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) ($Maybe.none))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Maybe.none))))))
(define (Kind.Term.show.as_nat.go) (lambda (term) ($Kind.Term.show.as_nat.go term)))
(define ($Kind.Term.show.go term path) (let ((self0 ($Kind.Term.show.as_nat term))) (case (get self0 0) ('Maybe.none (let () (let ((self0 term)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Name.show f0))) ('Kind.Term.ref (let ((f0 (get self0 1))) (let ((name ($Kind.Name.show f0))) (let ((self2 path)) (case (get self2 0) ('Maybe.none (let () name)) ('Maybe.some (let ((f2 (get self2 1))) (let ((path_val ($Bits.concat ($Kind.Path.to_bits f2) ($Bits.i ($Bits.e))))) (let ((path_str ($Nat.show ($Bits.to_nat path_val)))) ($String.flatten ($List.cons name ($List.cons ($Kind.Code.color "2" ($String.concat "-" path_str)) ($List.nil))))))))))))) ('Kind.Term.typ (let () "Type")) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) (let ((eras f0)) (let ((self ($Kind.Name.show f1))) (let ((name ($Kind.Name.show f2))) (let ((type ($Kind.Term.show.go f3 ($Kind.MPath.o path)))) (let ((open (let ((self9 eras)) (case self9 (#t (let () "<")) (#f (let () "(")))))) (let ((clos (let ((self10 eras)) (case self10 (#t (let () ">")) (#f (let () ")")))))) (let ((body ($Kind.Term.show.go ((f4 ($Kind.Term.var f1 0)) ($Kind.Term.var f2 0)) ($Kind.MPath.i path)))) ($String.flatten ($List.cons self ($List.cons open ($List.cons name ($List.cons ":" ($List.cons type ($List.cons clos ($List.cons " " ($List.cons body ($List.nil))))))))))))))))))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((name ($Kind.Name.show f0))) (let ((body ($Kind.Term.show.go (f1 ($Kind.Term.var f0 0)) ($Kind.MPath.o path)))) ($String.flatten ($List.cons "(" ($List.cons name ($List.cons ") " ($List.cons body ($List.nil)))))))))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.show.app term path ($List.nil)))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((name ($Kind.Name.show f0))) (let ((expr ($Kind.Term.show.go f1 ($Kind.MPath.o path)))) (let ((body ($Kind.Term.show.go (f2 ($Kind.Term.var f0 0)) ($Kind.MPath.i path)))) ($String.flatten ($List.cons "let " ($List.cons name ($List.cons " = " ($List.cons expr ($List.cons "; " ($List.cons body ($List.nil))))))))))))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((name ($Kind.Name.show f0))) (let ((expr ($Kind.Term.show.go f1 ($Kind.MPath.o path)))) (let ((body ($Kind.Term.show.go (f2 ($Kind.Term.var f0 0)) ($Kind.MPath.i path)))) ($String.flatten ($List.cons "def " ($List.cons name ($List.cons " = " ($List.cons expr ($List.cons "; " ($List.cons body ($List.nil))))))))))))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((term ($Kind.Term.show.go f1 ($Kind.MPath.o path)))) (let ((type ($Kind.Term.show.go f2 ($Kind.MPath.i path)))) ($String.flatten ($List.cons term ($List.cons "::" ($List.cons type ($List.nil))))))))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (let ((name ($Kind.Name.show f0))) ($String.flatten ($List.cons "?" ($List.cons name ($List.nil))))))) ('Kind.Term.hol (let ((f0 (get self0 1))) "_")) ('Kind.Term.nat (let ((f0 (get self0 1))) ($String.flatten ($List.cons ($Nat.show f0) ($List.nil))))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($String.flatten ($List.cons "'" ($List.cons ($Kind.Code.escape.char f0) ($List.cons "'" ($List.nil))))))) ('Kind.Term.str (let ((f0 (get self0 1))) ($String.flatten ($List.cons "\"" ($List.cons ($Kind.Code.escape f0) ($List.cons "\"" ($List.nil))))))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) (let ((expr ($Kind.Term.show.go f1 ($Kind.MPath.o path)))) (let ((name ($Kind.Name.show f2))) (let ((wyth ($String.join "; " ($List.mapped f3 (lambda (with_var) (let ((self9 with_var)) (case (get self9 0) ('Kind.Ann.new (let ((f9 (get self9 1))(f10 (get self9 2))(f11 (get self9 3))) (let ((self12 f11)) (case (get self12 0) ('Maybe.none (let () f9)) ('Maybe.some (let ((f12 (get self12 1))) ($String.concat f9 ($String.concat ": " ($Kind.Term.show.go f12 ($Maybe.none))))))))))))))))) (let ((cses ($BitsMap.to_list f4))) (let ((cses ($String.join "" ($List.mapped cses (lambda (x) (let ((name ($Kind.Name.from_bits ($Pair.fst x)))) (let ((term ($Kind.Term.show.go ($Pair.snd x) ($Maybe.none)))) ($String.flatten ($List.cons name ($List.cons ": " ($List.cons term ($List.cons "; " ($List.nil))))))))))))) (let ((moti (let ((self11 f5)) (case (get self11 0) ('Maybe.none (let () "")) ('Maybe.some (let ((f11 (get self11 1))) ($String.flatten ($List.cons ": " ($List.cons ($Kind.Term.show.go f11 ($Maybe.none)) ($List.nil)))))))))) ($String.flatten ($List.cons "case " ($List.cons expr ($List.cons " as " ($List.cons name ($List.cons wyth ($List.cons " { " ($List.cons cses ($List.cons "}" ($List.cons moti ($List.nil))))))))))))))))))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Kind.Term.show.go f1 path))))))) ('Maybe.some (let ((f0 (get self0 1))) f0)))))
(define (Kind.Term.show.go) (lambda (term) (lambda (path) ($Kind.Term.show.go term path))))
(define ($Kind.Term.show.is_ref term name) (let ((self0 term)) (case (get self0 0) ('Kind.Term.var (let ((f0 (get self0 1))(f1 (get self0 2))) ($Bool.false))) ('Kind.Term.ref (let ((f0 (get self0 1))) ($String.eql name f0))) ('Kind.Term.typ (let () ($Bool.false))) ('Kind.Term.all (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))) ($Bool.false))) ('Kind.Term.lam (let ((f0 (get self0 1))(f1 (get self0 2))) ($Bool.false))) ('Kind.Term.app (let ((f0 (get self0 1))(f1 (get self0 2))) ($Bool.false))) ('Kind.Term.let (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Bool.false))) ('Kind.Term.def (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Bool.false))) ('Kind.Term.ann (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Bool.false))) ('Kind.Term.gol (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Bool.false))) ('Kind.Term.hol (let ((f0 (get self0 1))) ($Bool.false))) ('Kind.Term.nat (let ((f0 (get self0 1))) ($Bool.false))) ('Kind.Term.chr (let ((f0 (get self0 1))) ($Bool.false))) ('Kind.Term.str (let ((f0 (get self0 1))) ($Bool.false))) ('Kind.Term.cse (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))(f3 (get self0 4))(f4 (get self0 5))(f5 (get self0 6))) ($Bool.false))) ('Kind.Term.ori (let ((f0 (get self0 1))(f1 (get self0 2))) ($Bool.false))))))
(define (Kind.Term.show.is_ref) (lambda (term) (lambda (name) ($Kind.Term.show.is_ref term name))))
(define ($Kind.Term.str strx) (vector 'Kind.Term.str strx))
(define (Kind.Term.str) (lambda (strx) ($Kind.Term.str strx)))
(define ($Kind.Term.typ) (vector 'Kind.Term.typ))
(define (Kind.Term.typ) ($Kind.Term.typ))
(define ($Kind.Term.unroll_chr chrx) (let ((bits ($U16.to_bits chrx))) (let ((term ($Kind.Term.ref ($Kind.Name.read "Word.from_bits")))) (let ((term ($Kind.Term.app term ($Kind.Term.nat 16)))) (let ((term ($Kind.Term.app term ($Kind.Term.unroll_chr.bits bits)))) (let ((term ($Kind.Term.app ($Kind.Term.ref ($Kind.Name.read "U16.new")) term))) term))))))
(define (Kind.Term.unroll_chr) (lambda (chrx) ($Kind.Term.unroll_chr chrx)))
(define ($Kind.Term.unroll_chr.bits bits) (let ((self0 bits)) (case (get self0 0) ('Bits.e (let () ($Kind.Term.ref ($Kind.Name.read "Bits.e")))) ('Bits.o (let ((f0 (get self0 1))) ($Kind.Term.app ($Kind.Term.ref ($Kind.Name.read "Bits.o")) ($Kind.Term.unroll_chr.bits f0)))) ('Bits.i (let ((f0 (get self0 1))) ($Kind.Term.app ($Kind.Term.ref ($Kind.Name.read "Bits.i")) ($Kind.Term.unroll_chr.bits f0)))))))
(define (Kind.Term.unroll_chr.bits) (lambda (bits) ($Kind.Term.unroll_chr.bits bits)))
(define ($Kind.Term.unroll_nat natx) (let ((self0 natx)) (case (= self0 0) (#t (let () ($Kind.Term.ref ($Kind.Name.read "Nat.zero")))) (#f (let ((f0 (- self0 1))) (let ((func ($Kind.Term.ref ($Kind.Name.read "Nat.succ")))) (let ((argm ($Kind.Term.nat f0))) ($Kind.Term.app func argm))))))))
(define (Kind.Term.unroll_nat) (lambda (natx) ($Kind.Term.unroll_nat natx)))
(define ($Kind.Term.unroll_str strx) (let ((self0 strx)) (case (= (string-length self0) 0) (#t (let () ($Kind.Term.ref ($Kind.Name.read "String.nil")))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((char ($Kind.Term.chr f0))) (let ((term ($Kind.Term.ref ($Kind.Name.read "String.cons")))) (let ((term ($Kind.Term.app term char))) (let ((term ($Kind.Term.app term ($Kind.Term.str f1)))) term)))))))))
(define (Kind.Term.unroll_str) (lambda (strx) ($Kind.Term.unroll_str strx)))
(define ($Kind.Term.var name indx) (vector 'Kind.Term.var name indx))
(define (Kind.Term.var) (lambda (name) (lambda (indx) ($Kind.Term.var name indx))))
(define ($Kind.api.io.check_file file) ((($Monad.bind ($IO.monad)) ($Kind.Synth.file file ($Kind.Map.new))) (lambda (loaded) (let ((self1 loaded)) (case (get self1 0) ('Either.left (let ((f1 (get self1 1))) ((($Monad.bind ($IO.monad)) ($IO.print ($String.flatten ($List.cons "On '" ($List.cons file ($List.cons "':" ($List.nil))))))) (lambda (-) ($IO.print f1))))) ('Either.right (let ((f1 (get self1 1))) (let ((self2 f1)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) (let ((nams f2)) (let ((defs f3)) (let ((self6 nams)) (case (get self6 0) ('List.nil (let () ($IO.print ($String.concat "File not found or empty: '" ($String.concat file "'."))))) ('List.cons (let ((f6 (get self6 1))(f7 (get self6 2))) ((($Monad.bind ($IO.monad)) ($IO.print ($Kind.Defs.report defs nams))) (lambda (-) ($Kind.Defs.cache defs))))))))))))))))))))
(define (Kind.api.io.check_file) (lambda (file) ($Kind.api.io.check_file file)))
(define ($List A) '())
(define (List) (lambda (A) ($List A)))
(define ($List.any cond list) (let ((self0 list)) (case (get self0 0) ('List.nil (let () ($Bool.false))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 (cond f0))) (case self2 (#t (let () ($Bool.true))) (#f (let () ($List.any cond f1))))))))))
(define (List.any) (lambda (cond) (lambda (list) ($List.any cond list))))
(define ($List.at index list) (let ((self0 list)) (case (get self0 0) ('List.nil (let () ($Maybe.none))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 index)) (case (= self2 0) (#t (let () ($Maybe.some f0))) (#f (let ((f2 (- self2 1))) ($List.at f2 f1))))))))))
(define (List.at) (lambda (index) (lambda (list) ($List.at index list))))
(define ($List.at_last index list) ($List.at index ($List.reverse list)))
(define (List.at_last) (lambda (index) (lambda (list) ($List.at_last index list))))
(define ($List.concat as bs) (let ((self0 as)) (case (get self0 0) ('List.nil (let () bs)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons f0 ($List.concat f1 bs)))))))
(define (List.concat) (lambda (as) (lambda (bs) ($List.concat as bs))))
(define ($List.cons head tail) (vector 'List.cons head tail))
(define (List.cons) (lambda (head) (lambda (tail) ($List.cons head tail))))
(define ($List.filter f xs) (let ((self0 xs)) (case (get self0 0) ('List.nil (let () ($List.nil))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 (f f0))) (case self2 (#t (let () ($List.cons f0 ($List.filter f f1)))) (#f (let () ($List.filter f f1))))))))))
(define (List.filter) (lambda (f) (lambda (xs) ($List.filter f xs))))
(define ($List.flatten xs) (let ((self0 xs)) (case (get self0 0) ('List.nil (let () ($List.nil))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.concat f0 ($List.flatten f1)))))))
(define (List.flatten) (lambda (xs) ($List.flatten xs)))
(define ($List.fold list nil cons) (let ((self0 list)) (case (get self0 0) ('List.nil (let () nil)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ((cons f0) ($List.fold f1 nil cons)))))))
(define (List.fold) (lambda (list) (lambda (nil) (lambda (cons) ($List.fold list nil cons)))))
(define ($List.for xs b f) (let ((self0 xs)) (case (get self0 0) ('List.nil (let () b)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.for f1 ((f f0) b) f))))))
(define (List.for) (lambda (xs) (lambda (b) (lambda (f) ($List.for xs b f)))))
(define ($List.is_empty list) (let ((self0 list)) (case (get self0 0) ('List.nil (let () ($Bool.true))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($Bool.false))))))
(define (List.is_empty) (lambda (list) ($List.is_empty list)))
(define ($List.length xs) (let ((self0 xs)) (case (get self0 0) ('List.nil (let () 0)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($Nat.succ ($List.length f1)))))))
(define (List.length) (lambda (xs) ($List.length xs)))
(define ($List.mapped as f) (let ((self0 as)) (case (get self0 0) ('List.nil (let () ($List.nil))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.cons (f f0) ($List.mapped f1 f)))))))
(define (List.mapped) (lambda (as) (lambda (f) ($List.mapped as f))))
(define ($List.nil) (vector 'List.nil))
(define (List.nil) ($List.nil))
(define ($List.reverse xs) ($List.reverse.go xs ($List.nil)))
(define (List.reverse) (lambda (xs) ($List.reverse xs)))
(define ($List.reverse.go xs res) (let ((self0 xs)) (case (get self0 0) ('List.nil (let () res)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($List.reverse.go f1 ($List.cons f0 res)))))))
(define (List.reverse.go) (lambda (xs) (lambda (res) ($List.reverse.go xs res))))
(define ($List.tail xs) (let ((self0 xs)) (case (get self0 0) ('List.nil (let () ($List.nil))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) f1)))))
(define (List.tail) (lambda (xs) ($List.tail xs)))
(define ($List.take n xs) (let ((self0 xs)) (case (get self0 0) ('List.nil (let () ($List.nil))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 n)) (case (= self2 0) (#t (let () ($List.nil))) (#f (let ((f2 (- self2 1))) ($List.cons f0 ($List.take f2 f1)))))))))))
(define (List.take) (lambda (n) (lambda (xs) ($List.take n xs))))
(define ($List.zip as bs) (let ((self0 as)) (case (get self0 0) ('List.nil (let () ($List.nil))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 bs)) (case (get self2 0) ('List.nil (let () ($List.nil))) ('List.cons (let ((f2 (get self2 1))(f3 (get self2 2))) ($List.cons ($Pair.new f0 f2) ($List.zip f1 f3)))))))))))
(define (List.zip) (lambda (as) (lambda (bs) ($List.zip as bs))))
(define ($Map V) '())
(define (Map) (lambda (V) ($Map V)))
(define ($Map.from_list xs) (let ((self0 xs)) (case (get self0 0) ('List.nil (let () ($BitsMap.new))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (get self2 0) ('Pair.new (let ((f2 (get self2 1))(f3 (get self2 2))) ($BitsMap.set ($String.to_bits f2) f3 ($Map.from_list f1)))))))))))
(define (Map.from_list) (lambda (xs) ($Map.from_list xs)))
(define ($Maybe A) '())
(define (Maybe) (lambda (A) ($Maybe A)))
(define ($Maybe.bind m f) (let ((self0 m)) (case (get self0 0) ('Maybe.none (let () ($Maybe.none))) ('Maybe.some (let ((f0 (get self0 1))) (f f0))))))
(define (Maybe.bind) (lambda (m) (lambda (f) ($Maybe.bind m f))))
(define ($Maybe.default m a) (let ((self0 m)) (case (get self0 0) ('Maybe.none (let () a)) ('Maybe.some (let ((f0 (get self0 1))) f0)))))
(define (Maybe.default) (lambda (m) (lambda (a) ($Maybe.default m a))))
(define ($Maybe.extract m a f) (let ((self0 m)) (case (get self0 0) ('Maybe.none (let () a)) ('Maybe.some (let ((f0 (get self0 1))) (f f0))))))
(define (Maybe.extract) (lambda (m) (lambda (a) (lambda (f) ($Maybe.extract m a f)))))
(define ($Maybe.is_some m) (let ((self0 m)) (case (get self0 0) ('Maybe.none (let () ($Bool.false))) ('Maybe.some (let ((f0 (get self0 1))) ($Bool.true))))))
(define (Maybe.is_some) (lambda (m) ($Maybe.is_some m)))
(define ($Maybe.mapped m f) (let ((self0 m)) (case (get self0 0) ('Maybe.none (let () ($Maybe.none))) ('Maybe.some (let ((f0 (get self0 1))) ($Maybe.some (f f0)))))))
(define (Maybe.mapped) (lambda (m) (lambda (f) ($Maybe.mapped m f))))
(define ($Maybe.monad) ($Monad.new (Maybe.bind) (Maybe.some)))
(define (Maybe.monad) ($Maybe.monad))
(define ($Maybe.none) (vector 'Maybe.none))
(define (Maybe.none) ($Maybe.none))
(define ($Maybe.or a b) (let ((self0 a)) (case (get self0 0) ('Maybe.none (let () b)) ('Maybe.some (let ((f0 (get self0 1))) ($Maybe.some f0))))))
(define (Maybe.or) (lambda (a) (lambda (b) ($Maybe.or a b))))
(define ($Maybe.some value) (vector 'Maybe.some value))
(define (Maybe.some) (lambda (value) ($Maybe.some value)))
(define ($Monad M) '())
(define (Monad) (lambda (M) ($Monad M)))
(define ($Monad.bind m) (let ((self0 m)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))(f1 (get self0 2))) f0)))))
(define (Monad.bind) (lambda (m) ($Monad.bind m)))
(define ($Monad.new bind pure) (vector 'Monad.new bind pure))
(define (Monad.new) (lambda (bind) (lambda (pure) ($Monad.new bind pure))))
(define ($Monad.pure m) (let ((self0 m)) (case (get self0 0) ('Monad.new (let ((f0 (get self0 1))(f1 (get self0 2))) f1)))))
(define (Monad.pure) (lambda (m) ($Monad.pure m)))
(define ($Nat) '())
(define (Nat) ($Nat))
(define ($Nat.add n m) (+ n m))
(define (Nat.add) (lambda (n) (lambda (m) ($Nat.add n m))))
(define ($Nat.apply n f x) (let ((self0 n)) (case (= self0 0) (#t (let () x)) (#f (let ((f0 (- self0 1))) ($Nat.apply f0 f (f x)))))))
(define (Nat.apply) (lambda (n) (lambda (f) (lambda (x) ($Nat.apply n f x)))))
(define ($Nat.div_mod n m) ($Nat.div_mod.go n m ($Nat.zero)))
(define (Nat.div_mod) (lambda (n) (lambda (m) ($Nat.div_mod n m))))
(define ($Nat.div_mod.go n m d) (let ((self0 ($Nat.sub_rem n m))) (case (get self0 0) ('Either.left (let ((f0 (get self0 1))) ($Nat.div_mod.go f0 m ($Nat.succ d)))) ('Either.right (let ((f0 (get self0 1))) ($Pair.new d n))))))
(define (Nat.div_mod.go) (lambda (n) (lambda (m) (lambda (d) ($Nat.div_mod.go n m d)))))
(define ($Nat.double n) (let ((self0 n)) (case (= self0 0) (#t (let () ($Nat.zero))) (#f (let ((f0 (- self0 1))) ($Nat.succ ($Nat.succ ($Nat.double f0))))))))
(define (Nat.double) (lambda (n) ($Nat.double n)))
(define ($Nat.eql n m) (= n m))
(define (Nat.eql) (lambda (n) (lambda (m) ($Nat.eql n m))))
(define ($Nat.from_base base ds) ($Nat.from_base.go base ($List.reverse ds) 1 0))
(define (Nat.from_base) (lambda (base) (lambda (ds) ($Nat.from_base base ds))))
(define ($Nat.from_base.go b ds p res) (let ((self0 ds)) (case (get self0 0) ('List.nil (let () res)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($Nat.from_base.go b f1 ($Nat.mul b p) ($Nat.add ($Nat.mul f0 p) res)))))))
(define (Nat.from_base.go) (lambda (b) (lambda (ds) (lambda (p) (lambda (res) ($Nat.from_base.go b ds p res))))))
(define ($Nat.gte n m) (>= n m))
(define (Nat.gte) (lambda (n) (lambda (m) ($Nat.gte n m))))
(define ($Nat.gtn n m) (> n m))
(define (Nat.gtn) (lambda (n) (lambda (m) ($Nat.gtn n m))))
(define ($Nat.is_zero n) (let ((self0 n)) (case (= self0 0) (#t (let () ($Bool.true))) (#f (let ((f0 (- self0 1))) ($Bool.false))))))
(define (Nat.is_zero) (lambda (n) ($Nat.is_zero n)))
(define ($Nat.lte n m) (<= n m))
(define (Nat.lte) (lambda (n) (lambda (m) ($Nat.lte n m))))
(define ($Nat.mod n m) (mod n m))
(define (Nat.mod) (lambda (n) (lambda (m) ($Nat.mod n m))))
(define ($Nat.mod.go n m r) (let ((self0 m)) (case (= self0 0) (#t (let () ($Nat.mod.go n r m))) (#f (let ((f0 (- self0 1))) (let ((self1 n)) (case (= self1 0) (#t (let () r)) (#f (let ((f1 (- self1 1))) ($Nat.mod.go f1 f0 ($Nat.succ r)))))))))))
(define (Nat.mod.go) (lambda (n) (lambda (m) (lambda (r) ($Nat.mod.go n m r)))))
(define ($Nat.mul n m) (* n m))
(define (Nat.mul) (lambda (n) (lambda (m) ($Nat.mul n m))))
(define ($Nat.pred n) (let ((self0 n)) (case (= self0 0) (#t (let () ($Nat.zero))) (#f (let ((f0 (- self0 1))) f0)))))
(define (Nat.pred) (lambda (n) ($Nat.pred n)))
(define ($Nat.read str) (let ((p ((($Parser.nat) 0) str))) (let ((self1 p)) (case (get self1 0) ('Parser.Reply.error (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) 0)) ('Parser.Reply.value (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) f3))))))
(define (Nat.read) (lambda (str) ($Nat.read str)))
(define ($Nat.show n) (number->string n))
(define (Nat.show) (lambda (n) ($Nat.show n)))
(define ($Nat.show_digit base n) (let ((m ($Nat.mod n base))) (let ((base64 ($List.cons 48 ($List.cons 49 ($List.cons 50 ($List.cons 51 ($List.cons 52 ($List.cons 53 ($List.cons 54 ($List.cons 55 ($List.cons 56 ($List.cons 57 ($List.cons 65 ($List.cons 66 ($List.cons 67 ($List.cons 68 ($List.cons 69 ($List.cons 70 ($List.cons 71 ($List.cons 72 ($List.cons 73 ($List.cons 74 ($List.cons 75 ($List.cons 76 ($List.cons 77 ($List.cons 78 ($List.cons 79 ($List.cons 80 ($List.cons 81 ($List.cons 82 ($List.cons 83 ($List.cons 84 ($List.cons 85 ($List.cons 86 ($List.cons 87 ($List.cons 88 ($List.cons 89 ($List.cons 90 ($List.cons 97 ($List.cons 98 ($List.cons 99 ($List.cons 100 ($List.cons 101 ($List.cons 102 ($List.cons 103 ($List.cons 104 ($List.cons 105 ($List.cons 106 ($List.cons 107 ($List.cons 108 ($List.cons 109 ($List.cons 110 ($List.cons 111 ($List.cons 112 ($List.cons 113 ($List.cons 114 ($List.cons 115 ($List.cons 116 ($List.cons 117 ($List.cons 118 ($List.cons 119 ($List.cons 120 ($List.cons 121 ($List.cons 122 ($List.cons 43 ($List.cons 47 ($List.nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (let ((self2 ($Bool.and ($Nat.gtn base 0) ($Nat.lte base 64)))) (case self2 (#t (let () (let ((self2 ($List.at m base64))) (case (get self2 0) ('Maybe.none (let () 35)) ('Maybe.some (let ((f2 (get self2 1))) f2)))))) (#f (let () 35)))))))
(define (Nat.show_digit) (lambda (base) (lambda (n) ($Nat.show_digit base n))))
(define ($Nat.sub n m) (max (- n m) 0))
(define (Nat.sub) (lambda (n) (lambda (m) ($Nat.sub n m))))
(define ($Nat.sub_rem n m) (let ((self0 m)) (case (= self0 0) (#t (let () ($Either.left n))) (#f (let ((f0 (- self0 1))) (let ((self1 n)) (case (= self1 0) (#t (let () ($Either.right ($Nat.succ f0)))) (#f (let ((f1 (- self1 1))) ($Nat.sub_rem f1 f0))))))))))
(define (Nat.sub_rem) (lambda (n) (lambda (m) ($Nat.sub_rem n m))))
(define ($Nat.succ pred) (+ pred 1))
(define (Nat.succ) (lambda (pred) ($Nat.succ pred)))
(define ($Nat.to_base base nat) ($Nat.to_base.go base nat ($List.nil)))
(define (Nat.to_base) (lambda (base) (lambda (nat) ($Nat.to_base base nat))))
(define ($Nat.to_base.go base nat res) (let ((self0 ($Nat.div_mod nat base))) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((self2 f0)) (case (= self2 0) (#t (let () ($List.cons f1 res))) (#f (let ((f2 (- self2 1))) ($Nat.to_base.go base f0 ($List.cons f1 res)))))))))))
(define (Nat.to_base.go) (lambda (base) (lambda (nat) (lambda (res) ($Nat.to_base.go base nat res)))))
(define ($Nat.to_bits n) (let ((self0 n)) (case (= self0 0) (#t (let () ($Bits.o ($Bits.e)))) (#f (let ((f0 (- self0 1))) ($Bits.inc ($Nat.to_bits f0)))))))
(define (Nat.to_bits) (lambda (n) ($Nat.to_bits n)))
(define ($Nat.to_string_base base nat) ($List.fold ($Nat.to_base base nat) ($String.nil) (lambda (n) (lambda (str) ($String.cons ($Nat.show_digit base n) str)))))
(define (Nat.to_string_base) (lambda (base) (lambda (nat) ($Nat.to_string_base base nat))))
(define ($Nat.to_u16 n) n)
(define (Nat.to_u16) (lambda (n) ($Nat.to_u16 n)))
(define ($Nat.to_word size n) ($Nat.apply n (Word.inc) ($Word.zero size)))
(define (Nat.to_word) (lambda (size) (lambda (n) ($Nat.to_word size n))))
(define ($Nat.zero) 0)
(define (Nat.zero) ($Nat.zero))
(define ($Pair A B) '())
(define (Pair) (lambda (A) (lambda (B) ($Pair A B))))
(define ($Pair.fst pair) (let ((self0 pair)) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) f0)))))
(define (Pair.fst) (lambda (pair) ($Pair.fst pair)))
(define ($Pair.new fst snd) (vector 'Pair.new fst snd))
(define (Pair.new) (lambda (fst) (lambda (snd) ($Pair.new fst snd))))
(define ($Pair.snd pair) (let ((self0 pair)) (case (get self0 0) ('Pair.new (let ((f0 (get self0 1))(f1 (get self0 2))) f1)))))
(define (Pair.snd) (lambda (pair) ($Pair.snd pair)))
(define ($Parser V) '())
(define (Parser) (lambda (V) ($Parser V)))
(define ($Parser.ErrorAt) '())
(define (Parser.ErrorAt) ($Parser.ErrorAt))
(define ($Parser.ErrorAt.combine a b) (let ((self0 a)) (case (get self0 0) ('Maybe.none (let () b)) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 b)) (case (get self1 0) ('Maybe.none (let () a)) ('Maybe.some (let ((f1 (get self1 1))) (let ((self2 f0)) (case (get self2 0) ('Parser.ErrorAt.new (let ((f2 (get self2 1))(f3 (get self2 2))(f4 (get self2 3))) (let ((self5 f1)) (case (get self5 0) ('Parser.ErrorAt.new (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) (let ((self8 ($Nat.gtn f2 f5))) (case self8 (#t (let () a)) (#f (let () b)))))))))))))))))))))
(define (Parser.ErrorAt.combine) (lambda (a) (lambda (b) ($Parser.ErrorAt.combine a b))))
(define ($Parser.ErrorAt.new idx code err) (vector 'Parser.ErrorAt.new idx code err))
(define (Parser.ErrorAt.new) (lambda (idx) (lambda (code) (lambda (err) ($Parser.ErrorAt.new idx code err)))))
(define ($Parser.Reply V) '())
(define (Parser.Reply) (lambda (V) ($Parser.Reply V)))
(define ($Parser.Reply.error idx code err) (vector 'Parser.Reply.error idx code err))
(define (Parser.Reply.error) (lambda (idx) (lambda (code) (lambda (err) ($Parser.Reply.error idx code err)))))
(define ($Parser.Reply.value idx code val) (vector 'Parser.Reply.value idx code val))
(define (Parser.Reply.value) (lambda (idx) (lambda (code) (lambda (val) ($Parser.Reply.value idx code val)))))
(define ($Parser.avoiding test parse) ((($Monad.bind ($Parser.monad)) ((Parser.try) test)) (lambda (avoided) (let ((self1 avoided)) (case self1 (#t (let () ((Parser.fail) "Avoided."))) (#f (let () parse)))))))
(define (Parser.avoiding) (lambda (test) (lambda (parse) ($Parser.avoiding test parse))))
(define ($Parser.bind parse next idx code) (let ((self0 ((parse idx) code))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error f0 f1 f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) (((next f2) f0) f1))))))
(define (Parser.bind) (lambda (parse) (lambda (next) (lambda (idx) (lambda (code) ($Parser.bind parse next idx code))))))
(define ($Parser.digit idx code) (let ((self0 code)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.error idx code "Not a digit."))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((sidx ($Nat.succ idx))) (let ((self3 ($U16.eql f0 48))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 0))) (#f (let () (let ((self3 ($U16.eql f0 49))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 1))) (#f (let () (let ((self3 ($U16.eql f0 50))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 2))) (#f (let () (let ((self3 ($U16.eql f0 51))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 3))) (#f (let () (let ((self3 ($U16.eql f0 52))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 4))) (#f (let () (let ((self3 ($U16.eql f0 53))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 5))) (#f (let () (let ((self3 ($U16.eql f0 54))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 6))) (#f (let () (let ((self3 ($U16.eql f0 55))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 7))) (#f (let () (let ((self3 ($U16.eql f0 56))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 8))) (#f (let () (let ((self3 ($U16.eql f0 57))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 9))) (#f (let () ($Parser.Reply.error idx code "Not a digit.")))))))))))))))))))))))))))))))))))))))))))))))
(define (Parser.digit) (lambda (idx) (lambda (code) ($Parser.digit idx code))))
(define ($Parser.eof idx code) (let ((self0 code)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.value idx code ($Unit.new)))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($Parser.Reply.error idx code "Expected end-of-file."))))))
(define (Parser.eof) (lambda (idx) (lambda (code) ($Parser.eof idx code))))
(define ($Parser.fail error idx code) ($Parser.Reply.error idx code error))
(define (Parser.fail) (lambda (error) (lambda (idx) (lambda (code) ($Parser.fail error idx code)))))
(define ($Parser.first_of pars) (((Parser.first_of.go) pars) ($Maybe.none)))
(define (Parser.first_of) (lambda (pars) ($Parser.first_of pars)))
(define ($Parser.first_of.go pars err idx code) (let ((self0 pars)) (case (get self0 0) ('List.nil (let () (let ((self0 err)) (case (get self0 0) ('Maybe.none (let () ($Parser.Reply.error idx code "No parse."))) ('Maybe.some (let ((f0 (get self0 1))) (let ((self1 f0)) (case (get self1 0) ('Parser.ErrorAt.new (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Parser.Reply.error f1 f2 f3))))))))))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) (let ((parsed ((f0 idx) code))) (let ((self3 parsed)) (case (get self3 0) ('Parser.Reply.error (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) (let ((neo ($Maybe.some ($Parser.ErrorAt.new f3 f4 f5)))) (let ((err ($Parser.ErrorAt.combine neo err))) ($Parser.first_of.go f1 err idx code))))) ('Parser.Reply.value (let ((f3 (get self3 1))(f4 (get self3 2))(f5 (get self3 3))) ($Parser.Reply.value f3 f4 f5)))))))))))
(define (Parser.first_of.go) (lambda (pars) (lambda (err) (lambda (idx) (lambda (code) ($Parser.first_of.go pars err idx code))))))
(define ($Parser.get_index idx code) ($Parser.Reply.value idx code idx))
(define (Parser.get_index) (lambda (idx) (lambda (code) ($Parser.get_index idx code))))
(define ($Parser.hex_digit idx code) (let ((self0 code)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.error idx code "Not a digit."))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((sidx ($Nat.succ idx))) (let ((self3 ($U16.eql f0 48))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 0))) (#f (let () (let ((self3 ($U16.eql f0 49))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 1))) (#f (let () (let ((self3 ($U16.eql f0 50))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 2))) (#f (let () (let ((self3 ($U16.eql f0 51))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 3))) (#f (let () (let ((self3 ($U16.eql f0 52))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 4))) (#f (let () (let ((self3 ($U16.eql f0 53))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 5))) (#f (let () (let ((self3 ($U16.eql f0 54))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 6))) (#f (let () (let ((self3 ($U16.eql f0 55))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 7))) (#f (let () (let ((self3 ($U16.eql f0 56))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 8))) (#f (let () (let ((self3 ($U16.eql f0 57))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 9))) (#f (let () (let ((self3 ($U16.eql f0 97))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 10))) (#f (let () (let ((self3 ($U16.eql f0 98))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 11))) (#f (let () (let ((self3 ($U16.eql f0 99))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 12))) (#f (let () (let ((self3 ($U16.eql f0 100))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 13))) (#f (let () (let ((self3 ($U16.eql f0 101))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 14))) (#f (let () (let ((self3 ($U16.eql f0 102))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 15))) (#f (let () (let ((self3 ($U16.eql f0 65))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 10))) (#f (let () (let ((self3 ($U16.eql f0 66))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 11))) (#f (let () (let ((self3 ($U16.eql f0 67))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 12))) (#f (let () (let ((self3 ($U16.eql f0 68))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 13))) (#f (let () (let ((self3 ($U16.eql f0 69))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 14))) (#f (let () (let ((self3 ($U16.eql f0 70))) (case self3 (#t (let () ($Parser.Reply.value sidx f1 15))) (#f (let () ($Parser.Reply.error idx code "Not a digit.")))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(define (Parser.hex_digit) (lambda (idx) (lambda (code) ($Parser.hex_digit idx code))))
(define ($Parser.hex_nat) ((($Monad.bind ($Parser.monad)) ((Parser.text) "0x")) (lambda (-) ((($Monad.bind ($Parser.monad)) ($Parser.many1 (Parser.hex_digit))) (lambda (digits) (($Monad.pure ($Parser.monad)) ($Nat.from_base 16 digits)))))))
(define (Parser.hex_nat) ($Parser.hex_nat))
(define ($Parser.is_eof idx code) (let ((self0 code)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.value idx code ($Bool.true)))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($Parser.Reply.value idx code ($Bool.false)))))))
(define (Parser.is_eof) (lambda (idx) (lambda (code) ($Parser.is_eof idx code))))
(define ($Parser.many parser) (((Parser.many.go) parser) (lambda (x) x)))
(define (Parser.many) (lambda (parser) ($Parser.many parser)))
(define ($Parser.many1 parser) ((($Monad.bind ($Parser.monad)) parser) (lambda (head) ((($Monad.bind ($Parser.monad)) ($Parser.many parser)) (lambda (tail) (($Monad.pure ($Parser.monad)) ($List.cons head tail)))))))
(define (Parser.many1) (lambda (parser) ($Parser.many1 parser)))
(define ($Parser.many.go parse values idx code) (let ((self0 ((parse idx) code))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.value idx code (values ($List.nil))))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.many.go parse (lambda (xs) (values ($List.cons f2 xs))) f0 f1))))))
(define (Parser.many.go) (lambda (parse) (lambda (values) (lambda (idx) (lambda (code) ($Parser.many.go parse values idx code))))))
(define ($Parser.maybe parse idx code) (let ((self0 ((parse idx) code))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.value idx code ($Maybe.none)))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.value f0 f1 ($Maybe.some f2)))))))
(define (Parser.maybe) (lambda (parse) (lambda (idx) (lambda (code) ($Parser.maybe parse idx code)))))
(define ($Parser.monad) ($Monad.new (Parser.bind) (Parser.pure)))
(define (Parser.monad) ($Parser.monad))
(define ($Parser.nat) ((($Monad.bind ($Parser.monad)) ($Parser.many1 (Parser.digit))) (lambda (digits) (($Monad.pure ($Parser.monad)) ($Nat.from_base 10 digits)))))
(define (Parser.nat) ($Parser.nat))
(define ($Parser.one idx code) (let ((self0 code)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.error idx code "Unexpected end of file."))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($Parser.Reply.value ($Nat.succ idx) f1 f0))))))
(define (Parser.one) (lambda (idx) (lambda (code) ($Parser.one idx code))))
(define ($Parser.pure value idx code) ($Parser.Reply.value idx code value))
(define (Parser.pure) (lambda (value) (lambda (idx) (lambda (code) ($Parser.pure value idx code)))))
(define ($Parser.spaces) ($Parser.many ($Parser.first_of ($List.cons ((Parser.text) " ") ($List.cons ((Parser.text) "\xA;") ($List.nil))))))
(define (Parser.spaces) ($Parser.spaces))
(define ($Parser.spaces_text text) ((($Monad.bind ($Parser.monad)) ($Parser.spaces)) (lambda (-) ((Parser.text) text))))
(define (Parser.spaces_text) (lambda (text) ($Parser.spaces_text text)))
(define ($Parser.text text idx code) (let ((self0 ($Parser.text.go text idx code))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.error idx code f2))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.value f0 f1 f2))))))
(define (Parser.text) (lambda (text) (lambda (idx) (lambda (code) ($Parser.text text idx code)))))
(define ($Parser.text.go text idx code) (let ((self0 text)) (case (= (string-length self0) 0) (#t (let () ($Parser.Reply.value idx code ($Unit.new)))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 code)) (case (= (string-length self2) 0) (#t (let () (let ((error ($String.flatten ($List.cons "Expected '" ($List.cons text ($List.cons "', found end of file." ($List.nil))))))) ($Parser.Reply.error idx code error)))) (#f (let ((f2 (char->integer (string-ref self2 0)))(f3 (let ((_str_ self2)) (substring _str_ 1 (string-length _str_))))) (let ((self4 ($U16.eql f0 f2))) (case self4 (#t (let () ($Parser.text f1 ($Nat.succ idx) f3))) (#f (let () (let ((error ($String.flatten ($List.cons "Expected '" ($List.cons text ($List.cons "', found '" ($List.cons ($String.cons f2 ($String.nil)) ($List.cons "'." ($List.nil))))))))) ($Parser.Reply.error idx code error)))))))))))))))
(define (Parser.text.go) (lambda (text) (lambda (idx) (lambda (code) ($Parser.text.go text idx code)))))
(define ($Parser.try parse idx code) (let ((self0 ((parse idx) code))) (case (get self0 0) ('Parser.Reply.error (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.value idx code ($Bool.false)))) ('Parser.Reply.value (let ((f0 (get self0 1))(f1 (get self0 2))(f2 (get self0 3))) ($Parser.Reply.value idx code ($Bool.true)))))))
(define (Parser.try) (lambda (parse) (lambda (idx) (lambda (code) ($Parser.try parse idx code)))))
(define ($Parser.until until parse) ((((Parser.until.go) until) parse) ($List.nil)))
(define (Parser.until) (lambda (until) (lambda (parse) ($Parser.until until parse))))
(define ($Parser.until1 cond parser) ((($Monad.bind ($Parser.monad)) parser) (lambda (head) ((($Monad.bind ($Parser.monad)) ($Parser.until cond parser)) (lambda (tail) (($Monad.pure ($Parser.monad)) ($List.cons head tail)))))))
(define (Parser.until1) (lambda (cond) (lambda (parser) ($Parser.until1 cond parser))))
(define ($Parser.until.go until parse values idx code) (let ((until_reply ((until idx) code))) (let ((self1 until_reply)) (case (get self1 0) ('Parser.Reply.error (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) (let ((reply ((parse idx) code))) (let ((self5 reply)) (case (get self5 0) ('Parser.Reply.error (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Parser.Reply.error f5 f6 f7))) ('Parser.Reply.value (let ((f5 (get self5 1))(f6 (get self5 2))(f7 (get self5 3))) ($Parser.until.go until parse ($List.cons f7 values) f5 f6)))))))) ('Parser.Reply.value (let ((f1 (get self1 1))(f2 (get self1 2))(f3 (get self1 3))) ($Parser.Reply.value f1 f2 ($List.reverse values))))))))
(define (Parser.until.go) (lambda (until) (lambda (parse) (lambda (values) (lambda (idx) (lambda (code) ($Parser.until.go until parse values idx code)))))))
(define ($String) '())
(define (String) ($String))
(define ($String.concat as bs) (string-append as bs))
(define (String.concat) (lambda (as) (lambda (bs) ($String.concat as bs))))
(define ($String.cons head tail) (string-append (make-string 1 (integer->char head)) tail))
(define (String.cons) (lambda (head) (lambda (tail) ($String.cons head tail))))
(define ($String.drop n xs) (let ((self0 n)) (case (= self0 0) (#t (let () xs)) (#f (let ((f0 (- self0 1))) (let ((self1 xs)) (case (= (string-length self1) 0) (#t (let () ($String.nil))) (#f (let ((f1 (char->integer (string-ref self1 0)))(f2 (let ((_str_ self1)) (substring _str_ 1 (string-length _str_))))) ($String.drop f0 f2))))))))))
(define (String.drop) (lambda (n) (lambda (xs) ($String.drop n xs))))
(define ($String.eql a b) (string=? a b))
(define (String.eql) (lambda (a) (lambda (b) ($String.eql a b))))
(define ($String.flatten xs) ($String.flatten.go xs ""))
(define (String.flatten) (lambda (xs) ($String.flatten xs)))
(define ($String.flatten.go xs res) (let ((self0 xs)) (case (get self0 0) ('List.nil (let () res)) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($String.flatten.go f1 ($String.concat res f0)))))))
(define (String.flatten.go) (lambda (xs) (lambda (res) ($String.flatten.go xs res))))
(define ($String.from_list xs) (let ((self0 xs)) (case (get self0 0) ('List.nil (let () ($String.nil))) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($String.cons f0 ($String.from_list f1)))))))
(define (String.from_list) (lambda (xs) ($String.from_list xs)))
(define ($String.is_empty str) (let ((self0 str)) (case (= (string-length self0) 0) (#t (let () ($Bool.true))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($Bool.false))))))
(define (String.is_empty) (lambda (str) ($String.is_empty str)))
(define ($String.join sep list) ($String.join.go sep list ($Bool.true)))
(define (String.join) (lambda (sep) (lambda (list) ($String.join sep list))))
(define ($String.join.go sep list fst) (let ((self0 list)) (case (get self0 0) ('List.nil (let () "")) ('List.cons (let ((f0 (get self0 1))(f1 (get self0 2))) ($String.flatten ($List.cons (let ((self2 fst)) (case self2 (#t (let () "")) (#f (let () sep)))) ($List.cons f0 ($List.cons ($String.join.go sep f1 ($Bool.false)) ($List.nil))))))))))
(define (String.join.go) (lambda (sep) (lambda (list) (lambda (fst) ($String.join.go sep list fst)))))
(define ($String.length xs) ($String.length.go xs 0))
(define (String.length) (lambda (xs) ($String.length xs)))
(define ($String.length.go xs n) (let ((self0 xs)) (case (= (string-length self0) 0) (#t (let () n)) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($String.length.go f1 ($Nat.succ n)))))))
(define (String.length.go) (lambda (xs) (lambda (n) ($String.length.go xs n))))
(define ($String.nil) "")
(define (String.nil) ($String.nil))
(define ($String.pad_left size chr str) ($String.reverse ($String.pad_right size chr ($String.reverse str))))
(define (String.pad_left) (lambda (size) (lambda (chr) (lambda (str) ($String.pad_left size chr str)))))
(define ($String.pad_right size chr str) (let ((self0 size)) (case (= self0 0) (#t (let () str)) (#f (let ((f0 (- self0 1))) (let ((self1 str)) (case (= (string-length self1) 0) (#t (let () ($String.cons chr ($String.pad_right f0 chr "")))) (#f (let ((f1 (char->integer (string-ref self1 0)))(f2 (let ((_str_ self1)) (substring _str_ 1 (string-length _str_))))) ($String.cons f1 ($String.pad_right f0 chr f2)))))))))))
(define (String.pad_right) (lambda (size) (lambda (chr) (lambda (str) ($String.pad_right size chr str)))))
(define ($String.reverse xs) ($String.reverse.go xs ($String.nil)))
(define (String.reverse) (lambda (xs) ($String.reverse xs)))
(define ($String.reverse.go xs res) (let ((self0 xs)) (case (= (string-length self0) 0) (#t (let () res)) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($String.reverse.go f1 ($String.cons f0 res)))))))
(define (String.reverse.go) (lambda (xs) (lambda (res) ($String.reverse.go xs res))))
(define ($String.split xs match) ($String.split.go xs match ""))
(define (String.split) (lambda (xs) (lambda (match) ($String.split xs match))))
(define ($String.split.go xs match last) (let ((self0 xs)) (case (= (string-length self0) 0) (#t (let () ($List.cons last ($List.nil)))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 ($String.starts_with xs match))) (case self2 (#t (let () (let ((rest ($String.drop ($String.length match) xs))) ($List.cons last ($String.split.go rest match ""))))) (#f (let () (let ((next ($String.cons f0 ($String.nil)))) ($String.split.go f1 match ($String.concat last next))))))))))))
(define (String.split.go) (lambda (xs) (lambda (match) (lambda (last) ($String.split.go xs match last)))))
(define ($String.starts_with xs match) (let ((self0 match)) (case (= (string-length self0) 0) (#t (let () ($Bool.true))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) (let ((self2 xs)) (case (= (string-length self2) 0) (#t (let () ($Bool.false))) (#f (let ((f2 (char->integer (string-ref self2 0)))(f3 (let ((_str_ self2)) (substring _str_ 1 (string-length _str_))))) (let ((self4 ($Char.eql f0 f2))) (case self4 (#t (let () ($String.starts_with f3 f1))) (#f (let () ($Bool.false))))))))))))))
(define (String.starts_with) (lambda (xs) (lambda (match) ($String.starts_with xs match))))
(define ($String.to_bits str) (let ((self0 str)) (case (= (string-length self0) 0) (#t (let () ($Bits.e))) (#f (let ((f0 (char->integer (string-ref self0 0)))(f1 (let ((_str_ self0)) (substring _str_ 1 (string-length _str_))))) ($Bits.concat ($U16.to_bits f0) ($String.to_bits f1)))))))
(define (String.to_bits) (lambda (str) ($String.to_bits str)))
(define ($Test) (let ((name "Test.main")) ((($Monad.bind ($IO.monad)) ($IO.print ($String.concat "Compiling " ($String.concat name " to Scheme...")))) (lambda (-) ((($Monad.bind ($IO.monad)) ($Kind.Synth.one name ($Kind.Map.new))) (lambda (defs) '()))))))
(define (Test) ($Test))
(define ($Trampoline A) '())
(define (Trampoline) (lambda (A) ($Trampoline A)))
(define ($Trampoline.call t) (let ((self0 t)) (case (get self0 0) ('Trampoline.done (let ((f0 (get self0 1))) f0)) ('Trampoline.wrap (let ((f0 (get self0 1))) ($Trampoline.call (f0 ($Unit.new))))))))
(define (Trampoline.call) (lambda (t) ($Trampoline.call t)))
(define ($Trampoline.done value) (vector 'Trampoline.done value))
(define (Trampoline.done) (lambda (value) ($Trampoline.done value)))
(define ($Trampoline.wrap value) (vector 'Trampoline.wrap value))
(define (Trampoline.wrap) (lambda (value) ($Trampoline.wrap value)))
(define ($Unit) '())
(define (Unit) ($Unit))
(define ($Unit.new) (vector 'Unit.new))
(define (Unit.new) ($Unit.new))
(define ($U16) '())
(define (U16) ($U16))
(define ($U16.add a b) (mod (+ a b) 65536))
(define (U16.add) (lambda (a) (lambda (b) ($U16.add a b))))
(define ($U16.btw a b c) ($Bool.and ($U16.lte a b) ($U16.lte b c)))
(define (U16.btw) (lambda (a) (lambda (b) (lambda (c) ($U16.btw a b c)))))
(define ($U16.eql a b) (= a b))
(define (U16.eql) (lambda (a) (lambda (b) ($U16.eql a b))))
(define ($U16.gte a b) (>= a b))
(define (U16.gte) (lambda (a) (lambda (b) ($U16.gte a b))))
(define ($U16.inc a) (+ a 1))
(define (U16.inc) (lambda (a) ($U16.inc a)))
(define ($U16.lte a b) (<= a b))
(define (U16.lte) (lambda (a) (lambda (b) ($U16.lte a b))))
(define ($U16.ltn a b) (< a b))
(define (U16.ltn) (lambda (a) (lambda (b) ($U16.ltn a b))))
(define ($U16.mul a b) (mod (* a b) 65536))
(define (U16.mul) (lambda (a) (lambda (b) ($U16.mul a b))))
(define ($U16.new value) (word-to-u16 value))
(define (U16.new) (lambda (value) ($U16.new value)))
(define ($U16.show_hex a) (let ((self0 a)) (case #t (#t (let ((f0 (u16-to-word self0))) ($Nat.to_string_base 16 ($Bits.to_nat ($Word.to_bits f0))))))))
(define (U16.show_hex) (lambda (a) ($U16.show_hex a)))
(define ($U16.sub a b) (mod (- a b) 65536))
(define (U16.sub) (lambda (a) (lambda (b) ($U16.sub a b))))
(define ($U16.to_bits a) (let ((self0 a)) (case #t (#t (let ((f0 (u16-to-word self0))) ($Word.to_bits f0))))))
(define (U16.to_bits) (lambda (a) ($U16.to_bits a)))
(define ($U16.zero) ($U16.new ($Word.zero ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.succ ($Nat.zero))))))))))))))))))))
(define (U16.zero) ($U16.zero))
(define ($Word size) '())
(define (Word) (lambda (size) ($Word size)))
(define ($Word.add a b) ($Word.adder a b ($Bool.false)))
(define (Word.add) (lambda (a) (lambda (b) ($Word.add a b))))
(define ($Word.adder a b c) (let ((self0 a)) (case (get self0 0) ('Word.e (let () (lambda (b) ($Word.e)))) ('Word.o (let ((f0 (get self0 1))) (lambda (b) (let ((self2 b)) (case (get self2 0) ('Word.e (let () (lambda (a.pred) ($Word.e)))) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred) (let ((self4 c)) (case self4 (#t (let () ($Word.i ($Word.adder a.pred f2 ($Bool.false))))) (#f (let () ($Word.o ($Word.adder a.pred f2 ($Bool.false)))))))))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred) (let ((self4 c)) (case self4 (#t (let () ($Word.o ($Word.adder a.pred f2 ($Bool.true))))) (#f (let () ($Word.i ($Word.adder a.pred f2 ($Bool.false))))))))))))))) ('Word.i (let ((f0 (get self0 1))) (lambda (b) (let ((self2 b)) (case (get self2 0) ('Word.e (let () (lambda (a.pred) ($Word.e)))) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred) (let ((self4 c)) (case self4 (#t (let () ($Word.o ($Word.adder a.pred f2 ($Bool.true))))) (#f (let () ($Word.i ($Word.adder a.pred f2 ($Bool.false)))))))))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred) (let ((self4 c)) (case self4 (#t (let () ($Word.i ($Word.adder a.pred f2 ($Bool.true))))) (#f (let () ($Word.o ($Word.adder a.pred f2 ($Bool.true))))))))))))))))))
(define (Word.adder) (lambda (a) (lambda (b) (lambda (c) ($Word.adder a b c)))))
(define ($Word.cmp a b) ($Word.cmp.go a b ($Cmp.eql)))
(define (Word.cmp) (lambda (a) (lambda (b) ($Word.cmp a b))))
(define ($Word.cmp.go a b c) (let ((self0 a)) (case (get self0 0) ('Word.e (let () (lambda (b) c))) ('Word.o (let ((f0 (get self0 1))) (lambda (b) (let ((self2 b)) (case (get self2 0) ('Word.e (let () (lambda (a.pred) c))) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred) ($Word.cmp.go a.pred f2 c)))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred) ($Word.cmp.go a.pred f2 ($Cmp.ltn)))))))))) ('Word.i (let ((f0 (get self0 1))) (lambda (b) (let ((self2 b)) (case (get self2 0) ('Word.e (let () (lambda (a.pred) c))) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred) ($Word.cmp.go a.pred f2 ($Cmp.gtn))))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred) ($Word.cmp.go a.pred f2 c))))))))))))
(define (Word.cmp.go) (lambda (a) (lambda (b) (lambda (c) ($Word.cmp.go a b c)))))
(define ($Word.e) (vector 'Word.e))
(define (Word.e) ($Word.e))
(define ($Word.eql a b) ($Cmp.as_eql ($Word.cmp a b)))
(define (Word.eql) (lambda (a) (lambda (b) ($Word.eql a b))))
(define ($Word.from_bits size bits) (let ((self0 size)) (case (= self0 0) (#t (let () ($Word.e))) (#f (let ((f0 (- self0 1))) (let ((self1 bits)) (case (get self1 0) ('Bits.e (let () ($Word.o ($Word.from_bits f0 ($Bits.e))))) ('Bits.o (let ((f1 (get self1 1))) ($Word.o ($Word.from_bits f0 f1)))) ('Bits.i (let ((f1 (get self1 1))) ($Word.i ($Word.from_bits f0 f1)))))))))))
(define (Word.from_bits) (lambda (size) (lambda (bits) ($Word.from_bits size bits))))
(define ($Word.gte a b) ($Cmp.as_gte ($Word.cmp a b)))
(define (Word.gte) (lambda (a) (lambda (b) ($Word.gte a b))))
(define ($Word.i pred) (vector 'Word.i pred))
(define (Word.i) (lambda (pred) ($Word.i pred)))
(define ($Word.inc word) (let ((self0 word)) (case (get self0 0) ('Word.e (let () ($Word.e))) ('Word.o (let ((f0 (get self0 1))) ($Word.i f0))) ('Word.i (let ((f0 (get self0 1))) ($Word.o ($Word.inc f0)))))))
(define (Word.inc) (lambda (word) ($Word.inc word)))
(define ($Word.lte a b) ($Cmp.as_lte ($Word.cmp a b)))
(define (Word.lte) (lambda (a) (lambda (b) ($Word.lte a b))))
(define ($Word.ltn a b) ($Cmp.as_ltn ($Word.cmp a b)))
(define (Word.ltn) (lambda (a) (lambda (b) ($Word.ltn a b))))
(define ($Word.mul a b) ($Word.mul.go a b ($Word.to_zero a)))
(define (Word.mul) (lambda (a) (lambda (b) ($Word.mul a b))))
(define ($Word.mul.go a b acc) (let ((self0 a)) (case (get self0 0) ('Word.e (let () acc)) ('Word.o (let ((f0 (get self0 1))) ($Word.mul.go f0 ($Word.shift_left1 b) acc))) ('Word.i (let ((f0 (get self0 1))) ($Word.mul.go f0 ($Word.shift_left1 b) ($Word.add b acc)))))))
(define (Word.mul.go) (lambda (a) (lambda (b) (lambda (acc) ($Word.mul.go a b acc)))))
(define ($Word.o pred) (vector 'Word.o pred))
(define (Word.o) (lambda (pred) ($Word.o pred)))
(define ($Word.shift_left1 word) (let ((self0 word)) (case (get self0 0) ('Word.e (let () ($Word.e))) ('Word.o (let ((f0 (get self0 1))) ($Word.o ($Word.shift_left1.aux f0 ($Bool.false))))) ('Word.i (let ((f0 (get self0 1))) ($Word.o ($Word.shift_left1.aux f0 ($Bool.true))))))))
(define (Word.shift_left1) (lambda (word) ($Word.shift_left1 word)))
(define ($Word.shift_left1.aux word prev) (let ((self0 word)) (case (get self0 0) ('Word.e (let () ($Word.e))) ('Word.o (let ((f0 (get self0 1))) (let ((self1 prev)) (case self1 (#t (let () ($Word.i ($Word.shift_left1.aux f0 ($Bool.false))))) (#f (let () ($Word.o ($Word.shift_left1.aux f0 ($Bool.false))))))))) ('Word.i (let ((f0 (get self0 1))) (let ((self1 prev)) (case self1 (#t (let () ($Word.i ($Word.shift_left1.aux f0 ($Bool.true))))) (#f (let () ($Word.o ($Word.shift_left1.aux f0 ($Bool.true))))))))))))
(define (Word.shift_left1.aux) (lambda (word) (lambda (prev) ($Word.shift_left1.aux word prev))))
(define ($Word.sub a b) ($Word.subber a b ($Bool.false)))
(define (Word.sub) (lambda (a) (lambda (b) ($Word.sub a b))))
(define ($Word.subber a b c) (let ((self0 a)) (case (get self0 0) ('Word.e (let () (lambda (b) ($Word.e)))) ('Word.o (let ((f0 (get self0 1))) (lambda (b) (let ((self2 b)) (case (get self2 0) ('Word.e (let () (lambda (a.pred) ($Word.e)))) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred) (let ((self4 c)) (case self4 (#t (let () ($Word.i ($Word.subber a.pred f2 ($Bool.true))))) (#f (let () ($Word.o ($Word.subber a.pred f2 ($Bool.false)))))))))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred) (let ((self4 c)) (case self4 (#t (let () ($Word.o ($Word.subber a.pred f2 ($Bool.true))))) (#f (let () ($Word.i ($Word.subber a.pred f2 ($Bool.true))))))))))))))) ('Word.i (let ((f0 (get self0 1))) (lambda (b) (let ((self2 b)) (case (get self2 0) ('Word.e (let () (lambda (a.pred) ($Word.e)))) ('Word.o (let ((f2 (get self2 1))) (lambda (a.pred) (let ((self4 c)) (case self4 (#t (let () ($Word.o ($Word.subber a.pred f2 ($Bool.false))))) (#f (let () ($Word.i ($Word.subber a.pred f2 ($Bool.false)))))))))) ('Word.i (let ((f2 (get self2 1))) (lambda (a.pred) (let ((self4 c)) (case self4 (#t (let () ($Word.i ($Word.subber a.pred f2 ($Bool.true))))) (#f (let () ($Word.o ($Word.subber a.pred f2 ($Bool.false))))))))))))))))))
(define (Word.subber) (lambda (a) (lambda (b) (lambda (c) ($Word.subber a b c)))))
(define ($Word.to_bits a) (let ((self0 a)) (case (get self0 0) ('Word.e (let () ($Bits.e))) ('Word.o (let ((f0 (get self0 1))) ($Bits.o ($Word.to_bits f0)))) ('Word.i (let ((f0 (get self0 1))) ($Bits.i ($Word.to_bits f0)))))))
(define (Word.to_bits) (lambda (a) ($Word.to_bits a)))
(define ($Word.to_zero word) (let ((self0 word)) (case (get self0 0) ('Word.e (let () ($Word.e))) ('Word.o (let ((f0 (get self0 1))) ($Word.o ($Word.to_zero f0)))) ('Word.i (let ((f0 (get self0 1))) ($Word.o ($Word.to_zero f0)))))))
(define (Word.to_zero) (lambda (word) ($Word.to_zero word)))
(define ($Word.trim new_size word) (let ((self0 new_size)) (case (= self0 0) (#t (let () ($Word.e))) (#f (let ((f0 (- self0 1))) (let ((self1 word)) (case (get self1 0) ('Word.e (let () ($Word.o ($Word.trim f0 ($Word.e))))) ('Word.o (let ((f1 (get self1 1))) ($Word.o ($Word.trim f0 f1)))) ('Word.i (let ((f1 (get self1 1))) ($Word.i ($Word.trim f0 f1)))))))))))
(define (Word.trim) (lambda (new_size) (lambda (word) ($Word.trim new_size word))))
(define ($Word.zero size) (let ((self0 size)) (case (= self0 0) (#t (let () ($Word.e))) (#f (let ((f0 (- self0 1))) ($Word.o ($Word.zero f0)))))))
(define (Word.zero) (lambda (size) ($Word.zero size)))
(define ($Test.main) ($Kind.api.io.check_file "./Kind/api/export.kind"))
(define (Test.main) ($Test.main))
(run_io (Test.main))
