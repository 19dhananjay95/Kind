// Litereum: a minimal decentralized computer
// ==========================================

// Types
// -----

// A Litereum program can:
// - Create algebraic datatypes
// - Perform pattern-matching
// - Call other programs
// - Store a local state
// It is a minimal calculus, with state, comms, and no lambdas.
// Pattern-matching is linear, to preserve the cost model.
type Litereum.Term {
  var(
    index: Nat
  )
  alloc(
    type: Nat
    form: Nat
    vals: List<Litereum.Term>
  )
  match(
    type: Nat
    name: String
    expr: Litereum.Term
    cses: List<Litereum.Term>
  )
  call(
    addr: Nat
    argm: Litereum.Term
    cont: Litereum.Term
  )
  store(
    stat: Litereum.Term 
    cont: Litereum.Term
  )
}

// Litereum types are algebraic datatypes (ADTs)
type Litereum.Type {
  new(
    name: String
    forms: List<Litereum.Form>
  )
}

// A constructor of an ADT
type Litereum.Form {
  new(
    name: String
    fields: List<Litereum.Field>
  )
}

// A field of an ADT's constructor
type Litereum.Field {
  new(
    name: String
    type: Nat
  )
}

// Litereum's global state
type Litereum.World {
  new(
    names: List<String>        // registered names
    types: List<Litereum.Type> // registered types
    terms: List<Litereum.Term> // registered terms
    state: Map<Litereum.Term>  // contract states
  )
}

// A private key is a set of 32 words
Litereum.Private: Type
  Vector<U256, 32>

// A public key is the hash^32 of the private key
Litereum.Public: Type
  Vector<U256, 32>

// An address is the hash of a public key
Litereum.Address: Type
  U256

// A hash is a 256-bit word
Litereum.Hash: Type
  U256

// A signature is a set of 32 words
// - 30 words sign the first 30 bytes of the message hash
// -  2 words sign the checksum
Litereum.Signature: Type
  Vector<U256, 32>

// The 32 bytes to be signed by a signature
Litereum.Summary: Type
  Vector<U8, 32>

// The body of a Litereum Post can hold up to 8 words
Litereum.Body: Type
  Vector<U256,8>

// Actions
// -------

Litereum.World.register_name(name: String, world: Litereum.World): Litereum.World
  world@names <- name & world@names

Litereum.World.register_type(type: Litereum.Type, world: Litereum.World): Litereum.World
  world@types <- type & world@types

Litereum.World.register_term(term: Litereum.Term, world: Litereum.World): Litereum.World
  world@terms <- term & world@terms

Litereum.World.set_state(term: Nat, value: Litereum.Term, world: Litereum.World): Litereum.World
  world@state <- (world@state{Nat.show(term)} <- value)

// Utils
// -----

Litereum.World.find_type(name: String, world: Litereum.World): Maybe<Pair<Nat,Litereum.Type>>
  List.ifind!((i,t) String.eql(t@name,name), world@types)

Litereum.Type.find_form(name: String, type: Litereum.Type): Maybe<Pair<Nat,Litereum.Form>>
  List.ifind!((i,t) String.eql(t@name,name), type@forms)

// Execution
// ---------

Litereum.World.run(term: Litereum.Term, world: Litereum.World, vars: List<Litereum.Term>): Maybe<Pair<Litereum.Term, Litereum.World>>
  case term {
    var: Maybe {
      get value = vars[term.index]
      return {value,world}
    }
    match: Maybe {
      get expr_run = Litereum.World.run(term.expr, world, vars)
      let {expr, world} = expr_run
      case expr {
        alloc: Maybe {
          get body = term.cses[expr.form]
          let vars = List.reverse!(expr.vals) ++ vars
          Litereum.World.run(body, world, vars)
        }
      } default some({term,world})
    }
    alloc: Maybe {
      get run_vals = Litereum.World.run.many(term.vals, world, vars)
      let {vals, world} = run_vals
      return {Litereum.Term.alloc(term.type, term.form, vals), world}
    }
  } default some({term,world})

Litereum.World.run.many(terms: List<Litereum.Term>, world: Litereum.World, vars: List<Litereum.Term>): Maybe<Pair<List<Litereum.Term>, Litereum.World>>
  case terms {
    nil: some({[], world})
    cons: Maybe {
      get run_head = Litereum.World.run(terms.head, world, vars)
      let {head, world} = run_head
      get run_tail = Litereum.World.run.many(terms.tail, world, vars)
      let {tail, world} = run_tail
      return {head & tail, world}
    }
  }

// Printing
// --------

Litereum.Term.show(term: Litereum.Term, world: Litereum.World, vars: List<String>, depth: Nat): String
  open world
  case term {
    var: case vars[term.index] as got {
      none: "?"
      some: got.value
    }
    alloc: Maybe {
      get type = world.types[term.type]
      get form = type@forms[term.form]
      let text = ""
      let vals = List.zip_with!!!(
        (field,value)
          field@name
          | ":"
          | Litereum.Term.show(value, world, vars, depth),
        form@fields,
        term.vals)
      let vals = if List.is_empty!(vals) then "" else "{" | String.join(",",vals) | "}"
      return type@name | "#" | form@name | vals
    } <> "?"
    match: Maybe {
      get type = world.types[term.type]
      let expr = Litereum.Term.show(term.expr, world, vars, depth)
      let name = term.name
      let vals = List.zip_with!!!(
        (form,cse)
          let fields = List.map!!((x) name | "." | x@name, List.reverse!(form@fields))
          let vars = fields ++ vars
          let depth = Nat.succ(depth)
          form@name
          | ": "
          | Litereum.Term.show(cse, world, vars, depth),
        type@forms,
        term.cses)
      return type@name | "#case " | expr | " as " | name | " { " | String.join(", ",vals) | " }" 
    } <> "?"
  } default "?"

// Parsing
// -------

Litereum.Term.parser(world: Litereum.World, vars: List<String>): Parser<Litereum.Term>
  open world
  Parser.choice!([
    Litereum.Term.parser.alloc(world, vars)
    Litereum.Term.parser.match(world, vars)
    Litereum.Term.parser.var(world, vars)
  ])

Litereum.Term.parser.alloc(world: Litereum.World, vars: List<String>): Parser<Litereum.Term>
  Parser {
    get type_name = Kind.Parser.name
    case Litereum.World.find_type(type_name, world) as found {
      none: Parser.fail!("Type not found.")
      some: Parser {
        Kind.Parser.text("#")
        get form_name = Kind.Parser.name
        let {type_num, type} = found.value
        case Litereum.Type.find_form(form_name, type) as found {
          none: Parser.fail!("Form not found.")
          some: Parser {
            let {form_num, form} = found.value
            let fields = form@fields
            if List.is_empty!(fields) then Parser {
              return Litereum.Term.alloc(type_num, form_num, [])
            } else Parser {
              let fields = List.map!!((x) x@name, fields)
              Kind.Parser.text("{")
              get vals = Litereum.Term.parser.alloc.vals(fields, world, vars)
              Kind.Parser.text("}")
              return Litereum.Term.alloc(type_num, form_num, vals)
            }
          }
        }
      }
    }
  }

Litereum.Term.parser.alloc.vals(fields: List<String>, world: Litereum.World, vars: List<String>): Parser<List<Litereum.Term>>
  case fields {
    nil: Parser {
      return []
    }
    cons: Parser {
      Kind.Parser.text(fields.head)
      Kind.Parser.text(":")
      get head = Litereum.Term.parser(world, vars)
      Parser.maybe!(Kind.Parser.text(","))
      get tail = Litereum.Term.parser.alloc.vals(fields.tail, world, vars)
      return head & tail
    }
  }

Litereum.Term.parser.match(world: Litereum.World, vars: List<String>): Parser<Litereum.Term>
  Parser {
    get type_name = Kind.Parser.name
    case Litereum.World.find_type(type_name, world) as found {
      none: Parser.fail!("Type not found.")
      some: Parser {
        let {type_num, type} = found.value
        //let cses = List.map!!((x) x@name, type@forms)
        Kind.Parser.text("#")
        Kind.Parser.text("case ")
        get expr = Litereum.Term.parser(world, vars)
        Kind.Parser.text("as")
        get name = Kind.Parser.name
        Kind.Parser.text("{")
        get cses = Litereum.Term.parser.match.cses(type@forms, name, vars, world)
        Kind.Parser.text("}")
        return Litereum.Term.match(type_num, name, expr, cses)
      }
    }
  }

Litereum.Term.parser.match.cses(cses: List<Litereum.Form>, name: String, vars: List<String>, world: Litereum.World): Parser<List<Litereum.Term>>
  case cses {
    nil: Parser {
      return []
    }
    cons: Parser {
      use form = cses.head
      Kind.Parser.text(form.name)
      Kind.Parser.text(":")
      let fields = List.map!!((x) name | "." | x@name, List.reverse!(form.fields))
      get head = Litereum.Term.parser(world, fields ++ vars)
      Parser.maybe!(Kind.Parser.text(","))
      get tail = Litereum.Term.parser.match.cses(cses.tail, name, vars, world)
      return head & tail
    }
  }

Litereum.Term.parser.var(world: Litereum.World, vars: List<String>): Parser<Litereum.Term>
  Parser {
    get name = Kind.Parser.name
    case List.find_index!(vars, String.eql(name)) as found {
      none: Parser.fail!("Unbound variable '" | name | "'.")
      some: Parser {
        return Litereum.Term.var(found.value)
      }
    }
  }

// Serialization
// -------------

Litereum.Body.deserializer: Deserializer<Litereum.Body>
  Vector.deserializer!(8,U256.deserializer)

Litereum.Body.serializer: Serializer<Litereum.Body>
  Vector.serializer!(8,U256.serializer)

Litereum.Signature.deserializer: Deserializer<Litereum.Signature>
  Vector.deserializer!(32,U256.deserializer)

Litereum.Signature.serializer: Serializer<Litereum.Signature>
  Vector.serializer!(32,U256.serializer)

Litereum.Hash.serializer: Serializer<Litereum.Hash>
  U256.serializer

Litereum.Hash.deserializer: Deserializer<Litereum.Hash>
  U256.deserializer

// Signatures
// ----------

// Takes the Keccak hash of a list of words
Litereum.Hash.from_words(words: List<U256>): Litereum.Hash
  Crypto.Keccak.hash.words(words)

// Hashes a buffer into a 1024-byte signable string
Litereum.Summary.from_bytes(len_bytes: Pair<U32,Buffer8>): Litereum.Summary
  let vals = Buffer8.to_list(Crypto.Keccak.hash.bytes(len_bytes))
  let csum = 7650 :: U32
  let csum = for i from 2 to List.length!(vals): csum - U8.to_u32(vals[i] <> 0)
  let vals = vals[0] <- U32.to_u8(U32.div(csum, 256))
  let vals = vals[1] <- U32.to_u8(U32.mod(csum, 256))
  let vals = Vector.from_list.length!(32, 0, vals)
  vals

// Converts a list of words to a signable
Litereum.Summary.from_words(words: List<U256>): Litereum.Summary
  Litereum.Summary.from_bytes(Buffer8.from_list.256(words))

// Converts a UTF-8 string to a signable
Litereum.Summary.from_utf8(str: String): Litereum.Summary
  Litereum.Summary.from_bytes(Buffer8.from_hex(String.to_hex(str)))

// Converts a seed to a private key
Litereum.Private.from_seed(seed: U256): Litereum.Private
  Litereum.Private.from_seed.go(32, seed)

Litereum.Private.from_seed.go(len: Nat, seed: U256): Vector<U256,len>
  case len {
    zero:
      Vector.nil!
    succ:
      let head = Litereum.Hash.from_words([U256.add(seed, Nat.to_u256(len))])
      let tail = Litereum.Private.from_seed.go(len.pred, seed)
      Vector.cons<U256,len.pred>(head, tail)
  }!

// Coverts a private key to an address
Litereum.Public.from_private(pvt: Litereum.Private): Litereum.Private
  Litereum.Public.from_private.go(32, pvt)

Litereum.Public.from_private.go(len: Nat, pvt: Vector<U256,len>): Vector<U256,len>
  case len with pvt {
    zero: Vector.nil!
    succ: case pvt {
      cons:
        let hash = pvt.head
        let hash = for i from 0 to 256:
          Litereum.Hash.from_words([hash])
        Vector.cons<U256,len.pred>(hash, Litereum.Public.from_private.go(len.pred, pvt.tail))
    }
  }!

// Converts a public key to an address
Litereum.Address.from_public(pub: Litereum.Public): Litereum.Address
  let vals = Buffer8.from_list.256(Vector.to_list!(32, pub))
  let addr = Buffer8.to_u256(Crypto.Keccak.hash.bytes(vals)@snd)
  addr

// Signs a signable
Litereum.Signature.sign(msg: Litereum.Summary, pvt: Litereum.Private): Litereum.Signature
  Litereum.Signature.sign.go(32, msg, pvt)

Litereum.Signature.sign.go(len: Nat, msg: Vector<U8,len>, pvt: Vector<U256,len>): Vector<U256,len>
  case len with msg pvt {
    zero: case msg pvt {
      nil nil: Vector.nil!
    }
    succ: case msg pvt {
      cons cons:
        let hash = pvt.head
        let hash = for i from 0 to 256 - U8.to_nat(msg.head):
          Litereum.Hash.from_words([hash])
        Vector.cons<U256,len.pred>(hash, Litereum.Signature.sign.go(len.pred, msg.tail, pvt.tail))
    }
  }!

// Verifies if a signature is correct
Litereum.Signature.verify(msg: Litereum.Summary, addr: Litereum.Address, sig: Litereum.Signature): Bool
  let checksums = Litereum.Signature.checksum(msg)
  let sign_addr = Litereum.Signature.recover(msg, sig)
  checksums && U256.eql(addr, sign_addr)

// Checks if the signable checksum is correct
Litereum.Signature.checksum(msg: Litereum.Summary): Bool
  Litereum.Signature.checksum.go(32, msg)

Litereum.Signature.checksum.go(len: Nat, msg: Vector<U8,len>): Bool
  let vals = Vector.to_list<U8>(len, msg)
  let csum = 7650 :: U32
  let csum = for i from 2 to List.length!(vals):
    csum - U8.to_u32(vals[i] <> 0)
  let cs_0 = U8.to_u32(vals[0] <> 0)
  let cs_1 = U8.to_u32(vals[1] <> 0)
  U32.eql(csum, U32.add(U32.mul(cs_0, 256), cs_1))

// Returns the public key that signed a message
Litereum.Signature.recover(msg: Litereum.Summary, sig: Litereum.Signature): Litereum.Address
  Litereum.Address.from_public(Litereum.Signature.recover.go(32, msg, sig))

Litereum.Signature.recover.go(len: Nat, msg: Vector<U8,len>, sig: Vector<U256,len>): Vector<U256,len>
  case len with msg sig {
    zero: Vector.nil!
    succ: case msg sig {
      cons cons cons:
        let hash = sig.head
        let hash = for i from 0 to U8.to_nat(msg.head): Litereum.Hash.from_words([hash])
        Vector.cons<U256,len.pred>(hash, Litereum.Signature.recover.go(len.pred, msg.tail, sig.tail))
    }
  }!

// Dead code
// ---------

////Litereum.Term.eval(
  ////term: Litereum.Term
  ////world: Litereum.World
////): Litereum.Term
  ////case term {
    ////app: case Litereum.Term.reduce(term.func) as func {
      ////lam: Litereum.Term.reduce(func.body(term.argm))
    ////} default term
    ////elim: case Litereum.Term.reduce(term.bits) as bits {
      ////nil: Litereum.Term.reduce(term.case_nil)
      ////cons0: Litereum.Term.reduce(term.case_cons0(bits.pred))
      ////cons1: Litereum.Term.reduce(term.case_cons1(bits.pred))
    ////} default term
  ////} default term
  
////type Litereum.Result {
  ////new(
    ////cost: Nat
    ////value: Litereum.Term
    ////world: Litereum.World
  ////)
////}

////Litereum.Term.execute(
  ////cost: Nat
  ////addr: Litereum.Address
  ////term: Litereum.Term
  ////world: Litereum.World
////): Litereum.Result
  ////open world
  ////let bond = world.bonds{U256.show(addr)}
  ////case Litereum.Term.reduce(term) as term {
    ////return:
      ////Litereum.Result.new(cost, term.result, world)
    ////get: 
      ////let cost = cost + 1
      ////let key = Litereum.Term.to_bits(term.key)
      ////case bond {
        ////none:
          ////Litereum.Term.execute(cost, addr, term.cont(Litereum.Term.nil), world)
        ////some:
          ////use bond = bond.value
          ////let val = Litereum.Term.from_bits(bond.state{Bits.show(key)} <> Bits.e)
          ////Litereum.Term.execute(cost, addr, term.cont(val), world)
      ////}
    ////set:
      ////let cost = cost + 1
      ////let key = Litereum.Term.to_bits(term.key)
      ////let val = Litereum.Term.to_bits(term.val)
      ////let world = case bond {
        ////none:
          ////world
        ////some: 
          ////use bond = bond.value
          ////let state = bond.state{Bits.show(key)} <- val
          ////let bond = bond@state <- state
          ////let bonds = world.bonds{U256.show(addr)} <- bond
          ////world@bonds <- bonds
      ////}
      ////Litereum.Term.execute(cost, addr, term.cont, world)
    ////call:
      ////let cost = cost + 1
      ////let targ_addr = Litereum.Term.to_address(term.addr)
      ////let targ_bond = world.bonds{U256.show(targ_addr)}
      ////case targ_bond {
        ////none:
          ////Litereum.Term.execute(cost, addr, term.cont(Litereum.Term.nil), world)
        ////some:
          ////use targ_bond = targ_bond.value
          ////let targ_term = targ_bond.main
          ////let targ_term = Litereum.Term.app(targ_term, Litereum.Term.from_address(targ_addr))
          ////let targ_term = Litereum.Term.app(targ_term, Litereum.Term.to_bits(term.args))
          ////use result = Litereum.Term.execute(cost, targ_addr, targ_term, world)
          ////Litereum.Term.execute(result.cost, addr, term.cont(result.value), result.world)
      ////}
    ////spawn:
      ////let cost = cost + 1
      ////let bond_addr = Litereum.Term.to_address(term.addr)
      ////let world.bonds = world.bonds{U256.show(bond_addr)} <- Litereum.Bond.new(term.main, {})
      ////let world = world@bonds <- world.bonds
      ////Litereum.Term.execute(cost, addr, term.cont, world)
  ////} default Litereum.Result.new(cost, Litereum.Term.nil, world)

////Litereum.Term.parser: Parser<Litereum.Term>
  ////Parser.choice!([
    ////Parser {
      ////Kind.Parser.text("@")
      ////get bind = Kind.Parser.name
      ////Kind.Parser.text("=>")
      ////get body = Litereum.Term.parser
      ////return Litereum.Term.lam(bind, () body)
    ////}
    ////Parser {
      ////Kind.Parser.text("(")
      ////get func = Litereum.Term.parser
      ////get argm = Litereum.Term.parser
      ////Kind.Parser.text(")")
      ////return Litereum.Term.app(func, argm)
    ////}
    ////Parser {
      ////Kind.Parser.text("*")
      ////return Litereum.Term.nil
    ////}
    ////Parser {
      ////Kind.Parser.text("0")
      ////get pred = Litereum.Term.parser
      ////return Litereum.Term.cons0(pred)
    ////}
    ////Parser {
      ////Kind.Parser.text("1")
      ////get pred = Litereum.Term.parser
      ////return Litereum.Term.cons1(pred)
    ////}
    ////Parser {
      ////Kind.Parser.text("case ")
      ////get bits = Litereum.Term.parser
      ////Kind.Parser.text("as")
      ////get name = Kind.Parser.name
      ////Kind.Parser.text("{")
      ////Kind.Parser.text("$:")
      ////get case_nil = Litereum.Term.parser
      ////Kind.Parser.text("0:")
      ////get case_cons0 = Litereum.Term.parser
      ////Kind.Parser.text("1:")
      ////get case_cons1 = Litereum.Term.parser
      ////Kind.Parser.text("}")
      ////return Litereum.Term.elim(bits, name, case_nil, () case_cons0, () case_cons1)
    ////}
    ////Parser {
      ////Kind.Parser.text("{")
      ////get statements = Litereum.Block.parser
      ////Kind.Parser.text("}")
      ////return Litereum.Term.block(statements)
    ////}
  ////])

////Litereum.Term.show(term: Litereum.Term): String
  ////case term {
    ////lam:
      ////"@"
      ////| term.name
      ////| " => "
      ////| Litereum.Term.show(term.body(Litereum.Term.var(term.name)))
    ////app:
      ////"("
      ////| Litereum.Term.show(term.func)
      ////| " "
      ////| Litereum.Term.show(term.argm)
      ////| ")"
    ////var:
      ////term.name
    ////nil:
      ////"*"
    ////cons0:
      ////"0" | Litereum.Term.show(term.pred)
    ////cons1:
      ////"1" | Litereum.Term.show(term.pred)
    ////elim:
      ////"case "
      ////| Litereum.Term.show(term.bits)
      ////| " as "
      ////| term.name
      ////| " {"
      ////| " $: " | Litereum.Term.show(term.case_nil)
      ////| " 0: " | Litereum.Term.show(term.case_cons0(Litereum.Term.var(term.name | ".pred")))
      ////| " 1: " | Litereum.Term.show(term.case_cons0(Litereum.Term.var(term.name | ".pred")))
      ////| "}"
    ////block:
      ////"{"
      ////| Litereum.Block.show(term.statements)
      ////| "}"
  ////}

////Litereum.Block.parser: Parser<Litereum.Block>
  ////Parser.choice!([
    ////Parser {
      ////Kind.Parser.text("return ")
      ////get result = Litereum.Term.parser
      ////return Litereum.Block.return(result)
    ////}
    ////Parser {
      ////get bind = Kind.Parser.name
      ////Kind.Parser.text("=")
      ////Kind.Parser.text("(get ")
      ////get key = Litereum.Term.parser
      ////Kind.Parser.text(")")
      ////Kind.Parser.text(";")
      ////get cont = Litereum.Block.parser
      ////return Litereum.Block.get(key, bind, () cont)
    ////}
    ////Parser {
      ////Kind.Parser.text("(set ")
      ////get key = Litereum.Term.parser
      ////get val = Litereum.Term.parser
      ////Kind.Parser.text(")")
      ////Kind.Parser.text(";")
      ////get cont = Litereum.Block.parser
      ////return Litereum.Block.set(key, val, cont)
    ////}
    ////Parser {
      ////get bind = Kind.Parser.name
      ////Kind.Parser.text("=")
      ////Kind.Parser.text("(call")
      ////get addr = Litereum.Term.parser
      ////get args = Litereum.Term.parser
      ////Kind.Parser.text(")")
      ////Kind.Parser.text(";")
      ////get cont = Litereum.Block.parser
      ////return Litereum.Block.call(addr, args, bind, () cont)
    ////}
    ////Parser {
      ////Kind.Parser.text("(spawn ")
      ////get addr = Litereum.Term.parser
      ////get main = Litereum.Term.parser
      ////Kind.Parser.text(")")
      ////Kind.Parser.text(";")
      ////get cont = Litereum.Block.parser
      ////return Litereum.Block.spawn(addr, main, cont)
    ////}
  ////])

////Litereum.Block.show(block: Litereum.Block): String
  ////case block {
    ////return:
      ////"return "
      ////| Litereum.Term.show(block.result)
      ////| ";"
    ////get:
      ////block.bind
      ////| " = (get " | Litereum.Term.show(block.key) | "); "
      ////| Litereum.Block.show(block.cont(Litereum.Term.var(block.bind)))
    ////set:
      ////"(set "
      ////| Litereum.Term.show(block.key)
      ////| " "
      ////| Litereum.Term.show(block.val)
      ////| "); "
      ////| Litereum.Block.show(block.cont)
    ////call:
      ////block.bind
      ////| " = "
      ////| "(call "
      ////| Litereum.Term.show(block.addr)
      ////| " "
      ////| Litereum.Term.show(block.args)
      ////| "); "
      ////| Litereum.Block.show(block.cont(Litereum.Term.var(block.bind)))
    ////spawn:
      ////"(spawn "
      ////| Litereum.Term.show(block.addr)
      ////| " "
      ////| Litereum.Term.show(block.main)
      ////| "); "
      ////| Litereum.Block.show(block.cont)
  ////}

// Tests
// -----

Litereum: _
  let world = Litereum.World.new([], [], [], {})
  let world = Litereum.World.register_type(Litereum.Type.new("Bool", [
    Litereum.Form.new("true", [])
    Litereum.Form.new("false", [])
  ]), world)
  let world = Litereum.World.register_type(Litereum.Type.new("Nat", [
    Litereum.Form.new("zero", [])
    Litereum.Form.new("succ", [
      Litereum.Field.new("pred", 1)
    ])
  ]), world)
  let world = Litereum.World.register_type(Litereum.Type.new("Foo", [
    Litereum.Form.new("new", [
      Litereum.Field.new("bool", 0)
      Litereum.Field.new("nat", 1)
    ])
  ]), world)
  let code = "
    Foo#case Foo#new{bool:Bool#true,nat:Nat#zero} as val {
      new: Nat#succ{pred:val.nat}
    }"
  let term = Parser.run!(Litereum.Term.parser(world,[]), code) <> Litereum.Term.var(0)
  let result = Litereum.World.run(term, world, [])
  IO {
    IO.print(Litereum.Term.show(term, world, [], 0))
    IO.print(case result { none: "", some: Litereum.Term.show(result.value@fst, result.value@snd, [], 0) })
  }
