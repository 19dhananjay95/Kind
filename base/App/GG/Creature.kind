type App.GG.Creature { 
  new(
    category: App.GG.Monster
    team: App.GG.Team
    animation: Pair<App.GG.Animation, U64>
    actions: App.GG.Actions
    statuses: App.GG.Creature.Statuses
    hp: I32
    id: Nat
  )
}


type App.GG.Creature.Dna {
  new(
    alteration: String //TODO
    attributes: App.GG.Creature.Attributes
    body: App.GG.Body
  )
}

type App.GG.Creature.Attributes {
  new(
    hp:I32
    energy:I32
    damage:I32
    corruption: I32
  )
}


App.GG.Creature.Attributes.add(
  a: App.GG.Creature.Attributes
  b: App.GG.Creature.Attributes
): App.GG.Creature.Attributes

  let hp = a@hp + b@hp
  let energy = a@energy + b@energy
  let damage = a@damage + b@damage
  let corruption = a@corruption + b@corruption
  App.GG.Creature.Attributes.new(hp, energy, damage, corruption)

App.GG.Creature.Attributes.base: App.GG.Creature.Attributes
  App.GG.Creature.Attributes.new(
    25 // hp
    25 // energy
    25 // damage
    25 // corruption
  )

//===========================================================
//Creature Management

App.GG.Creature.modify_at(
  mod: App.GG.Creature -> App.GG.Creature
  pos: App.GG.Coord
  grid: App.GG.Grid
): App.GG.Grid
  
  let result = Maybe { 
    get creature = App.GG.Creature.get(pos, grid)
    let mod = App.GG.Tile.update_creature(mod)
    let new_grid = App.GG.Grid.update(pos, mod, grid)
    return new_grid
  }
  result <> grid


App.GG.Creature.get(
  place: App.GG.Coord
  grid: App.GG.Grid
): Maybe<App.GG.Creature>

  let tile = App.GG.Grid.get(place, grid)
  case tile { 
    none:
      none
    some:
      tile.value@creature
  }


//===========================================================
//Status Management

type App.GG.Creature.Statuses {
  new(
    poison: Maybe<App.GG.Creature.Status>
    stun: Maybe<App.GG.Creature.Status>
  )
}

type App.GG.Creature.Status {
  // invulnerable(duration: U64)
  // intangible(duration: U64)
  // poison(duration: U64, damage: I32)
  // root(duration: U64)
  poison(duration: U64, damage: I32)
  stun(category: App.GG.Creature.Status.Stun)
}

App.GG.Creature.Statuses.pure: App.GG.Creature.Statuses
  App.GG.Creature.Statuses.new(none, none)

type App.GG.Creature.Status.Stun {
  flinch
  shock
}

App.GG.Creature.Status.del_from_nat(count: Nat, creature: App.GG.Creature): App.GG.Creature
  let statuses = creature@statuses
  let new_statuses = 
    switch Nat.eql(count) {
    0: statuses@poison <- none
    1: statuses@stun <- none
  }default statuses
  creature@statuses <- new_statuses

App.GG.Creature.Status.add(status: App.GG.Creature.Status, creature: App.GG.Creature): App.GG.Creature
  let statuses = creature@statuses
  let new_statuses = 
    case status {
      poison: statuses@poison <- some(status)
      stun: statuses@stun <- some(status)
    }
  creature@statuses <- new_statuses

App.GG.Creature.Status.get_from_nat(count: Nat, statuses: App.GG.Creature.Statuses): Maybe<Maybe<App.GG.Creature.Status>>
  switch Nat.eql(count) {
    0: some(statuses@poison)
    1: some(statuses@stun)
  }default none

App.GG.Creature.Status.update_grid(coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
  App.GG.Creature.Status.update_grid.go(0, coord, local)

App.GG.Creature.Status.update_grid.go(count: Nat, coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
let grid = local@grid
  let new_local = 
    Maybe {
      get creature = App.GG.Creature.get(coord, grid)
      let statuses = creature@statuses
      get status = App.GG.Creature.Status.get_from_nat(count, statuses)
      let new_local = 
        without status: local
        case status {
          poison: App.GG.Creature.Status.update_poison(status, coord, local)
          stun: App.GG.Creature.Status.update_stun(status, coord, local)
        }default local
      let new_local = App.GG.Creature.Status.update_grid.go(count +1, coord, new_local)
      return new_local
    } <> local
  new_local

App.GG.Creature.Status.update_poison(status: App.GG.Creature.Status, coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
  case status {
    poison: 
      log(U64.show(status.duration))
      let grid = local@grid
      let new_grid = 
        if status.duration =? 0 then
          let new_creature = App.GG.Creature.Status.del_from_nat(0)
          let new_grid     = App.GG.Creature.modify_at(new_creature, coord, grid)
          new_grid
        else
          let new_creature = App.GG.Creature.Status.add(App.GG.Creature.Status.poison(status.duration - 1, status.damage))
          let new_grid = App.GG.Creature.modify_at(new_creature, coord, grid)
          new_grid
      let new_local = local@grid <- new_grid
      if (status.duration % 10) =? 0 then 
        let eff = App.GG.Effect.creature.change_hp_at(status.damage, coord, false)
        let result = eff(coord, App.GG.Effect.Origin.creature, new_local)
        case result {err: new_local, new: result.local}
      else
        new_local

  }default local

App.GG.Creature.Status.update_stun(status: App.GG.Creature.Status, coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
  case status {
    stun: 
      let grid = local@grid
      let new_creature = App.GG.Creature.Status.add(App.GG.Creature.Status.stun(status.category))
      let new_grid     = App.GG.Creature.modify_at(new_creature, coord, grid)
      let new_local    = local@grid <- new_grid
      new_local
  }default local
// New Status




// App.GG.Creature.status_update(
//   creature: App.GG.Creature
// ): App.GG.Creature
  
//   let status_update = App.GG.Creature.status_update_aux(creature@status)
//   creature@status <- status_update

// App.GG.Creature.status_update_aux(
//   status: List<App.GG.Creature.Status>
// ):List<App.GG.Creature.Status>

//   case status { 
//     nil:
//       []
//     cons:
//       let head = case status.head { 
//         flinch: App.GG.Creature.Status.flinch
//         invulnerable: App.GG.Creature.Status.invulnerable(status.head.duration - 1)
//         noname: App.GG.Creature.Status.noname(status.head.duration -1)
//         poison: App.GG.Creature.Status.poison(status.head.duration - 1, status.head.damage)
//         root: App.GG.Creature.Status.root(status.head.duration - 1)
//         stun: App.GG.Creature.Status.stun

//       }
//       let tail = App.GG.Creature.status_update_aux(status.tail)
//       case head { 
//         flinch: head & tail
//         invulnerable: if U64.gtn(head.duration, 0) then head & tail else tail
//         noname: head & tail
//         poison: if U64.gtn(head.duration, 0) then head & tail else tail
//         root: if U64.gtn(head.duration, 0) then head & tail else tail
//         stun: head & tail
//       }
//   }


// App.GG.Creature.add_status(
//   status:  App.GG.Creature.Status
//   creature: App.GG.Creature
// ): App.GG.Creature

//   let invul = App.GG.Creature.status_check_invulnerable(creature)
//   if invul then 
//     case status { 
//       invulnerable: App.GG.Creature.status_add_invulnerable(creature, status.duration)
//     }default creature
//   else
//     case status {
//       flinch: App.GG.Creature.status_add_flinch(creature)
//       invulnerable: App.GG.Creature.status_add_invulnerable(creature, status.duration)
//       noname: App.GG.Creature.status_add_noname(creature, status.duration)
//       poison: App.GG.Creature.status_add_poison(creature, status.duration, status.damage)
//       root:App.GG.Creature.status_add_root(creature, status.duration)
//       stun: App.GG.Creature.status_add_stun(creature)
//     }


// App.GG.Creature.status_add_flinch(
//   creature: App.GG.Creature
// ): App.GG.Creature
  
//   let new_status = App.GG.Creature.Status.flinch & creature@status
//   creature@status <- new_status

// App.GG.Creature.status_add_invulnerable(
//   creature: App.GG.Creature
//   duration: U64
// ): App.GG.Creature
  
//   let new_status = App.GG.Creature.status_add_invulnerable_aux(duration, creature@status)
//   creature@status <- new_status

// App.GG.Creature.status_add_invulnerable_aux(
//   duration: U64
//   status: List<App.GG.Creature.Status>
// ): List<App.GG.Creature.Status>

//   let new_invul = App.GG.Creature.Status.invulnerable(duration)
//   case status {
//     nil: new_invul & status
//     cons:
//       case status.head { 
//         invulnerable:
//           if U64.gtn(status.head.duration, duration) then
//             status
//           else
//             new_invul & status.tail
//       }default status.head & App.GG.Creature.status_add_invulnerable_aux(duration, status.tail)
//   }


// App.GG.Creature.status_check_invulnerable(
//   creature: App.GG.Creature
// ): Bool
//   let status = creature@status
//   case status { 
//     invulnerable: true
//   }default false


// App.GG.Creature.status_add_noname(
//   creature: App.GG.Creature
//   duration: U64
// ): App.GG.Creature
  
//   let new_status = App.GG.Creature.status_add_noname_aux(duration, creature@status)
//   creature@status <- new_status


// App.GG.Creature.status_add_noname_aux(
//   duration: U64
//   status: List<App.GG.Creature.Status>
// ): List<App.GG.Creature.Status>

//   let new_noname = App.GG.Creature.Status.noname(duration)
//   case status {
//     nil: new_noname & status
//     cons:
//       case status.head { 
//         noname:
//           if U64.gtn(status.head.duration, duration) then
//             status
//           else
//             new_noname & status.tail
//       }default status.head & App.GG.Creature.status_add_noname_aux(duration, status.tail)
//   }

// App.GG.Creature.status_check_noname(
//   creature: App.GG.Creature
// ): Bool
//   let status = creature@status
//   case status { 
//     noname: true
//   }default false


// App.GG.Creature.status_add_poison(
//   creature: App.GG.Creature
//   duration: U64
//   damage: I32
// ): App.GG.Creature
  
//   let new_status = App.GG.Creature.status_add_poison_aux(duration, damage, creature@status)
//   creature@status <- new_status


// App.GG.Creature.status_add_poison_aux(
//   duration: U64
//   damage: I32
//   status: List<App.GG.Creature.Status>
// ): List<App.GG.Creature.Status>

//   let new_poison = App.GG.Creature.Status.poison(duration, damage)
//   case status {
//     nil: new_poison & status
//     cons:
//       case status.head { 
//         poison:
//           if U64.gtn(status.head.duration, duration) then
//             status
//           else
//             new_poison & status.tail
//       }default status.head & App.GG.Creature.status_add_poison_aux(duration, damage, status.tail)
//   }


// App.GG.Creature.status_add_root(
//   creature: App.GG.Creature
//   duration: U64
// ): App.GG.Creature
  
//   let new_status = App.GG.Creature.status_add_root_aux(duration, creature@status)
//   creature@status <- new_status


// App.GG.Creature.status_add_root_aux(
//   duration: U64
//   status: List<App.GG.Creature.Status>
// ): List<App.GG.Creature.Status>

//   let new_root = App.GG.Creature.Status.root(duration)
//   case status {
//     nil: new_root & status
//     cons:
//       case status.head { 
//         root:
//           if U64.gtn(status.head.duration, duration) then
//             status
//           else
//             new_root & status.tail
//       }default status.head & App.GG.Creature.status_add_root_aux(duration, status.tail)
//   }

  
// App.GG.Creature.status_add_stun(
//   creature: App.GG.Creature
// ): App.GG.Creature
  
//   let new_status = App.GG.Creature.Status.stun & creature@status
//   creature@status <- new_status

// App.GG.Creature.status_eql(a: App.GG.Creature.Status, b: App.GG.Creature.Status): Bool
//   case a b {
//     invulnerable invulnerable: true
//     poison poison: true
//     root root: true
//     stun root: true
//   }default false

// App.GG.Creature.status_different(a: App.GG.Creature.Status, b: App.GG.Creature.Status): Bool
//   not(App.GG.Creature.status_eql(a, b))

// App.GG.Creature.del_status(status: App.GG.Creature.Status, creature: App.GG.Creature): App.GG.Creature
//   let new_status = List.filter!(App.GG.Creature.status_different(status), creature@status)
//   creature@status <- new_status


//===========================================================

App.GG.Creature.sub_folder(quantity: Nat, creature: App.GG.Creature): App.GG.Creature
  case creature@category as monster {
    minion: creature
    slime:
      creature@category <- App.GG.Monster.slime(monster.data, monster.hand, List.drop!(quantity, monster.folder), monster.energy)
  }

App.GG.Creature.shuffle_folder(seed: Nat, creature: App.GG.Creature): App.GG.Creature
  case creature@category as monster {
    minion: creature
    slime:
      let new_folder = App.GG.Chips.shuffle(seed, monster.folder)
      creature@category <- App.GG.Monster.slime(monster.data, monster.hand, new_folder, monster.energy)
  }

App.GG.Creature.add_chip(chip: App.GG.Chip, creature: App.GG.Creature): App.GG.Creature
  case creature@category as monster {
    minion: creature
    slime:
      let category = App.GG.Monster.slime(monster.data, chip & monster.hand, monster.folder, monster.energy)
      creature@category <- category
  }

App.GG.Creature.delete(coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  let tile = App.GG.Grid.get(coord, grid)
  without tile: grid
  let new_tile = tile@creature <- none
  App.GG.Grid.set(coord, new_tile, grid)

App.GG.Creature.create_slime(slime: App.GG.Slime, grid: App.GG.Grid): App.GG.Creature
  let team = App.GG.Team.blue
  let animation = {App.GG.Animation.idle, 0#64}
  let actions = App.GG.Actions.new(none, none, false)
  let status = App.GG.Creature.Statuses.pure
  let id = App.GG.Grid.next_id(grid)
  let dna = slime@dna
  let body = dna@body
  let data = slime
  let hand = []
  let folder = App.GG.Body.to_folder(body)
  let hp = dna@attributes@hp * 10
  let energy = 0 :: I32
  let monster = App.GG.Monster.slime(data, hand, folder, energy)
  App.GG.Creature.new(monster, team, animation, actions, status, hp, id)

App.GG.Creature.create_minion(minion: App.GG.Minion, grid: App.GG.Grid): App.GG.Creature
  let team = App.GG.Team.red
  let animation = {App.GG.Animation.idle, 0#64}
  let actions = App.GG.Actions.new(none, none, false)
  let status = App.GG.Creature.Statuses.pure
  let id = App.GG.Grid.next_id(grid)
  let AI = App.GG.AI.new(0, 0)
  let hp = minion@hp
  let monster = App.GG.Monster.minion(minion, AI)
  App.GG.Creature.new(monster, team, animation, actions, status, hp, id)

App.GG.Creature.place(creature: App.GG.Creature, coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  let f = 
    (tile: App.GG.Tile)
    tile@creature <- some(creature)
  App.GG.Grid.update(coord, f, grid)

App.GG.Creature.dmg_with_attribute(creature: App.GG.Creature, dmg: I32): I32
  let attributes = App.GG.Creature.Attributes.get(creature)
  without attributes: dmg
  let destruction = attributes@damage
  (dmg * destruction) / 25

App.GG.Creature.basic_attack_dmg(creature: App.GG.Creature): I32
  let attributes = App.GG.Creature.Attributes.get(creature)
  without attributes: 0 :: I32
  let base_dmg  = 2 :: I32
  let extra_dmg = (attributes@damage - 25) / 5
  let total_dmg = base_dmg + extra_dmg
  I32.neg(total_dmg)

App.GG.Creature.Attributes.get(creature: App.GG.Creature): Maybe<App.GG.Creature.Attributes>
  case creature@category as monster {
    minion: none
    slime:
      let slime = monster.data
      let dna = slime@dna
      let attributes = dna@attributes
      some(attributes)
  }

// ============================================================================
// Grid Update functions

// If creature hasn't acted, update its actions, run its effects and update animation to next frame
App.GG.Creature.run(coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
  if App.GG.Creature.has_acted(coord, local) then 
    local
  else
    let new_local = App.GG.Creature.run_ai(coord, local)
    let new_local = App.GG.Creature.update_actions(coord, new_local)
    let new_local = App.GG.Creature.update_animation(coord, new_local)
    let new_local = App.GG.Actions.run(coord, new_local)
    new_local

// Checks if creature has acted in this frame
App.GG.Creature.has_acted(coord: App.GG.Coord, local: App.GG.State.local): Bool
  let creature = App.GG.Creature.get(coord, local@grid)
  without creature: false
  creature@actions@has_acted

App.GG.Creature.reset_actions.aux(creature: App.GG.Creature): App.GG.Creature
  let actions = creature@actions
  let new_actions = actions@has_acted <- false
  creature@actions <- new_actions

// Updates animation to its next frame
App.GG.Creature.update_animation(coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
  let mod = (creature: App.GG.Creature) creature@animation <- {creature@animation@fst, creature@animation@snd + 1}
  let new_grid = App.GG.Creature.modify_at(mod, coord, local@grid)
  let new_local = local@grid <- new_grid
  new_local
// If current action is "none", moves next action to its place
App.GG.Creature.update_actions(coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
  let grid = local@grid
  let new_grid = App.GG.Creature.modify_at(App.GG.Creature.update_actions.aux, coord, grid)
  let new_local = local@grid <- new_grid
  new_local

App.GG.Creature.update_actions.aux(creature: App.GG.Creature): App.GG.Creature
  let actions = creature@actions
  let next_action = actions@next
  let curr_action  = actions@current
  without curr_action: 
    without next_action: creature
    let new_actions = actions@current <- some(next_action)
    let new_actions = new_actions@next <- none
    let new_creature = creature@actions <- new_actions
    new_creature
  creature

// Changes creature's has_acted to false
App.GG.Creature.reset_actions(coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  App.GG.Creature.modify_at(App.GG.Creature.reset_actions.aux, coord, grid)

App.GG.Creature.run_ai(coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
  Maybe {
    let grid = local@grid
    get creature = App.GG.AI.get(coord, grid)
    get minion = App.GG.Minion.get(coord, grid)
    let result = minion@effect(coord, App.GG.Effect.Origin.creature, local)
    let new_local = case result {err: local, new: result.local}
    return new_local
  } <> local
    

// ============================================================================