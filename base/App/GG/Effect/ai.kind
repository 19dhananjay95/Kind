App.GG.Effect.ai.update(
  mod: App.GG.AI -> App.GG.AI
): App.GG.Effect<Unit>
  (center, origin, local)

  let new_grid = App.GG.Creature.modify_at(App.GG.AI.update(mod), center, local@grid)
  let new_local = local@grid <- new_grid
  App.GG.Effect.Result.new!(unit, center, origin, new_local, (enemy, img) img, 0, "")


App.GG.Effect.ai.get: App.GG.Effect<Maybe<App.GG.AI>>
  (center, origin, local)

  let new_AI = App.GG.AI.get(center, local@grid)
  App.GG.Effect.Result.new!(new_AI, center, origin, local, (enemy, img) img, 0, "")

App.GG.Effect.ai.inc(reset: Bool): App.GG.Effect<Unit>
  App.GG.Effect { 
    get center = App.GG.Effect.coord.get_center
    get creature = App.GG.Effect.creature.get
    get grid = App.GG.Effect.grid.get
    without creature: App.GG.Effect.pass
    let coords = App.GG.Coord.front_all(center, creature@team, grid)
    let target = false
    for coord in coords with target:
      target || App.GG.Coord.has_enemy(coord, creature@team, grid)
    let inc = if reset then App.GG.AI.inc else App.GG.AI.inc_no_reset
    App.GG.Effect.ai.update(inc(target))
  }

App.GG.Effect.ai.run(
  seen: List<Pair<U64, App.GG.Effect<Unit>>>
  unseen: List<Pair<U64, App.GG.Effect<Unit>>>
  reset_ai: Bool
): App.GG.Effect<Unit>
  App.GG.Effect { 
    get ai = App.GG.Effect.ai.get
    without ai: App.GG.Effect.pass
    App.GG.Effect { 
      App.GG.Effect.ai.inc(reset_ai)
      let effs = App.GG.Effect.ai.run.get_action(ai@seen, seen)
      let effs = effs ++ App.GG.Effect.ai.run.get_action(ai@unseen, unseen)
      log(U64.show(ai@seen))
      log("LIST LENGTH: " | Nat.show(List.length!(effs)))
      let mod = (effect: App.GG.Effect<Unit>) effect
      App.GG.Effect.multiple<App.GG.Effect<Unit>>(mod, effs)
    }
  }

App.GG.Effect.ai.update_unseen(mod: U64 -> U64): App.GG.Effect<Unit>
  App.GG.Effect {
    get ai = App.GG.Effect.ai.get
    without ai: App.GG.Effect.pass
    let new_ai = (AI) AI@unseen <- mod(AI@unseen)
    App.GG.Effect.ai.update(new_ai)
  }

App.GG.Effect.ai.update_seen(mod: U64 -> U64): App.GG.Effect<Unit>
  App.GG.Effect {
    get ai = App.GG.Effect.ai.get
    without ai: App.GG.Effect.pass
    let new_ai = (AI) AI@seen <- mod(AI@seen)
    App.GG.Effect.ai.update(new_ai)
  }

App.GG.Effect.ai.run.aux(eff: App.GG.Effect<Unit>): App.GG.Effect<Unit>
  eff

App.GG.Effect.ai.run.get_action(AI: U64, effs: List<Pair<U64, App.GG.Effect<Unit>>>): List<App.GG.Effect<Unit>>
  case effs {
    nil: []
    cons:
      let num = effs.head@fst
      let eff = effs.head@snd
      let new_eff = 
        if AI =? num then
          [eff]
        else
          []
      new_eff ++ App.GG.Effect.ai.run.get_action(AI, effs.tail)
  }

