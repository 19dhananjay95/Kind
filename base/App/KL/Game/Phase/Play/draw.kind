 // TODO avoid using assets from Kaelin, use KL assets, adjust their positions

// BOARD DRAWING
// =============

// draw all the screen (round, seconds, canvas, list of skills)
App.KL.Game.Phase.Play.draw(img: VoxBox, local: App.KL.Game.State.Local, game: App.KL.Game): DOM
  open game
  <div style={ 
    "width": "100vw", 
    "height": "100vh", 
    "display": "flex", 
    "flex-direction": "column", 
    "justify-content": "center", 
    "align-items": "center",
    "position": "relative"
  }>
    <div style={"font-size": "24px", "font-family": "monospace"}>
      case game.moment {
        preparation: 
          "Turn "
          | Nat.show(U64.to_nat(game.turn))
          | ". Casting in "
          | Nat.show(U64.to_nat(game.moment.countdown))
          | " ticks..."
        execution: case game.moment.casts {
          nil:
            "End of turn "
            | Nat.show(U64.to_nat(game.turn))
            | "."
          cons: Maybe {
            let cast = game.moment.casts.head
            get skill = App.KL.Game.Cast.get_skill(cast, game)
            get hero = App.KL.Game.Cast.get_hero(cast, game)
            let text = hero@name | " used " | skill@name | "!"
            let text = text | if game.moment.success then "" else " But it failed."
            return text
          } <> "Invalid cast."
        }
      }
    </div>
    <div>{ 
      let width = Nat.show(I32.to_nat(App.KL.Constants.center_x * 2))
      let height = Nat.show(I32.to_nat(App.KL.Constants.center_y * 2))
      DOM.vbox(
        { "id": "game_screen",
          "width": width,
          "height": height,
          "scale": "2"},
        {},
        App.KL.Game.Phase.Play.draw.canvas(img, local, game)) 
    }</div>
  </div>

// CANVAS DRAWING
// ================

// draw canvas
App.KL.Game.Phase.Play.draw.canvas(
  img: VoxBox
  local: App.KL.Game.State.Local
  game: App.KL.Game
): VoxBox
  open game
  let hits = case game.moment {
    preparation: none
    execution: some(game.moment.hits)
  }
  let img = App.KL.Game.Phase.Play.draw.board(game@board, local@preview, hits, local@user, local@mouse, img) 
  let img = App.KL.Game.Phase.Play.draw.cursor(local@mouse, img)
  img

// draw canvas board
App.KL.Game.Phase.Play.draw.board(
  map: App.KL.Game.Board
  preview: App.KL.Game.Cast.Preview
  hits: Maybe<App.KL.Game.Indicators>
  user: String
  mouse: Pair<U32, U32>
  img: VoxBox
): VoxBox

  mouse_coord = Hexagonal.Axial.from_screen_xy(mouse, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
  indicators = App.KL.Game.Phase.Play.Draw.get_indicators(preview@skill, mouse_coord, user, map)
  map = Hexagonal.Axial.BBT.to_list!(map)
  for pos in map with img:
    {coord, tile} = pos
    img = App.KL.Game.Phase.Play.draw.tile.terrain(tile@terrain, preview@picks, indicators, hits, coord, mouse_coord, img)
    img = App.KL.Game.Phase.Play.draw.tile.creature(tile@creature, coord, img)
    img
  img


App.KL.Game.Phase.Play.Draw.get_indicators(
  skill: Maybe<App.KL.Game.Skill>, 
  target: Hexagonal.Axial,
  user: String,
  map: App.KL.Game.Board
): App.KL.Game.Indicators
  
  Maybe {
    get center     = App.KL.Game.Board.find_player_coord(user, map)
    get creature =  App.KL.Game.Board.Creature.get(center, map)
    get skill      = skill
    let indicator  = App.KL.Game.Indicator.blue
    let indicators = Hexagonal.Axial.BBT.new!
    let haste = App.KL.Game.Creature.get_total_haste(creature)
    //TODO: verify Player status in center to check how far the range should be shown.
    let coords     = Hexagonal.Axial.range(center, Nat.to_i32(U64.to_nat(skill@range)) + haste)
    // set range indicator
    for coord in coords with indicators:
      Hexagonal.Axial.BBT.set!(coord, indicator, indicators)
    let areas = App.KL.Game.Effect.indicators.get_indicators(center, skill, target, map)
    return Hexagonal.Axial.BBT.union!(indicators, areas)
  } <> Hexagonal.Axial.BBT.new<App.KL.Game.Indicator>
  

// draw mouse indicator
App.KL.Game.Phase.Play.draw.cursor(
  mouse: Pair<U32, U32>
  img: VoxBox
): VoxBox
  coord = Hexagonal.Axial.from_screen_xy(mouse, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
  {x,y} = App.KL.Game.Phase.Play.draw.centralize(coord)
  VoxBox.Draw.image(x, y, 0#32, App.Kaelin.Assets.tile.mouse_ui, img)

// draws tile terrain
App.KL.Game.Phase.Play.draw.tile.terrain(
  terrain: App.KL.Game.Terrain
  picks: App.KL.Game.Picks
  areas: App.KL.Game.Indicators
  hits: Maybe<App.KL.Game.Indicators>
  tile_coord: Hexagonal.Axial
  mouse_coord: Hexagonal.Axial
  img: VoxBox
): VoxBox
  indicator = Hexagonal.Axial.BBT.get!(tile_coord, hits <> areas) <> App.KL.Game.Indicator.background
  {i, j} = App.KL.Game.Phase.Play.draw.centralize(tile_coord)
  field = App.KL.Game.Field.get_by_id.default(terrain@field_id)
  field_drawing = field@draw(terrain, indicator)
  tile_drawing = VoxBox.Draw.image(i, j, 0#32, field_drawing, img)
  tile_drawing = App.KL.Game.Phase.Play.draw.letter(tile_coord, picks, tile_drawing)
  tile_drawing

// draws tile creature if any
App.KL.Game.Phase.Play.draw.tile.creature(
  creature: Maybe<App.KL.Game.Creature>,
  coord: Hexagonal.Axial,
  img: VoxBox
): VoxBox
  case creature {
    none: img
    some:
      {cx, cy} = Hexagonal.Axial.to_screen_xy(coord, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
      let cx = cx - (128::U32)
      let cy = cy - (128::U32)
      let hero = creature.value@hero
      let drawing = hero@draw(creature.value)
      //let aux = I32.to_u32(App.KL.Constants.hexagon_radius) //U32
      //let cy = cy - (aux * 2) //U32
      //let cx = cx - aux //U32
      let img = VoxBox.Draw.image(cx, cy, 0u, drawing, img)
      let img = if I32.gtn(creature.value@hp, 0)
        then App.KL.Game.Phase.Play.Bar.show_hp(cx + 128 - 16, cy + 128 - 28, creature.value, img)
        else img
      img
  }

// AUX FUNCTIONS
// =============

App.KL.Game.Phase.Play.draw.letter(
  tile_coord: Hexagonal.Axial
  picks: App.KL.Game.Picks
  img: VoxBox
): VoxBox
  case Hexagonal.Axial.BBT.get!(tile_coord, picks) as got {
    none: img
    some: 
      screen_coord = Hexagonal.Axial.to_screen_xy(tile_coord, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
      {cx, cy} = App.KL.Game.Phase.Play.draw.centralize_letter(screen_coord)
      VoxBox.Draw.text(Char.to_string(got.value), PixelFont.black, Pos32.new(cx,cy,0u), img)
  }

App.KL.Game.Phase.Play.draw.centralize_letter(screen_coord: Pair<U32, U32>): Pair<U32, U32>
  { screen_coord@fst - 2, screen_coord@snd - 6 }
  
// Centralizes an image in the hexagon 
// TODO: won't be used after we start using assets from KL only
App.KL.Game.Phase.Play.draw.centralize(
  coord: Hexagonal.Axial
): Pair(U32, U32)
  let {i, j} = Hexagonal.Axial.to_screen_xy(coord, App.KL.Constants.hexagon_radius, App.KL.Constants.center_x, App.KL.Constants.center_y)
  let aux = I32.to_u32(App.KL.Constants.hexagon_radius)
  let i = i - aux
  let j = j - aux
  {i, j}

App.KL.Game.Phase.Play.draw.hp(
  cx: U32
  cy: U32
  creature: App.KL.Game.Creature
  img: VoxBox
): VoxBox
  let hp = I32.to_int(creature@hp)
  let hp = Nat.show(Int.to_nat(hp))
  VoxBox.Draw.text(hp, PixelFont.small_black, Pos32.new(cx,cy,0), img)


App.KL.Game.Phase.Play.draw.shield(
  cx: U32
  cy: U32
  creature: App.KL.Game.Creature
  img: VoxBox
): VoxBox
  let shield = App.KL.Game.Board.Creature.total_shield(creature)
  let shield = I32.to_int(shield)
  let shield = Nat.show(Int.to_nat(shield))
  VoxBox.Draw.text(shield, PixelFont.small_black, Pos32.new(cx, cy, 0), img)
