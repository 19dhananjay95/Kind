type App.GG.Creature { 
  new(
    category: App.GG.Monster
    team: App.GG.Team
    animation: Pair<App.GG.Animation, U64>
    actions: App.GG.Actions
    status: List<App.GG.Creature.Status>
    hp: I32
    id: Nat
  )
}


type App.GG.Creature.Dna {
  new(
    alteration: String //TODO
    attributes: App.GG.Creature.Attributes
    body: App.GG.Body
  )
}

type App.GG.Creature.Attributes {
  new(
    hp:I32
    energy:I32
    damage:I32
    corruption: I32
  )
}


App.GG.Creature.Attributes.add(
  a: App.GG.Creature.Attributes
  b: App.GG.Creature.Attributes
): App.GG.Creature.Attributes

  let hp = a@hp + b@hp
  let energy = a@energy + b@energy
  let damage = a@damage + b@damage
  let corruption = a@corruption + b@corruption
  App.GG.Creature.Attributes.new(hp, energy, damage, corruption)

App.GG.Creature.Attributes.base: App.GG.Creature.Attributes
  App.GG.Creature.Attributes.new(
    25 // hp
    25 // energy
    25 // damage
    25 // corruption
  )

//===========================================================
//Creature Management

App.GG.Creature.modify_at(
  mod: App.GG.Creature -> App.GG.Creature
  pos: App.GG.Coord
  grid: App.GG.Grid
): App.GG.Grid
  
  let result = Maybe { 
    get creature = App.GG.Creature.get(pos, grid)
    let mod = App.GG.Tile.update_creature(mod)
    let new_grid = App.GG.Grid.update(pos, mod, grid)
    return new_grid
  }
  result <> grid


App.GG.Creature.get(
  place: App.GG.Coord
  grid: App.GG.Grid
): Maybe<App.GG.Creature>

  let tile = App.GG.Grid.get(place, grid)
  case tile { 
    none:
      none
    some:
      tile.value@creature
  }


//===========================================================
//Status Management

type App.GG.Creature.Status {
  invulnerable(duration: U64)
  poison(duration: U64, damage: I32)
  root(duration: U64)
  stun
}

App.GG.Creature.status_update(
  creature: App.GG.Creature
): App.GG.Creature
  
  let status_update = App.GG.Creature.status_update_aux(creature@status)
  creature@status <- status_update

App.GG.Creature.status_update_aux(
  status: List<App.GG.Creature.Status>
):List<App.GG.Creature.Status>

  case status { 
    nil:
      []
    cons:
      let head = case status.head { 
        invulnerable: App.GG.Creature.Status.invulnerable(status.head.duration - 1)
        poison: App.GG.Creature.Status.poison(status.head.duration - 1, status.head.damage)
        root: App.GG.Creature.Status.root(status.head.duration - 1)
        stun: App.GG.Creature.Status.stun

      }
      let tail = App.GG.Creature.status_update_aux(status.tail)
      case head { 
        invulnerable: if U64.gtn(head.duration, 0) then head & tail else tail
        poison: if U64.gtn(head.duration, 0) then head & tail else tail
        root: if U64.gtn(head.duration, 0) then head & tail else tail
        stun: head & tail
      }
  }


App.GG.Creature.add_status(
  status:  App.GG.Creature.Status
  creature: App.GG.Creature
): App.GG.Creature

  let invul = App.GG.Creature.status_check_invulnerable(creature)
  if invul then 
    case status { 
      invulnerable: App.GG.Creature.status_add_invulnerable(creature, status.duration)
    }default creature
  else
    case status {
      invulnerable: App.GG.Creature.status_add_invulnerable(creature, status.duration)
      poison: App.GG.Creature.status_add_poison(creature, status.duration, status.damage)
      root:App.GG.Creature.status_add_root(creature, status.duration)
      stun: App.GG.Creature.status_add_stun(creature)
    }

App.GG.Creature.status_add_invulnerable(
  creature: App.GG.Creature
  duration: U64
): App.GG.Creature
  
  let new_status = App.GG.Creature.status_add_invulnerable_aux(duration, creature@status)
  creature@status <- new_status

App.GG.Creature.status_add_invulnerable_aux(
  duration: U64
  status: List<App.GG.Creature.Status>
): List<App.GG.Creature.Status>

  let new_invul = App.GG.Creature.Status.invulnerable(duration)
  case status {
    nil: new_invul & status
    cons:
      case status.head { 
        invulnerable:
          if U64.gtn(status.head.duration, duration) then
            status
          else
            new_invul & status.tail
      }default status.head & App.GG.Creature.status_add_invulnerable_aux(duration, status.tail)
  }


App.GG.Creature.status_check_invulnerable(
  creature: App.GG.Creature
): Bool
  let status = creature@status
  case status { 
    invulnerable: true
  }default false


App.GG.Creature.status_add_poison(
  creature: App.GG.Creature
  duration: U64
  damage: I32
): App.GG.Creature
  
  let new_status = App.GG.Creature.status_add_poison_aux(duration, damage, creature@status)
  creature@status <- new_status


App.GG.Creature.status_add_poison_aux(
  duration: U64
  damage: I32
  status: List<App.GG.Creature.Status>
): List<App.GG.Creature.Status>

  let new_poison = App.GG.Creature.Status.poison(duration, damage)
  case status {
    nil: new_poison & status
    cons:
      case status.head { 
        poison:
          if U64.gtn(status.head.duration, duration) then
            status
          else
            new_poison & status.tail
      }default status.head & App.GG.Creature.status_add_poison_aux(duration, damage, status.tail)
  }


App.GG.Creature.status_add_root(
  creature: App.GG.Creature
  duration: U64
): App.GG.Creature
  
  let new_status = App.GG.Creature.status_add_root_aux(duration, creature@status)
  creature@status <- new_status


App.GG.Creature.status_add_root_aux(
  duration: U64
  status: List<App.GG.Creature.Status>
): List<App.GG.Creature.Status>

  let new_root = App.GG.Creature.Status.root(duration)
  case status {
    nil: new_root & status
    cons:
      case status.head { 
        root:
          if U64.gtn(status.head.duration, duration) then
            status
          else
            new_root & status.tail
      }default status.head & App.GG.Creature.status_add_root_aux(duration, status.tail)
  }

  
App.GG.Creature.status_add_stun(
  creature: App.GG.Creature
): App.GG.Creature
  
  let new_status = App.GG.Creature.Status.stun & creature@status
  creature@status <- new_status

App.GG.Creature.status_eql(a: App.GG.Creature.Status, b: App.GG.Creature.Status): Bool
  case a b {
    invulnerable invulnerable: true
    poison poison: true
    root root: true
    stun root: true
  }default false

App.GG.Creature.status_different(a: App.GG.Creature.Status, b: App.GG.Creature.Status): Bool
  not(App.GG.Creature.status_eql(a, b))

App.GG.Creature.del_status(status: App.GG.Creature.Status, creature: App.GG.Creature): App.GG.Creature
  let new_status = List.filter!(App.GG.Creature.status_different(status), creature@status)
  creature@status <- new_status


App.GG.Creature.sub_folder(quantity: Nat, creature: App.GG.Creature): App.GG.Creature
  case creature@category as monster {
    minion: creature
    slime:
      creature@category <- App.GG.Monster.slime(monster.data, monster.hand, List.drop!(quantity, monster.folder), monster.energy)
  }

App.GG.Creature.shuffle_folder(seed: Nat, creature: App.GG.Creature): App.GG.Creature
  case creature@category as monster {
    minion: creature
    slime:
      let new_folder = App.GG.Chips.shuffle(seed, monster.folder)
      creature@category <- App.GG.Monster.slime(monster.data, monster.hand, new_folder, monster.energy)
  }

App.GG.Creature.add_chip(chip: App.GG.Chip, creature: App.GG.Creature): App.GG.Creature
  case creature@category as monster {
    minion: creature
    slime:
      let category = App.GG.Monster.slime(monster.data, chip & monster.hand, monster.folder, monster.energy)
      creature@category <- category
  }

App.GG.Creature.delete(coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  let tile = App.GG.Grid.get(coord, grid)
  without tile: grid
  let new_tile = tile@creature <- none
  App.GG.Grid.set(coord, new_tile, grid)

App.GG.Creature.create_slime(slime: App.GG.Slime, grid: App.GG.Grid): App.GG.Creature
  let team = App.GG.Team.blue
  let animation = {App.GG.Animation.idle, 0#64}
  let actions = App.GG.Actions.new(none, none, false)
  let status = [] :: List<App.GG.Creature.Status>
  let id = App.GG.Grid.next_id(grid)
  let dna = slime@dna
  let body = dna@body
  let data = slime
  let hand = []
  let folder = App.GG.Body.to_folder(body)
  let hp = dna@attributes@hp * 10
  let energy = 0 :: I32
  let monster = App.GG.Monster.slime(data, hand, folder, energy)
  App.GG.Creature.new(monster, team, animation, actions, status, hp, id)

App.GG.Creature.create_minion(minion: App.GG.Minion, grid: App.GG.Grid): App.GG.Creature
  let team = App.GG.Team.red
  let animation = {App.GG.Animation.idle, 0#64}
  let actions = App.GG.Actions.new(none, none, false)
  let status = [] :: List<App.GG.Creature.Status>
  let id = App.GG.Grid.next_id(grid)
  let AI = App.GG.AI.new(0, 0)
  let hp = minion@hp
  let monster = App.GG.Monster.minion(minion, AI)
  App.GG.Creature.new(monster, team, animation, actions, status, hp, id)

App.GG.Creature.place(creature: App.GG.Creature, coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  let f = 
    (tile: App.GG.Tile)
    tile@creature <- some(creature)
  App.GG.Grid.update(coord, f, grid)

App.GG.Creature.dmg_with_attribute(creature: App.GG.Creature, dmg: I32): I32
  case creature@category as monster {
    minion: dmg
    slime:
      let slime = monster.data
      let dna = slime@dna
      let attributes = dna@attributes
      let destruction = attributes@damage
      (dmg * destruction) / 25
  }
