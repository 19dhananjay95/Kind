App.KL.Game.Phase.Play.tick(tick: U64, game: App.KL.Game): App.KL.Game
  open game
  case game.moment {
    // Preparation phase
    preparation:
      // Countdown positive: decrease countdown
      if U64.gtn(game.moment.countdown, 0) then
        let game = game@moment <- App.KL.Game.Moment.preparation(game.moment.countdown - 1)
        game
      // Countdown zero: go to execution phase
      else
        let game = game@moment <- App.KL.Game.Moment.execution(App.KL.Game.Cast.sort(game), 0)
        let game = game@casts <- []
        game
    // Execution phase
    execution: case game.moment.casts {
      cons: Maybe {
        let frame = game.moment.frame
        let cast = game.moment.casts.head
        get skill = App.KL.Game.Cast.get_skill(cast, game)
        // Animating a cast: apply effect, increase frame
        if U64.ltn(frame, skill@frames) then Maybe {
          let game = if U64.eql(frame,0) then App.KL.Game.Cast.apply(cast, game) else game
          let game = game@moment <- App.KL.Game.Moment.execution(game.moment.casts, frame + 1)
          return game
        // Ending a cast: go to next
        } else Maybe {
          let game = game@moment <- App.KL.Game.Moment.execution(game.moment.casts.tail, 0)
          return game
        }
      } <> game@moment <- App.KL.Game.Moment.execution(game.moment.casts.tail, 0) // Ignore invalid cast
      // No more casts left
      nil:
        let frame = game.moment.frame
        // Between-turn delay
        if U64.ltn(frame, App.KL.Constants.between_turn_delay) then
          game@moment <- App.KL.Game.Moment.execution(game.moment.casts, frame + 1)
        // Go to next turn
        else
          let game = game@moment <- App.KL.Game.Moment.preparation(App.KL.Constants.round_time)
          let game = game@turn <- game@turn + 1
          game
    }
  }
  //let game = game@tick <- game@tick + 1
  //if U64.eql(U64.mod(game@tick, App.KL.Constants.round_time), 0) then 
    //let casts = App.KL.Game.Cast.sort(game)
    //for cast in casts with game:
      //App.KL.Game.Cast.apply(cast, game)
    //game@casts <- []
  //else
    //game
