Crypto.TinyKeccak(
  rate: U32
  capacity: U32
  input: Buffer8
  inputByteLen: U32
  delimitedSuffix: U8
): Buffer8
  let state = Buffer8.alloc(8)
  let sizeof_state = 200
  let rateInBytes = rate/8
  let state = Crypto.TinyKeccak.absorb(inputByteLen, rateInBytes, input, 0, state, delimitedSuffix)
  state

Crypto.TinyKeccak.absorb(
  inputByteLen: U32
  rateInBytes: U32
  input: Buffer8
  input_idx: U32
  state: Buffer8
  delimitedSuffix: U8
): Buffer8
  if inputByteLen =? 0 then
    let blockSize = inputByteLen % rateInBytes
    let v = U8.xor(
      Buffer8.get(blockSize, state)
      delimitedSuffix)
    Buffer8.set(blockSize, v, state)
  else
    let blockSize = U32.min(inputByteLen, rateInBytes)
    for i: U32 from 0 to blockSize with state:
      let v = U8.xor(
        Buffer8.get(i, state),
        Buffer8.get(input_idx + i, input))
      Buffer8.set(i, v, state)
    let state =
      if blockSize =? rateInBytes then
        Crypto.TinyKeccak.permute(state)
      else
        state
    Crypto.TinyKeccak.absorb(
      inputByteLen - blockSize,
      rateInBytes,
      input,
      input_idx + blockSize,
      state,
      delimitedSuffix)

Crypto.TinyKeccak.squeeze(
  state: Buffer8
  output: Buffer8
  output_idx: U32
  outputByteLen: U32
  rateInBytes: U32
): Buffer8
  if outputByteLen =? 0 then
    output
  else
    let blockSize = U32.min(outputByteLen, rateInBytes)
    for i: U32 from output_idx to output_idx + blockSize with output:
      Buffer8.set(i,
        Buffer8.get(i, state)
        output)
    let state = Crypto.TinyKeccak.permute(state)
    Crypto.TinyKeccak.squeeze(state, output, output_idx + blockSize, outputByteLen - blockSize, rateInBytes)

Crypto.TinyKeccak.permute(
  state: Buffer8
): Buffer8
  let state = Keccak.TinyKeccak.theta(state)
  let state = Keccak.TinyKeccak.rho(state)
  let state = Keccak.TinyKeccak.pi(state)
  let state = Keccak.TinyKeccak.chi(state)
  let state = Keccak.TinyKeccak.iota(state)
  state

// #define readLane(x, y) load64((uint8_t*)state+sizeof(tKeccakLane)*i(x, y))
// typedef uint64_t tKeccakLane;
Crypto.TinyKeccak.load64(x: Buffer8, x_idx: U32, out: Buffer8, out_idx: U32): Buffer8
  for i: U32 from 0 to 8 with out:
    let v = Buffer8.get(7 - i + x_idx, x)
    Buffer8.set(out_idx + i, v, out)
  out

Crypto.TinyKeccak.readLane(
  state: Buffer8
  x: U32
  y: U32
  out: Buffer8
  out_idx: U32
): Buffer8
  Crypto.TinyKeccak.load64(state, 8*(x + (5*y)), out, out_idx)

Keccak.TinyKeccak.theta(state: Buffer8): Buffer8
  let C = [] :: List<Buffer8>
  for x: U32 from 0 to 5 with C:
    let col = Buffer8.alloc(3)
    let temp = Buffer8.alloc(3)
    for i: U32 from 0 to 5 with col:
      let temp = Crypto.TinyKeccak.readLane(state, x, i, temp, 0)
      for j: U32 from 0 to 8 with col:
        let v = U8.xor(
          Buffer8.get(j, col)
          Buffer8.get(j, temp))
        Buffer8.set(j, v, col)
      col
    (col & C)
  for x from 0 to 5 with state:
    let D = Buffer8.alloc(3)
    let col1 = C[(x+4)%5] <> Buffer8.alloc(3)
    let col2 = C[(x+1)%5] <> Buffer8.alloc(3)
    for i: U32 from 0 to 8 with D:
      let rol64_1_byte = U8.or(
        U8.shr(Buffer8.get((i+1)%8, col2), 7)
        U8.shl(Buffer8.get(i, col2), 1))
      let v = U8.xor(
        Buffer8.get(i, col1),
        rol64_1_byte)
      Buffer8.set(i, v, D)
    state
  state

Keccak.TinyKeccak.rho(state: Buffer8): Buffer8
  state

Keccak.TinyKeccak.pi(state: Buffer8): Buffer8
  state

Keccak.TinyKeccak.chi(state: Buffer8): Buffer8
  state

Keccak.TinyKeccak.iota(state: Buffer8): Buffer8
  state
