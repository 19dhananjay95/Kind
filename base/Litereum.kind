// Litereum: a minimal decentralized computer

Litereum.Private: Type
  Vector<U256, 32>

Litereum.Public: Type
  Vector<U256, 32>

Litereum.Address: Type
  U256

Litereum.Signature: Type
  Vector<U256, 32>

Litereum.Summary: Type
  Vector<U8, 32>

Litereum.Hash: Type
  U256

Litereum.Body: Type
  Vector<U256,8>

type Litereum.Post {
  new(
    body: Litereum.Body      //  8 words =  256 bytes
    sign: Litereum.Signature // 32 words = 1024 bytes
    info: U256               //  1 word  =   32 bytes
    prev: U256               //  1 word  =   32 bytes
  )                          // 42 words = 1344 bytes
} deriving (serializer, deserializer)

type Litereum.Chain {
  new(
    post: Map<Litereum.Post>       // PostHash ~> post
    score: Map<Litereum.Hash>      // PostHash ~> accumulated_score
    nexts: Map<List<Litereum.Hash>> // PostHash ~> [next_post_hash]
    tip: Pair<U256,Litereum.Hash>  // top-most post
  )
}

type Litereum.NetAddress {
  ipv4(ip0: U8, ip1: U8, ip2: U8, ip3: U8, port: U16)
} deriving (serializer, deserializer)
  

type Litereum.Peer {
  new(
    address: Litereum.NetAddress
  )
}

type Litereum.Message {
  ping
  request_tip
  request_by_hash(
    hash: Litereum.Post
  )
  gossip(
    post: Litereum.Post
    peers: List<Litereum.Peer>
  )
}

type Litereum.Node {
  new(
    port: Nat
    peers: List<Litereum.Peer>
    chain: Litereum.Chain
  )
}

Litereum.Body.deserializer: Deserializer<Litereum.Body>
  Vector.deserializer!(8,U256.deserializer)

Litereum.Body.serializer: Serializer<Litereum.Body>
  Vector.serializer!(8,U256.serializer)

Litereum.Signature.deserializer: Deserializer<Litereum.Signature>
  Vector.deserializer!(32,U256.deserializer)

Litereum.Signature.serializer: Serializer<Litereum.Signature>
  Vector.serializer!(32,U256.serializer)

// Takes the Keccak hash of a list of words
Litereum.Hash.from_words(words: List<U256>): Litereum.Hash
  Crypto.Keccak.hash.words(words)

// Returns the PostHash
Litereum.Hash.from_post(post: Litereum.Post): Litereum.Hash
  use post = post
  let words = []
  let words = words ++ Vector.to_list!(8, post.body)
  let words = words ++ Vector.to_list!(32, post.sign)
  let words = words ++ [post.info, post.prev]
  Litereum.Hash.from_words(words)

// Hashes a buffer into a 1024-byte signable string
Litereum.Summary.from_bytes(len_bytes: Pair<U32,Buffer8>): Litereum.Summary
  let vals = Buffer8.to_list(Crypto.Keccak.hash.bytes(len_bytes))
  let csum = 7650 :: U32
  let csum = for i from 2 to List.length!(vals): csum - U8.to_u32(vals[i] <> 0)
  let vals = vals[0] <- U32.to_u8(U32.div(csum, 256))
  let vals = vals[1] <- U32.to_u8(U32.mod(csum, 256))
  let vals = Vector.from_list.length!(32, 0, vals)
  vals

// Converts a list of words to a signable
Litereum.Summary.from_words(words: List<U256>): Litereum.Summary
  Litereum.Summary.from_bytes(Buffer8.from_list.256(words))

// Converts a UTF-8 string to a signable
Litereum.Summary.from_utf8(str: String): Litereum.Summary
  Litereum.Summary.from_bytes(Buffer8.from_hex(String.to_hex(str)))

// Converts a seed to a private key
Litereum.Private.from_seed(seed: U256): Litereum.Private
  Litereum.Private.from_seed.go(32, seed)

Litereum.Private.from_seed.go(len: Nat, seed: U256): Vector<U256,len>
  case len {
    zero:
      Vector.nil!
    succ:
      let head = Litereum.Hash.from_words([U256.add(seed, Nat.to_u256(len))])
      let tail = Litereum.Private.from_seed.go(len.pred, seed)
      Vector.cons<U256,len.pred>(head, tail)
  }!

// Coverts a private key to an address
Litereum.Public.from_private(pvt: Litereum.Private): Litereum.Private
  Litereum.Public.from_private.go(32, pvt)

Litereum.Public.from_private.go(len: Nat, pvt: Vector<U256,len>): Vector<U256,len>
  case len with pvt {
    zero: Vector.nil!
    succ: case pvt {
      cons:
        let hash = pvt.head
        let hash = for i from 0 to 256:
          Litereum.Hash.from_words([hash])
        Vector.cons<U256,len.pred>(hash, Litereum.Public.from_private.go(len.pred, pvt.tail))
    }
  }!

// Converts a public key to an address
Litereum.Address.from_public(pub: Litereum.Public): Litereum.Address
  let vals = Buffer8.from_list.256(Vector.to_list!(32, pub))
  let addr = Buffer8.to_u256(Crypto.Keccak.hash.bytes(vals)@snd)
  addr

// Signs a post
Litereum.Signature.sign_post(post: Litereum.Post, pvt: Litereum.Private): Litereum.Signature
  Litereum.Signature.sign(Litereum.Summary.from_words(Vector.to_list!(8,post@body)), pvt)
  
// Signs a signable
Litereum.Signature.sign(msg: Litereum.Summary, pvt: Litereum.Private): Litereum.Signature
  Litereum.Signature.sign.go(32, msg, pvt)

Litereum.Signature.sign.go(len: Nat, msg: Vector<U8,len>, pvt: Vector<U256,len>): Vector<U256,len>
  case len with msg pvt {
    zero: case msg pvt {
      nil nil: Vector.nil!
    }
    succ: case msg pvt {
      cons cons:
        let hash = pvt.head
        let hash = for i from 0 to 256 - U8.to_nat(msg.head):
          Litereum.Hash.from_words([hash])
        Vector.cons<U256,len.pred>(hash, Litereum.Signature.sign.go(len.pred, msg.tail, pvt.tail))
    }
  }!

// Verifies if a signature is correct
Litereum.Signature.verify(msg: Litereum.Summary, addr: Litereum.Address, sig: Litereum.Signature): Bool
  let checksums = Litereum.Signature.checksum(msg)
  let sign_addr = Litereum.Signature.recover(msg, sig)
  checksums && U256.eql(addr, sign_addr)

// Checks if the signable checksum is correct
Litereum.Signature.checksum(msg: Litereum.Summary): Bool
  Litereum.Signature.checksum.go(32, msg)

Litereum.Signature.checksum.go(len: Nat, msg: Vector<U8,len>): Bool
  let vals = Vector.to_list<U8>(len, msg)
  let csum = 7650 :: U32
  let csum = for i from 2 to List.length!(vals):
    csum - U8.to_u32(vals[i] <> 0)
  let cs_0 = U8.to_u32(vals[0] <> 0)
  let cs_1 = U8.to_u32(vals[1] <> 0)
  //log("!!! csum is " | U32.show(csum))
  //log("!!! cs_0 is " | U32.show(cs_0))
  //log("!!! cs_1 is " | U32.show(cs_1))
  U32.eql(csum, U32.add(U32.mul(cs_0, 256), cs_1))

// Returns the public key that signed a message
Litereum.Signature.recover(msg: Litereum.Summary, sig: Litereum.Signature): Litereum.Address
  Litereum.Address.from_public(Litereum.Signature.recover.go(32, msg, sig))

Litereum.Signature.recover.go(len: Nat, msg: Vector<U8,len>, sig: Vector<U256,len>): Vector<U256,len>
  case len with msg sig {
    zero: Vector.nil!
    succ: case msg sig {
      cons cons cons:
        let hash = sig.head
        let hash = for i from 0 to U8.to_nat(msg.head): Litereum.Hash.from_words([hash])
        Vector.cons<U256,len.pred>(hash, Litereum.Signature.recover.go(len.pred, msg.tail, sig.tail))
    }
  }!

// Estimates how many attempts were needed to make this hash
Litereum.Hash.score(hash: U256): U256
  Nat.to_u256(Nat.pow(2,256) / U256.to_nat(hash))

// Increases the Post nonce until it is above target_score
Litereum.Post.mine(post: Litereum.Post, target_score: U256, attempts: U256): Litereum.Post
  let post_score = Litereum.Hash.score(Litereum.Hash.from_post(post))
  if U256.eql(attempts,0) || U256.gte(post_score, target_score) then
    post
  else
    Litereum.Post.mine(post@info <- post@info + 1, target_score, attempts - 1)

Litereum.Chain.add_post(post: Litereum.Post, chain: Litereum.Chain): Litereum.Chain
  open post
  open chain
  open chain.tip
  let prev_hash   = post.prev
  let post_hash   = Litereum.Hash.from_post(post)
  let prev        = chain.post{U256.show(prev_hash)} abort chain
  let prev_score  = chain.score{U256.show(prev_hash)} abort chain
  let post_score  = U256.add(prev_score, Litereum.Hash.score(post_hash))
  let prev_nexts  = chain.nexts{U256.show(prev_hash)} <> []
  let chain.post  = chain.post{U256.show(post_hash)} <- post
  let chain.score = chain.score{U256.show(post_hash)} <- post_score
  let chain.nexts = chain.nexts{U256.show(prev_hash)} <- post_hash & prev_nexts
  let chain.tip   = if post_score >? chain.tip.fst then {post_score,post_hash} else chain.tip
  Litereum.Chain.new(chain.post, chain.score, chain.nexts, chain.tip)

Litereum.Chain.genesis: Litereum.Chain
  let chain.post = {U256.show(0): Litereum.Post.new(Vector.create!(8,()0),Vector.create!(32,()0),0,0)}
  let chain.score = {U256.show(0): 0#256}
  let chain.nexts = {U256.show(0): []}
  let chain.tip = {0#256, 0#256}
  Litereum.Chain.new(chain.post, chain.score, chain.nexts, chain.tip)

Litereum.Chain.main_fork(chain: Litereum.Chain): List<Litereum.Post>
  open chain
  open chain.tip
  case chain.post{U256.show(chain.tip.snd)} as tip_post {
    none: []
    some: Litereum.Chain.main_fork.go(tip_post.value, chain.post, [])
  }

Litereum.Chain.main_fork.go(
  post: Litereum.Post
  posts: Map<Litereum.Post>
  result: List<Litereum.Post>
): List<Litereum.Post>
  open post
  let result = List.cons!(post, result)
  if U256.eql(post.prev, 0) then
    result
  else case posts{U256.show(post.prev)} as prev {
    none: result
    some: Litereum.Chain.main_fork.go(prev.value, posts, result)
  }

Litereum.NetAddress.show_ip(addr: Litereum.NetAddress): String
  open addr
  let ip0 = Nat.show(U8.to_nat(addr.ip0))
  let ip1 = Nat.show(U8.to_nat(addr.ip1))
  let ip2 = Nat.show(U8.to_nat(addr.ip2))
  let ip3 = Nat.show(U8.to_nat(addr.ip3))
  ip0 | "." | ip1 | "." | ip2 | "." | ip3

Litereum.NetAddress.show_port(addr: Litereum.NetAddress): String
  open addr
  Nat.show(U16.to_nat(addr.port))
  
Litereum.example.signature: IO<Unit>
  IO {
    let pvt = Litereum.Private.from_seed(1234)
    let pub = Litereum.Public.from_private(pvt)
    let adr = Litereum.Address.from_public(pub)
    let msg = Litereum.Summary.from_utf8("cats cats cats yay")
    let sig = Litereum.Signature.sign(msg, pvt)
    let chk = Litereum.Signature.verify(msg, adr, sig)
    IO.print(Bool.show(chk))
  }

Litereum.example.mining: IO<Unit>
  IO {
    let pvt  = Litereum.Private.from_seed(1234)
    let pub  = Litereum.Public.from_private(pvt)
    let addr = Litereum.Address.from_public(pub)
    let body = Vector.create!(8, (x) Nat.to_u256(x))
    let sign = Litereum.Signature.sign(Litereum.Summary.from_words(Vector.to_list!(8,body)), pvt)
    let post = Litereum.Post.new(body, sign, 0, 0)
    let post = Litereum.Post.mine(post, 2000, 1000000)
    let hash = Litereum.Hash.from_post(post)
    IO.print(U256.show(Litereum.Hash.score(hash)))
  }

Litereum.main(port: Nat): IO<Unit>
  let peers = [
    Litereum.Peer.new(Litereum.NetAddress.ipv4(127,0,0,1,42000))
    Litereum.Peer.new(Litereum.NetAddress.ipv4(127,0,0,1,42001))
    Litereum.Peer.new(Litereum.NetAddress.ipv4(127,0,0,1,42002))
    Litereum.Peer.new(Litereum.NetAddress.ipv4(127,0,0,1,42003))
  ]
  let node = Litereum.Node.new(port, peers, Litereum.Chain.genesis)
  Litereum.main.loop(node)

Litereum.main.loop(node: Litereum.Node): IO<Unit>
  open node
  IO {
    
    // Broadcast gossips
    Litereum.broadcast(node, String.hex.encode("Hi, I'm " | Nat.show(node.port)))

    // Get inbox
    get inbox = IO.recv_udp(node.port)
    Litereum.main.print_inbox(inbox)

    // Loop
    IO.sleep(1000)
    Litereum.main.loop(node)
    return unit
  }

Litereum.broadcast(node: Litereum.Node, data: String): IO<Unit>
  open node
  Litereum.broadcast.go(node.port, node.peers, data)

Litereum.broadcast.go(
  port: Nat
  peers: List<Litereum.Peer>
  msg: String
): IO<Unit>
  case peers {
    nil: IO.pass
    cons:
      open peers.head
      open peers.head.address
      IO {
        //IO.print("send to " | Nat.show(U16.to_nat(peers.head.address.port)))
        IO.send_udp(port, Litereum.NetAddress.show_ip(peers.head.address), U16.to_nat(peers.head.address.port), msg)
        Litereum.broadcast.go(port, peers.tail, msg)
      }
  }

Litereum.main.print_inbox(inbox: List<IO.recv_udp.Message>): IO<Unit>
  case inbox {
    nil: IO.pass
    cons: IO {
      use msge = inbox.head
      use from = msge.from
      IO.print("<" | from.ip | ":" | Nat.show(from.port) | "> " | String.hex.decode(msge.data))
      Litereum.main.print_inbox(inbox.tail)
    }
  }
