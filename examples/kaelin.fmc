// # Kaelin 
// 
// A simple MOBA-like boardgame and a showcase for Formality-Core
// 
// It aims to be blockchain-compatible. That means real-time Kaelin matches can
// take place inside smart-contract platforms like Ethereum or Tezos. That's
// because turns have 10-20 seconds, and moves are made in a commit-reveal
// scheme, allowing the game state to be computed by players directly, without
// a central server (aka state-channels). In the case of a dispute (such as a
// player stopping to respond), the blockchain can be consulted and resolve the
// conflict in an acceptable time (about 1 minute).
// 
// Kaelin aims to preserve many of the fun characteristics of a MOBA such as
// map control, micro and macro decisions, team-work, and essentially answer
// the question: how do you dodge a skillshot in a turn-based boardgame?
// 
// ## Heroes
// 
// Name    | Role       | Description    | MOV | HP  | References & Inspiration
// ------- | ---------- | -------------- | --- | --- | -------------------------------------------------
// Tophoro | Tank       | Terrain Bender |   3 | 120 | Toph (Avatar TLA), Totoro (Studio Ghibli)
// Gonk    | Tank       | Warrior        |   3 |  90 | Gon (Hunter X Hunter), Goku (Gradon Ball Z)
// ?       | Tank       | ?              |   ? |   ? | ?
// ?       | Tank       | ?              |   ? |   ? | ?
// ?       | Tank       | ?              |   ? |   ? | ?
// ?       | Tank       | ?              |   ? |   ? | ?
// Erkos   | Ranged     | Fire Mage      |   4 |  40 | Erk (Fire Emblem), Harry Potter (Harry Potter)
// Croni   | Ranged     | Dark Mage      |   4 |  40 | Chromie (Blizzard), Raven (Teen Titans)
// Snarch  | Ranged     | Archer         |   4 |  60 | Zk-Snarks (crypto)
// ?       | Ranged     | ?              |   ? |   ? | ?
// ?       | Ranged     | ?              |   ? |   ? | ?
// ?       | Ranged     | ?              |   ? |   ? | ?
// Sirpix  | Melee      | Thief          |   4 |  60 | Dev
// Kenlua  | Melee      | Swordsman      |   4 |  60 | Killua (Hunter X Hunter), Kenshin (Rurouni Kenshin)
// Flina   | Melee      | Pegasus Knight |   6 |  60 | Florina (Fire Emblem), Link (The Legend of Zelda)
// ?       | Melee      | ?              |   ? |   ? | ?
// ?       | Melee      | ?              |   ? |   ? | ?
// ?       | Melee      | ?              |   ? |   ? | ?
// Stanci  | Support    | Healer         |   4 |  40 | Dev
// ?       | Support    | ?              |   ? |   ? | ?
// ?       | Support    | ?              |   ? |   ? | ?
// ?       | Support    | ?              |   ? |   ? | ?
// ?       | Support    | ?              |   ? |   ? | ?
// ?       | Support    | ?              |   ? |   ? | ?
// Zagatur | Influencer | Summoner       |   0 |  10 | Zagara, Abathur (Blizzard)
// Agdris  | Influencer | Silencer       |   1 |  20 | Agda, Idris (programming language)
// Mewru   | Influencer | Psychic        |   0 |  20 | Mewtwo (Pok√©mon), Meruem (Hunter X Hunter)
// ?       | Influencer | ?              |   ? |   ? | ?
// ?       | ?          | ?              |   ? |   ? | ?
// ?       | ?          | ?              |   ? |   ? | ?
// ?       | ?          | ?              |   ? |   ? | ?
// ?       | ?          | ?              |   ? |   ? | ?
//
// ## Moves
// 
// - Tophoro
//   - Earth Pull : pulls enemies in a 1-3-5 (wave) ahead.
//   - Earth Wall : creates up to 3 earth walls in up to 3 range.
//   - Earth Lock : selects an enemy in up to 2 range. Stuns him/her. Can't use on next turn.
//   - Earth Root : self-roots for 3 turns, gaining massive shield and heal.
// 
// - Gonk
//   - Endure  : can't die on this turn. Can't use on next turn.
//   - Breath  : heals 6 HP. Can't move on this turn. 
//   - Empathy : loses N HP. Grants N armor to allies in a 5x5 (cirlce) around.
//   - Shatter : select an enemy up to 1 range. Deals an amount of damage inversely proportional to remaining HP.
//
// - Erkos
//   - Flame Ball : hits a 5x5 (circle) up to 4 range.
//   - Flame Wave : hits a 1-3-3-5-5 (wave) ahead. Deals 5 damage.
//   - Flame Rage : on the next turn, attacks deal +2 dmg. Stacks. Can't attack on this turn.
//   - Flame Nova : loses 30 HP. Deals massive damage in a 11x11 circle (20?).
// 
// - Croni
//   - Shadow Doll : places a doll in empty tile for up to 8 range, blocking the way until the end of the turn.
//   - Shadow Flux : after a delay, hits a 3x3 (square) in up to 8 range for high damage.
//   - Shadow Trap : places a trap in a secret position; activate to reveal and stun in a 3x3 (circle).
//   - Shadow Bond : loses 3 hp. Can't attack on this turn. If Croni dies on this turn, takes the killer with her.
// 
// - Flina
//   - Fly     : moves 4 steps, passing through enemies and walls.
//   - Javelin : hits a selected enemy up to 2 range.
//   - Gust    : pushes and deal damage to enemies in a 1-3-5 (wave) ahead.
//   - Ocarina : ...
//
// - Snarch
//   - Quick Bolt     : hits a selected enemy up to 6 range.
//   - Piercing Bolt  : hits a 1-1-1-1-1-1 (wave) ahead.
//   - Explosive Bolt : hits up to 2 3x3 (circles) up to 6 range.
//   - Ballista       : mounts/dismounts from a ballista. Can't attack on this turn. While mounted, can't move and attacks range doubled.
// 
// - Sirpix
//   - Stealth Clone : creates a stealth in up to 4 range. If already created, moves it 4 steps.
//   - Stealth Swap  : if your clone is in an empty tile, swaps position with it.
//   - Killing Edge  : hits a 3x3 (square) around.
//   - Lockpick      : special effects on map.
// 
// - Kenlua
//   - Dodge : select 4 tiles up to 32 range. Prevent all damage from enemies standing on those tiles during this turn.
//   - Slice : hits a 3x3 (square) around, dealing damage. 
//   - Haste : moves 4 steps. 
//   - Slash : hits a 1x1 (point) up to 1 range. Deals massive damage. If the hit lands, returns to the position you were at the beginning of the turn.
// 
// - Stanci
//   - Heal    : selects an ally up to 4 range. Heals him/her.
//   - Shield  : selects an ally up to 4 range. Gives him/her armor.
//   - Restore : hits a 5x5 (circle) up to 4 range, healing allies inside.
//   - Light   : selects an enemy up to 4 range to deal damage.
// 
// - Zagatur
//   - Summon    : selects an empty tile up to 4 range. Spawns a clone of Zagatur on it.
//   - Needle    : hits a 3x1 (line) ahead, dealing damage.
//   - Spikes    : hits a 3x3 (square) around, dealing damage.
//   - Petalkill : all zagatur die and hit a 3x3 square around, dealing high damage.
// 
// - Agdris
//   - Silence : selects an enemy up to 12 range. It can't attack on this turn.
//   - Memento : dies. Enemies can't attack on this turn.
// 
// - Mewru
//   - Psychock    : hits a 7x7 (circle) around, dealing damage.
//   - Mend        : hits a 7x7 (circle) around, healing allies.
//   - Telekinesis : selects an enemy up to 4 range. Performs 4 steps in selected directions.
//   - Teleport    : selects an empty location on the map. Moves to that location. 
// 
// ## Move Priority
// 
// <<Instant: 0>>
// - Croni Shadow Trap (activate)
// - Agdris Silence
// - Agdris Memento
//
// <<SelfCast: 16>>
// - Sirpix Stealth Clone
// - Snarch Ballista
// - Erkos Flame Rage
// - Gonk Endure
// - Gonk Breath
// - Gonk Empathy 
// - Tophoro Earth Root
// - Croni Shadow Bond
// - Mewru Telekinesis
// - Mewru Teleport
// 
// <<PointAndClick: 64>>
// - Tophoro Earth Lock
// - Stanci Shield
// - Stanci Heal
// - Kenlua Haste
// - Kenlua Slice
// - Sirpix Stealth Swap
// - SirPix Killing Edge
// - Stanci Light
// - Snarch Quick Bolt
// - Flina Javelin
// - Gonk Shatter
//
// <<TerrainControl: 112>>
// - Tophoro Earth Wall
// - Croni Shadow Doll
//
// - <<Walk: 128>>
// - Kenlua Walk
// - Sirpix Walk
// - Flina Walk
// - Snarch Walk
// - Erkos Walk
// - Stanci Walk
// - Croni Walk
// - Gonk Walk
// - Tophoro Walk
// - Agdris Walk
// - Mewru Walk
// - Zagatur Walk
//
// <<Post-Walk: 160>>
// - Flina Fly
// - Kenlua Dodge
// 
// <<Skillshot: 176>>
// - Tophoro Earth Pull
// - Kenlua Slash
// - Snarch Piercing Bolt
// - Snarch Explosive Bolt
// - Erkos Flame Wave
// - Erkos Flame Ball
// - Erkos Flame Nova
// - Zagatur Needles
// - Zagatur Spikes
// - Mewru Mend
// - Mewru Psychock
// - Croni Shadow Flux
// - Stanci Restore
// - Zagatur Petalkill
//
// <<EndTurn: 224>>
// - Croni Shadow Trap (place)
// - Zagatur Summon

def kaelin:
  // :::::::::::
  // :: Array ::
  // :::::::::::

  dup fold3    = (fold_array ~3)
  dup fold5    = (fold_array ~5)
  dup fold8    = (fold_array ~8)
  dup fold10   = (fold_array ~10) #
  dup with3    = (with ~3)
  dup take3    = (take ~3)
  dup update3  = (update ~3)
  dup write3   = (write ~3)
  dup with5    = (with ~5)
  dup take5    = (take ~5)
  dup update5  = (update ~5)
  dup write5   = (write ~5)
  dup with8    = (with ~8)
  dup take8    = (take ~8)
  dup update8  = (update ~8)
  dup write8   = (write ~8)
  dup with10   = (with ~10)
  dup take10   = (take ~10)
  dup update10 = (update ~10)
  dup write10  = (write ~10)

  // :::::::::::::::
  // :: Direction ::
  // :::::::::::::::

  dup RIGHT = #[ 1, 0] 
  dup DOWN  = #[ 0, 1] 
  dup LEFT  = #[-1, 0] 
  dup UP    = #[ 0,-1] 

  // Using a path, goes from "pos" to "target position"
  // - dirs : movement list to get into the desired position
  // - pos  : initial position
  let add_dirs = {mlen}
    dup move = (mlen {pos_dirs}
      get [pos,dirs] = pos_dirs
      get [dirs,dir] = (pop [0,0] dirs)
      [(vec2_add pos dir), dirs])
    # {pos dirs}
      fst (move [pos,dirs])
  dup add_dirs1 = (add_dirs ~1)
  dup add_dirs2 = (add_dirs ~2)
  dup add_dirs3 = (add_dirs ~3)
  dup add_dirs4 = (add_dirs ~4)
  dup add_dirs5 = (add_dirs ~5)

  // ::::::::::
  // :: Side ::
  // ::::::::::

  dup WHITE = #0
  dup BLACK = #1
  dup BOARD = #2

  dup eql_side = #{a b}
    |a == b|

  dup side_to_icon = #{side}
    cpy side = side
    if |side == WHITE|
    then: (to_chars "O")
    else: if |side == BLACK|
      then: (to_chars "X")
      else: (to_chars "B")

  // :::::::::::
  // :: Stats ::
  // :::::::::::

  dup Stats = # {hp shield armor buff locked muted} {Stats} (Stats hp shield armor buff locked muted)

  dup base_stats = # {hp}
    (Stats hp 0 0 0 0 0)

  dup stats_cpy = # {stats}
    (stats {hp shield armor buff locked muted}
      cpy hp     = hp
      cpy shield = shield
      cpy armor  = armor
      cpy buff   = buff
      cpy locked = locked
      cpy muted  = muted
      let cpy0   = (Stats hp shield armor buff locked muted)
      let cpy1   = (Stats hp shield armor buff locked muted)
      [cpy0, cpy1])

  dup mod_hp     = # {fn stats} (stats {hp shield armor buff locked muted} (Stats (fn hp) shield armor buff locked muted))
  dup get_hp     = # {stats} (stats {hp shield armor buff locked muted} hp)
  dup get_shield = # {stats} (stats {hp shield armor buff locked muted} shield)
  dup get_armor  = # {stats} (stats {hp shield armor buff locked muted} armor)
  dup get_buff   = # {stats} (stats {hp shield armor buff locked muted} buff)
  dup get_locked = # {stats} (stats {hp shield armor buff locked muted} locked)
  dup get_muted  = # {stats} (stats {hp shield armor buff locked muted} muted)
 
  // :::::::::::
  // :: Piece ::
  // :::::::::::

  dup Air    = #                   {Air Wall Throne Unit} Air
  dup Wall   = # {temp}            {Air Wall Throne Unit} (Wall temp)
  dup Throne = # {side}            {Air Wall Throne Unit} (Throne side)
  dup Unit   = # {hero side stats} {Air Wall Throne Unit} (Unit hero side stats)

  dup hero_icon = # {hero long}
    cpy long   = long
    let hero00 = (to_chars (if long ["Tophoro ", "To"]))
    let hero01 = (to_chars (if long ["Gonk    ", "Go"]))
    let hero02 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero03 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero04 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero05 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero06 = (to_chars (if long ["Erkos   ", "Er"]))
    let hero07 = (to_chars (if long ["Croni   ", "Cr"]))
    let hero08 = (to_chars (if long ["Snarch  ", "Sn"]))
    let hero09 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero10 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero11 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero12 = (to_chars (if long ["Sirpix  ", "Si"]))
    let hero13 = (to_chars (if long ["Kenlua  ", "Ke"]))
    let hero14 = (to_chars (if long ["Flina   ", "Fl"]))
    let hero15 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero16 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero17 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero18 = (to_chars (if long ["Stanci  ", "St"]))
    let hero19 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero20 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero21 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero22 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero23 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero24 = (to_chars (if long ["Zagatur ", "Za"]))
    let hero25 = (to_chars (if long ["Agdris  ", "Ag"]))
    let hero26 = (to_chars (if long ["Mewru   ", "Me"]))
    let hero27 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero28 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero29 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero30 = (to_chars (if long ["Missna  ", "Mi"]))
    let hero31 = (to_chars (if long ["Missna  ", "Mi"]))
    let quad00 = [[[hero00,hero01],[hero02,hero03]],[[hero04,hero05],[hero06,hero07]]]
    let quad01 = [[[hero08,hero09],[hero10,hero11]],[[hero12,hero13],[hero14,hero15]]]
    let quad02 = [[[hero16,hero17],[hero18,hero19]],[[hero20,hero21],[hero22,hero23]]]
    let quad03 = [[[hero24,hero25],[hero26,hero27]],[[hero28,hero29],[hero30,hero31]]]
    let heroes = [[quad00,quad01],[quad02,quad03]]
    (snd (take5 hero NilF heroes))

  dup piece_icon = # {piece}
    let case_air    = (to_chars " .")
    let case_wall   = {temp} if temp [(to_chars " M"), (to_chars " W")]
    let case_throne = {side} (to_chars " T")
    let case_unit   = {side hero stats} (hero_icon hero 0)
    (piece case_air case_wall case_throne case_unit)

  dup piece_info = # {piece}
    let case_air    = [Air, NilF]
    let case_wall   = {temp} [(Wall temp), NilF]
    let case_throne = {side} [(Throne side), NilF]
    let case_unit   = {side hero stats}
      get [stats0, stats1] = (stats_cpy stats)
      cpy hero = hero
      cpy hp   = (get_hp stats0)
      cpy side = side
      let val  = (Unit side hero stats1)
      let info =
        (concat (hero_icon hero 1) // Hero name
        (concat (to_chars ": ")
        (concat (ConsF (box_byte (num_to_char ||hp / 100| % 10|)) NilF) // HP
        (concat (ConsF (box_byte (num_to_char ||hp /  10| % 10|)) NilF) // HP
        (concat (ConsF (box_byte (num_to_char ||hp /   1| % 10|)) NilF) // HP
        (concat (to_chars " hp -- ")
        (concat (if side [(to_chars "black"),(to_chars "white")]) (ConsF #10 NilF))))))))
      [val, info]
    (piece case_air case_wall case_throne case_unit)

  dup piece_cpy_with = # {fn piece}
    let case_air    = {fn} [Air, (fn Air)]
    let case_wall   = {temp} {fn}
      cpy temp = temp
      [(Wall temp), (fn (Wall temp))]
    let case_throne = {side} {fn}
      cpy side = side
      [(Throne side), (fn (Throne side))]
    let case_unit = {side hero stats} {fn}
      cpy side = side
      cpy hero = hero
      get [stats0, stats1] = (stats_cpy stats)
      [(Unit side hero stats0), (fn (Unit side hero stats1))]
    (piece case_air case_wall case_throne case_unit fn)

  dup get_piece_hero = # {piece}
    let case_air    = None
    let case_wall   = {a_temp} None
    let case_throne = {a_side} None
    let case_unit   = {a_side a_hero a_stats} (Just a_hero)
    (piece case_air case_wall case_throne case_unit)

  dup get_piece_side = # {piece}
    let case_air    = BOARD
    let case_wall   = {a_temp} BOARD
    let case_throne = {a_side} a_side
    let case_unit   = {a_side a_hero a_stats} a_side
    (piece case_air case_wall case_throne case_unit)

  dup piece_is_hero = # {hero piece}
    let case_air    = 0
    let case_wall   = {a_temp} 0
    let case_throne = {a_side} 0
    let case_unit   = {a_side a_hero a_stats} |a_hero == hero|
    (piece case_air case_wall case_throne case_unit)

  // "a" and "b" are side positions. The function checks if they can swap their position, that is, simulate a walk, and returns:
  // - The same position: if they can't interact with each other.
  // - Inverted position: the elements interacted and one now occupies the position of the other.
  dup a_step_to_b = # {a b}
    let case_a_air      = {b} [Air, b]
    let case_a_wall     = {a_temp} {b} [(Wall a_temp), b]
    let case_a_throne   = {a_side} {b} [(Throne a_side), b]
    let case_a_unit     = {a_side a_hero a_stats} {b}
      let case_b_air    = {a_side a_hero a_stats}
        let a_val       = (Unit a_side a_hero a_stats)
        let b_val       = Air
        [b_val, a_val]
      let case_b_wall   = {b_temp} {a_side a_hero a_stats}
        let a_val       = (Unit a_side a_hero a_stats)
        let b_val       = (Wall b_temp)
        [a_val, b_val]
      let case_b_throne = {b_side} {a_side a_hero a_stats}
        let a_val       = (Unit a_side a_hero a_stats)
        let b_val       = (Throne b_side)
        [a_val, b_val]
      let case_b_unit   = {b_side b_hero b_stats} {a_side a_hero a_stats}
        cpy a_side      = a_side
        cpy b_side      = b_side
        let a_val       = (Unit a_side a_hero a_stats)
        let b_val       = (Unit b_side b_hero b_stats)
        let can_pass    = (eql_side a_side b_side)
        let then_swap   = [{a b}[b,a],{a b}[a,b]]
        (if can_pass then_swap a_val b_val)
      (b case_b_air case_b_wall case_b_throne case_b_unit a_side a_hero a_stats)
    (a case_a_air case_a_wall case_a_throne case_a_unit b)

  dup damage_visual_effect = # {dmg piece}
    let case_air    = (Wall 1)
    let case_wall   = {temp} (Wall temp)
    let case_throne = {side} (Throne side)
    let case_unit   = {side hero stats} (Unit side hero (mod_hp {hp}|hp - dmg| stats))
    (piece case_air case_wall case_throne case_unit)

  // TODO: 
  // - check if the life of "piece" is bigger than the damage
  dup damage = # {dmg piece}
    let case_air    = Air
    let case_wall   = {temp} (Wall temp)
    let case_throne = {side} (Throne side)
    let case_unit   = {side hero stats} (Unit side hero (mod_hp {hp}|hp - dmg| stats))
    (piece case_air case_wall case_throne case_unit)

  // :::::::::::::::::::::
  // :: Heroes & Skills ::
  // :::::::::::::::::::::

  dup TOPHORO  = # 0
  dup GONK     = # 1
  dup ERKOS    = # 6
  dup CRONI    = # 7
  dup SNARCH   = # 8
  dup SIRPIX   = # 12
  dup KENLUA   = # 13
  dup FLINA    = # 14
  dup STANCI   = # 18
  dup ZAGATUR  = # 24
  dup AGDRIS   = # 25
  dup MEWRU    = # 26

  let TO = TOPHORO
  let GO = GONK
  let ER = ERKOS
  let CR = CRONI
  let SN = SNARCH
  let SI = SIRPIX
  let KE = KENLUA
  let FL = FLINA
  let ST = STANCI
  let ZA = ZAGATUR
  let AG = AGDRIS
  let ME = MEWRU

  dup Tophoro  = # {side} (Unit side TOPHORO (base_stats 120))
  dup Gonk     = # {side} (Unit side GONK    (base_stats  90))
  dup Erkos    = # {side} (Unit side ERKOS   (base_stats  40))
  dup Croni    = # {side} (Unit side CRONI   (base_stats  40))
  dup Snarch   = # {side} (Unit side SNARCH  (base_stats  60))
  dup Sirpix   = # {side} (Unit side SIRPIX  (base_stats  60))
  dup Kenlua   = # {side} (Unit side KENLUA  (base_stats  60))
  dup Flina    = # {side} (Unit side FLINA   (base_stats  60))
  dup Stanci   = # {side} (Unit side STANCI  (base_stats  40))
  dup Zagatur  = # {side} (Unit side ZAGATUR (base_stats  10))
  dup Agdris   = # {side} (Unit side AGDRIS  (base_stats  20))
  dup Mewru    = # {side} (Unit side MEWRU   (base_stats  20))

  dup PASS          = # 0
  dup KENLUA_WALK   = # 128
  dup SIRPIX_WALK   = # 129
  dup FLINA_WALK    = # 130
  dup SNARCH_WALK   = # 131
  dup ERKOS_WALK    = # 132
  dup STANCI_WALK   = # 133
  dup CRONI_WALK    = # 134
  dup GONK_WALK     = # 135
  dup TOPHORO_WALK  = # 136
  dup AGDRIS_WALK   = # 137
  dup MEWRU_WALK    = # 138
  dup ZAGATUR_WALK  = # 139
  dup EARTH_PULL    = # 176
  dup PIERCING_BOLT = # 179

  // get_skill_hero
  // | Given a skill, returns the hero of that skill
  // : {skill : Num}
  //   Num
  dup get_skill_hero = # {skill}
    let i000 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i016 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i032 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i048 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i064 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i080 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i096 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i112 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i128 = [[[[KE,SI],[FL,SN]],[[ER,ST],[CR,GO]]],[[[TO,AG],[ME,ZA]],[[ 0, 0],[ 0, 0]]]]
    let i144 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i160 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i176 = [[[[TO, 0],[ 0,SN]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i192 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i208 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i224 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let i240 = [[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]],[[[ 0, 0],[ 0, 0]],[[ 0, 0],[ 0, 0]]]]
    let smap = [[[[i000,i016],[i032,i048]],[[i064,i080],[i096,i112]]],[[[i128,i144],[i160,i176]],[[i192,i208],[i224,i240]]]]
    snd (take8 skill 0 smap)

  // get_hero_skill
  // | Given a hero and a skill slot, returns the skill
  // : {hero : Num}
  //   {slot : Num}
  //   Num
  dup get_hero_skill = # {hero slot}
    let to = [[[TOPHORO_WALK , EARTH_PULL] , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let go = [[[GONK_WALK    , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let er = [[[ERKOS_WALK   , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let cr = [[[CRONI_WALK   , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let sn = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let si = [[[SIRPIX_WALK  , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let ke = [[[KENLUA_WALK  , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let fl = [[[FLINA_WALK   , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let st = [[[STANCI_WALK  , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let za = [[[ZAGATUR_WALK , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let ag = [[[AGDRIS_WALK  , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let me = [[[MEWRU_WALK   , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let xx = [[[PASS         , PASS]       , [PASS , PASS]] , [[PASS , PASS] , [PASS , PASS]]]
    let h0 = [[[[to,go],[xx,xx]],[[xx,xx],[er,cr]]],[[[sn,xx],[xx,xx]],[[si,ke],[fl,xx]]]]
    let h1 = [[[[xx,xx],[st,xx]],[[xx,xx],[xx,xx]]],[[[za,ag],[me,xx]],[[xx,xx],[xx,xx]]]]
    (snd (take3 slot 0 (snd (take5 hero 0 [h0,h1]))))

  // :::::::::::
  // :: Board ::
  // :::::::::::

  dup new_board = #
    let O   = Air
    let a   = (Gonk WHITE)
    let b   = (Erkos WHITE)
    let c   = (Kenlua WHITE)
    let d   = (Mewru WHITE)
    let e   = (Tophoro BLACK)
    let f   = (Croni BLACK)
    let g   = (Stanci BLACK)
    let h   = (Flina BLACK)
    let W   = (Wall 0)
    let x   = (Throne WHITE)
    let y   = (Throne BLACK)
    let r00 = [[[[[W,W],[W,W]],[[W,W],[W,O]]],[[[O,W],[W,O]],[[O,O],[O,W]]]],[[[[W,O],[O,O]],[[O,W],[W,O]]],[[[O,W],[W,W]],[[y,W],[W,W]]]]]
    let r01 = [[[[[W,O],[O,W]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[h,g]],[[O,f],[e,W]]]]]
    let r02 = [[[[[W,W],[W,W]],[[W,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,O]],[[O,O],[O,W]]]]]
    let r03 = [[[[[W,O],[O,W]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,O]],[[O,O],[O,W]]]]]
    let r04 = [[[[[W,O],[W,W]],[[W,W],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,O]],[[O,O],[O,W]]]]]
    let r05 = [[[[[W,O],[O,W]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,O]],[[O,O],[O,W]]]]]
    let r06 = [[[[[W,W],[W,W]],[[W,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,O]],[[W,O],[O,W]]]]]
    let r07 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r08 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r09 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
    let r10 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
    let r11 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
    let r12 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r13 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r14 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r15 = [[[[[W,W],[W,W]],[[W,W],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[W,W]],[[W,W],[W,W]]]]] // MID
    let r16 = [[[[[W,W],[W,W]],[[W,W],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[W,W]],[[W,W],[W,W]]]]] // MID
    let r17 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r18 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r19 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r20 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
    let r21 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
    let r22 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]
    let r23 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r24 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]
    let r25 = [[[[[W,O],[O,W]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[W,W]],[[W,W],[W,W]]]]]
    let r26 = [[[[[W,O],[O,O]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,O]],[[O,O],[O,W]]]]]
    let r27 = [[[[[W,O],[O,O]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[W,W],[W,W]]]]]
    let r28 = [[[[[W,O],[O,O]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[O,O],[O,W]]]]]
    let r29 = [[[[[W,O],[O,O]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[O,W],[W,W]]]]]
    let r30 = [[[[[W,a],[b,O]],[[c,d],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[O,W],[O,W]]]]]
    let r31 = [[[[[W,W],[W,x]],[[W,W],[W,O]]],[[[O,W],[W,O]],[[O,O],[O,W]]]],[[[[W,O],[O,O]],[[O,W],[W,O]]],[[[O,W],[W,W]],[[W,W],[W,W]]]]]
    [[[[[r00,r01],[r02,r03]],[[r04,r05],[r06,r07]]],[[[r08,r09],[r10,r11]],[[r12,r13],[r14,r15]]]],
    [[[[r16,r17],[r18,r19]],[[r20,r21],[r22,r23]]],[[[r24,r25],[r26,r27]],[[r28,r29],[r30,r31]]]]]

  // Simulates an index in an array of 1024 elements (32x32 map).
  // x: column
  // y: line 
  dup board_index = # {pos}
    get [x,y] = pos
    ||y * 32| + x|

  dup board_position = # {idx}
    cpy idx = idx
    [|idx % 32|, |idx / 32|]

  dup board_interact = # {a_pos b_pos fun board}
    cpy a_idx         = (board_index a_pos)
    cpy b_idx         = (board_index b_pos)
    get [board,a_val] = (take10 a_idx Air board)
    get [board,b_val] = (take10 b_idx Air board)
    get [a_val,b_val] = (fun a_val b_val)
    let board         = (write10 a_idx a_val board)
    let board         = (write10 b_idx b_val board)
    board 

  // Apply a function to a board piece
  dup board_update = # {pos fun board}
    (update10 (board_index pos) fun board)

  dup print_board = 
    let fold_node = {lft rgt}
      get [lft_info, lft_board] = lft
      get [rgt_info, rgt_board] = rgt
      [(concat lft_info rgt_info), (concat lft_board rgt_board)]
    let fold_leaf = {piece}
      get [piece, info] = (piece_info piece)
      [info, (piece_icon piece)]
    dup fold = (fold10 #fold_node #fold_leaf)
    # {board}
      get [info, board] = (fold board)
      let board = (cons-every #64 #10 board)
      (from_chars (concat (ConsF 10 NilF) (concat info (concat board (ConsF 10 NilF)))))

  dup board_query_at = # {pos func board}
    (with10 (board_index pos) (piece_cpy_with func) board)

  // ::::::::::::::::
  // :: Animations ::
  // ::::::::::::::::

  dup Skip = #        {Skip Text Path Area Many} Skip
  dup Text = # {text} {Skip Text Path Area Many} (Text text)
  dup Path = # {path} {Skip Text Path Area Many} (Path path)
  dup Area = # {area} {Skip Text Path Area Many} (Area area)
  dup Many = # {list} {Skip Text Path Area Many} (Many list)

  // :::::::::::::
  // :: Effects ::
  // :::::::::::::

  // Given a position and a direction to step forward, move the element (if is possible) and return the updated map
  dup step = # {a_pos a_dxy board}
    get [a_pos0,a_pos1] = (vec2_cpy a_pos)
    let b_pos           = (vec2_add a_pos0 a_dxy)
    (board_interact a_pos1 b_pos a_step_to_b board)

  // TODO: Flip properties of a piece about move and attack
  dup stun = # {piece}
    let case_air     = Air
    let case_wall    = {temp} (Wall temp)
    let case_throne  = {side} (Throne side)
    let case_unit    = {side hero stats} (Unit side hero stats)
    (piece case_air case_wall case_throne case_unit)

  // Stun enemies in a 3x3 (circle) around
  dup stun_small_circle =
    let area  = vec2_circle_b
    let hits  = {pos board} (board_update pos stun board)
    (area #hits) 

  // Checks if given position is a specific hero
  dup is_hero_at = # {pos hero board}
    (board_query_at pos (piece_is_hero hero) board)

  // Gets the side of the piece in some position
  dup get_side_at = # {pos board}
    (board_query_at pos get_piece_side board)

  // :::::::::::::::::::
  // :: Skill Effects ::
  // :::::::::::::::::::

  // make_area_skill
  // : {-P    : Type}
  //   {area  : Area}
  //   {hits  : {cpos : [Num,Num]} {pos : [Num,Num]} {state : P} P}
  // ! {pos   : [Num,Num]}
  //   {board : P}
  //   P
  let make_area_skill = {area hits}
    dup hits = hits
    dup exec = (area #{pos state}
        get [state, area]  = state
        get [board, cpos]  = state
        get [cpos0, cpos1] = (vec2_cpy cpos)
        get [pos0, pos1]   = (vec2_cpy pos)
        let new_board      = (hits cpos0 pos0 board)
        let new_area       = (Cons pos1 area)
        [[new_board, cpos1], new_area])
    # {pos board}
      get [pos0, pos1]  = (vec2_cpy pos)
      get [state, area] = (exec pos0 [[board, pos1], Nil])
      get [board, cpos] = state
      [board, (Area area)]

  // make_wave_skill
  // : {-P    : Type}
  //   {area  : Area}
  //   {hits  : {cpos : [Num,Num]} {pos : [Num,Num]} {dir : [Num,Num]} {state : P} P}
  // ! {pos   : [Num,Num]}
  //   {dir   : [Num,Num]}
  //   {board : P}
  //   P
  let make_wave_skill = {area hits}
    dup hits = hits
    dup exec = (area #{pos_dir state}
      get [pos, dir]     = pos_dir
      get [state, area]  = state
      get [board, cpos]  = state
      get [cpos0, cpos1] = (vec2_cpy cpos)
      get [pos0, pos1]   = (vec2_cpy pos)
      let new_board      = (hits cpos0 pos0 dir board)
      let new_area       = (Cons pos1 area)
      [[new_board, cpos1], new_area])
    # {pos dir board}
      get [pos0, pos1]  = (vec2_cpy pos)
      get [state, area] = (exec pos0 dir [[board, pos1], Nil])
      get [board, cpos] = state
      [board, (Area area)]

  dup do_if_side = # {comp a_pos b_pos board func}
    get [b_pos0, b_pos1] = (vec2_cpy b_pos)
    get [board, a_side]  = (get_side_at a_pos board)
    get [board, b_side]  = (get_side_at b_pos0 board)
    (if (comp a_side b_side)
      then: {board} (func b_pos1 board)
      else: {board} board
      board)
  dup do_if_enemy = # (do_if_side {a_side b_side} |1 - |a_side == b_side||)
  dup do_if_ally  = # (do_if_side {a_side b_side}      |a_side == b_side|)

  // Walks through a set of directions
  let walk = {hero steps}
    dup hero = hero
    let walk = {state}
      get [state0, state1] = state
      get [pos, dirs]      = state0
      get [board, path]    = state1
      get [new_dirs, dir]  = (pop [0,0] dirs)
      get [pos, pos_cpy]   = (vec2_cpy pos)
      get [dir, dir_cpy]   = (vec2_cpy dir)
      let new_pos          = (vec2_add pos_cpy dir_cpy)
      get [pos, pos_cpy]   = (vec2_cpy pos)
      let new_path         = {x} (path (Cons pos_cpy x))
      get [pos, pos_cpy]   = (vec2_cpy pos)
      get [board, allow]   = (is_hero_at pos_cpy hero board)
      let new_board        = (if allow [step, {pos dir board}board] pos dir board)
      [[new_pos, new_dirs], [new_board, new_path]]
    dup walk = (steps #walk)
    # {pos dirs board}
      let state            = [[pos, dirs], [board, {x}x]]
      get [state0, state1] = (walk state)
      get [pos, dirs]      = state0
      get [board, path]    = state1
      [board, (Path (path (Cons pos Nil)))]

  // == Tophoro ==
  // ~~~~~~~~~~~~~

  dup tophoro_walk = (walk #TOPHORO ~3)

  dup earth_pull =
    let wave = (vec2_wave_in (ConsF #0 (ConsF #1 (ConsF #3 (ConsF #5 NilF)))))
    let hits = # {cpos hpos dir board} (do_if_ally cpos hpos board {hpos board}(step hpos dir board))
    (make_wave_skill wave hits)

  dup earth_wall =
    let loop = {state}
      get [state, dirs_list] = state
      get [board, cpos]      = state
      get [cpos0, cpos1]     = (vec2_cpy cpos)
      get [dirs_list, dirs]  = (pop [0,0] dirs_list)
      let wall_pos           = (add_dirs3 cpos0 dirs)
      let board              = (board_update wall_pos {p}(p (Wall 1) {temp}(Wall temp) Throne Unit) board)
      [[board, cpos1], dirs_list]
    dup put_walls = (~3 #loop)
    # {pos dirs_list board}
      (fst (fst (put_walls [[board,pos], dirs_list])))

  // == Gonk ==
  // ~~~~~~~~~~

  dup gonk_walk = (walk #GONK ~4)

  // == Erkos ==
  // ~~~~~~~~~~~

  dup erkos_walk = (walk #ERKOS ~4)

  // Hits a 1-3-3-5-5 (wave). Deals 5 damage.
  dup flame_wave =
    let area = (vec2_wave (ConsF #1 (ConsF #3 (ConsF #3 (ConsF #5 (ConsF #5 NilF))))))
    let hits = {pos board} (board_update pos (damage 5) board)
    (area #hits)
  
  // Hits a 5x5 (circle). Deals 5 damage.
  // TODO: add 4 range
  dup flame_ball =
    let area = vec2_circle_e
    let hits = {pos board} (board_update pos (damage 5) board)
    //let hits = {pos board} (board_update pos (damage_visual_effect 5) board)
    (area #hits)

  // Selects an enemy up to 1 range. Deals massive damage (20?)
  dup flame_soul = # {pos dir board}
    let t_pos = (vec2_add pos dir)
    (board_update t_pos (damage_visual_effect 21) board)

  // Deals massive damage in a 11x11 circle (20?)
  dup flame_nova =
    let area = vec2_circle_j
    let hits = {pos board} (board_update pos (damage 20) board)
    //let hits = {pos board} (board_update pos (damage_visual_effect 20) board)
    (area #hits)

  // == Croni ==
  // ~~~~~~~~~~~

  dup croni_walk = (walk #CRONI ~4)

  // Places a doll in an empty tile
  // TODO: add 8 range
  dup shadow_doll = # {pos board}
    let case_air     = (Wall 1)
    let case_wall    = {temp} (Wall temp)
    let case_throne  = {side} (Throne side)
    let case_unit    = {side hero stats} (Unit side hero stats)
    let change_piece = {t} (t case_air case_wall case_throne case_unit)
    (board_update pos change_piece board)

  // Hits a 3x3 (square) with for high damage (15?).
  // TODO: add 8 range
  dup shadow_flux =
    let area = vec2_circle_c
    //let hits = {pos board} (board_update pos (damage 15) board)
    let hits = {pos board} (board_update pos (damage_visual_effect 15) board)
    (area #hits)

  // TODO: Loses half hp. Can't attack on this turn. Can't use on next turn. If Croni dies on this turn, takes the killer with her.
  //dup shadow_bond = # {side hero hp}

  // == Snarch ==
  // ~~~~~~~~~~~~

  dup snarch_walk = (walk #SNARCH ~4)

  // Hits a selected enemy up to 3 range. Deals 5 damage.
  dup quick_shot = # {pos dirs board}
    (board_update (add_dirs4 pos dirs) (damage_visual_effect 3) board)

  // Hits all enemies in a 5x1 (line) ahead. Deals 3 damage.
  dup piercing_bolt =
    let area = (vec2_wave (ConsF #1 (ConsF #1 (ConsF #1 (ConsF #1 (ConsF #1 NilF))))))
    let hits = {pos board} (board_update pos (damage_visual_effect 3) board)
    (area #hits) 

  // Explosive Arrow : hits up to 2 3x3 (circles). Deals 2 damage.
  // TODO: add 5 range
  //dup explosive_arrow =
    //let area = vec2_circle_b
    //let hits = {pos board} (board_update pos (damage_visual_effect 2) board)
    //# {pos1 pos2 board}
      //let board = (area #hits pos1 board)
      //let board = (area #hits pos2 board)
      //board

  // TODO: mounts/dismounts from a ballista. Can't attack on this turn. While mounted, can't move and attacks range increase to 12.
  //dup ballista = #

  // == Sirpix ==
  // ~~~~~~~~~~~~

  dup sirpix_walk = (walk #SIRPIX ~4)

  // == Kenlua ==
  // ~~~~~~~~~~~~

  dup kenlua_walk = (walk #KENLUA ~4)

  // Hits a 3x3 (square) around. Deals 3 damage.
  dup killing_edge =
    let area = vec2_circle_c
    let hits = {pos board} (board_update pos (damage_visual_effect 3) board)
    (area #hits)

  // Select 4 tiles up to 32 range. Prevent all damage from enemies standing on those tiles during this turn.
  // TODO: Add range
  // TODO: Change function applied to the positions to "silence"
  dup dodge = # {pos1 pos2 pos3 pos4 board}
    let case_air    = Air
    let case_wall   = {temp} (Wall temp)
    let case_throne = {side} (Throne side)
    let case_unit   = {side hero stats} (Unit side hero stats)
    let board       = (board_update pos1 (damage_visual_effect 1) board)
    let board       = (board_update pos2 (damage_visual_effect 1) board)
    let board       = (board_update pos3 (damage_visual_effect 1) board)
    let board       = (board_update pos4 (damage_visual_effect 1) board)
    board

  // Hits a 3x3 (square) around. Deals 8 damage.
  dup slice_area =
    let area = vec2_circle_c
    let hits = {pos board} (board_update pos (damage_visual_effect 8) board)
    (area #hits)

  // == Flina ==
  // ~~~~~~~~~~~

  dup flina_walk = (walk #FLINA ~4)

  // == Stanci ==
  // ~~~~~~~~~~~~

  dup stanci_walk = (walk #STANCI ~4)

  // == Zagatur ==
  // ~~~~~~~~~~~~~

  dup zagatur_walk = (walk #ZAGATUR ~0)

  // == Agdris ==
  // ~~~~~~~~~~~~

  dup agdris_walk = (walk #AGDRIS ~1)

  // == Mewru ==
  // ~~~~~~~~~~~

  dup mewru_walk = (walk #MEWRU ~0)

  // ::::::::::::::::::
  // :: Casts & Turn ::
  // ::::::::::::::::::

  // empty_casts
  // : (Array ~8 (Maybe [Pos, Arg]))
  dup empty_casts = #
    let a = [None,None]
    let b = [a,a] let c = [b,b] let d = [c,c]
    let e = [d,d] let f = [e,e] let g = [f,f] [g,g]

  // cast
  // : {skill : Num} ->
  //   {pos   : [Num,Num]} ->
  //   {arg   : Arg} ->
  //   {casts : (Array ~8 (Maybe [Pos, Arg]))} ->
  //   (Array ~8 (Maybe [Pos, Arg]))
  dup cast = # {skill pos arg casts}
    (write8 skill (Just [pos, arg]) casts)

  // Casts a skill
  dup cast_skill = # {hero skill effect state log}
    cpy hero = hero
    cpy skill = skill
    get [board, casts] = state
    get [casts, mcast] = (take8 skill None casts)
    let case_none = {board casts}
      [board, casts]
    let case_just = {cast board casts}
      get [pos, arg]     = cast
      get [pos, pos_cpy] = (vec2_cpy pos)
      get [board, allow] = (with10 (board_index pos_cpy) (piece_cpy_with (piece_is_hero hero)) board)
      get [pos, pos_cpy] = (vec2_cpy pos)
      let board = (if allow
        then: {board}
          get [board, anims] = (effect pos_cpy arg board)
          (log [hero, skill] anims board)
        else: {board}
          board
        board)
      [board, casts]
    (mcast case_none case_just board casts)

  // Removes temporary walls, stuns, etc.
  dup end_turn =
    let fold_node = {a b} [a,b]
    let fold_leaf = {piece}
      let case_air    = Air
      let case_wall   = {temp} if temp [Air, (Wall 0)]
      let case_throne = Throne
      let case_unit   = Unit
      (piece case_air case_wall case_throne case_unit)
    dup fold = (fold10 #fold_node #fold_leaf)
    # {board} (fold board)

  let exec_casts_with = {log} 
    dup log = log
    # {casts board}
      let state = [board, casts]
      let state = (cast_skill KENLUA  KENLUA_WALK   kenlua_walk   state log)
      let state = (cast_skill SIRPIX  SIRPIX_WALK   sirpix_walk   state log)
      let state = (cast_skill FLINA   FLINA_WALK    flina_walk    state log)
      let state = (cast_skill SNARCH  SNARCH_WALK   snarch_walk   state log)
      let state = (cast_skill ERKOS   ERKOS_WALK    erkos_walk    state log)
      let state = (cast_skill STANCI  STANCI_WALK   stanci_walk   state log)
      let state = (cast_skill CRONI   CRONI_WALK    croni_walk    state log)
      let state = (cast_skill GONK    GONK_WALK     gonk_walk     state log)
      let state = (cast_skill TOPHORO TOPHORO_WALK  tophoro_walk  state log)
      let state = (cast_skill AGDRIS  AGDRIS_WALK   agdris_walk   state log)
      let state = (cast_skill MEWRU   MEWRU_WALK    mewru_walk    state log)
      let state = (cast_skill ZAGATUR ZAGATUR_WALK  zagatur_walk  state log)
      let state = (cast_skill TOPHORO EARTH_PULL    earth_pull    state log)
      let state = (cast_skill SNARCH  PIERCING_BOLT piercing_bolt state log)
      (fst state)

  // exec_casts
  // : {casts : (Array ~8 [Pos, Arg])}
  //   {board : (Array ~10 Unit)}
  //   (Array ~10 Unit)
  dup exec_casts = (exec_casts_with #{a b c}c)

  //W W W W W W W . . W W . . . . W W . . . . W W . . W W W T W W W
  //W . . W . . W . . . . . . . . . . . . . . . . . . W X X . X X W
  //W W W W W . W . . . . . . . . . . . . . . . . . . C . . . . . W
  //W . . W . . W . . . . . . . . . . . . . . . . . . W . . . . . W
  //W . W W W W W . . . . . . . . . . . . . . . X . . C . . . . . W
  //W . . W . . . . . . . . . . . . . . . . X X X X X W . . . . . W
  //W W W W W . W . . . . . . . . . . . . X X X X X X W W . . . W W
  //. . . . . . . . . . . . . X X . . . X X X X X X X X X . . . . .
  //. . . . . . . . . . . X X X X . . . X X X X X X X X X . . . . .
  //W . . . . . . . . E X X X X X . . X X X X X T X X X X X . . . W
  //W . . . . . . . . . . X X X X . . . X X X X X X X X X . . . . W
  //W . . . . . . . . . . . . X X . . . X X X X X X X X X . . . . W
  //. . . . . . . . . . . . . . . . . . . X X X X X X X . . . . . .
  //. . . . . . . . . . . . . . . . C . . . X X X X X . . . . . . .
  //. . . . . . . . . . . . . . X X S . . . . . X . . . . . . . . .
  //C C C C C C C C . . . . . X X X X X . . . . . . C C C C C C C C
  //C C C C C C C . . . . . . X X T X X . . . . . . C C C C C C C C
  //. . . . . . . . . . . . . X X X X X . . . . . . . . . . . . . .
  //. . . . . . . . M . . S . . X X X . . . . . . . . . . . . . . .
  //. . . . . . . . . . E . . . . . . . . . . X X X . . . . . . . .
  //W . . . . . . . . . K . . . . . . . . . . X T X . . . . . . . W
  //W . . . . . . . . . . . . . . . . X . . . X X X . . . . . . . W
  //W . . . . . . . . . . . . . . . X X . . . . . . . . . . . . . W
  //. . . . O O . . . . . . . . T X X X . . . . . . . . . . . . . .
  //. . . . . . . . . . . . . . . . X X . . . . . . . . . . . . . .
  //W W . . . W W . . . . . . . . . . X . . . . . . . W W W W W W W
  //W . . . . . W . . . . . . . . . . . . . . . . . . W . . . . . W
  //W . . . . . C . . . . . . . . . . . . . . . . . . W . W W W W W
  //W . . . . . W . . . . . . . . . . . . . . . . . . W . W . . . W
  //W . . . . . C . . . . . . . . . . . . . . . . . . W . W . W W W
  //W O . K . O W . . . . . . . . . . . . . . . . . . W . W . W . W
  //W W W T W W W . . W W . . . . W W . . . . W W . . W W W W W W W"

  //W W W W W W W . . W W . . . . W W . . . . W W . . W W W T W W W
  //W . . W . . W . . . . . . . M . . . . . . . . . . W X X . X X W
  //W W W W W . W . . . . . . M M M . . . . . . . . . C . . . . . W
  //W . . W . . W . . . . . M M M M M . . . . . . . . W . . . . . W
  //W . W W W W W . . . . M M M M M M M . . . . . . . C . . . . . W
  //W . . W . . . . . . M M M M O M M M M . . . . . . W . . . . . W
  //W W W W W . W . . M M M M O O O M M M M . . . . . W W . . . W W
  //. . . . . . . . M M M M O O O O O M M M M . . . . . . . . . . .
  //. . . . . . . M M M M O O O O O O O M M M M . . . . . X . . . .
  //W . . . . . M M M M O O O O 4 O O O O M M M M . . . X X X . . W
  //W . . . . M M M M O O O O 4 4 4 O O O O M M M M . . . X . . . W
  //W . . . M M M M O O O O 4 4 4 4 4 O O O O M M M M . . . . . . W
  //. . . M M M M O O O O 4 4 4 4 4 4 4 O O O O M M M M . . . . . .
  //. . M M M M O O O O 4 4 4 4 C 4 4 4 4 O O O O M M M M . . . . .
  //. . . M M M M O O O O 4 4 4 4 4 4 4 O O O O M M M M . . . . . .
  //C C C C C C C M O O O O 4 4 4 4 4 O O O O M M M C C C C C C C C
  //C C C C C C C M M O O O O 4 4 4 O O O O M M M M C C C C C C C C
  //. . . . . . M M M M O O O O 4 O O O O M M M M . . . . . . . . .
  //. . . . . . . M M M M O O O O O O O M M M M . . . . . . . . . .
  //. . . . . . . . M M M M O O O O O M M M M . . . . . . . . . . .
  //W . . . . . . . . M M M M O O O M M M M . . . . . . . . . . . W
  //W . . . . . . . . . M M M M O M M M M . . . C . . . . . . . . W
  //W . . . . . . . . . . M M M M M M M . . . . 4 . . . . . . . . W
  //. . . . O O . . . . . . M M M M M . . . . . 4 . . . . . . . . .
  //. . . . . . . . . . . . . M M M . . . . . . 4 . . . . . . . . .
  //W W . . . W W . . . . . . . M . . . . . . . 4 . . W W W W W W W
  //W . . . . . W . . . . . . . . . . x . . . . O . . W . . . . . W
  //W . . . . . C . . . . . . . . . x x x . . . O . . W . W W W W W
  //W . . . . . W . . . . . . . . x x x x x . . O . . W . W . . . W
  //W . . . . . C . . . . . . . . . x x x . . . O . . W . W . W W W
  //W O . . . O W . . . . . . . . . . x . . . . . . . W . W . W . W
  //W W W T W W W . . W W . . . . W W . . . . W W . . W W W W W W W"

  dup example = #
    let board = new_board
    let board = (earth_wall [30,1] (Cons (Cons DOWN (Cons DOWN Nil)) Nil) board)
    let board = (end_turn board)

    //let casts = empty_casts
    //let casts = (cast CRONI_WALK [29,1] (Cons [0,1] (Cons [0,1] (Cons [0,1] Nil))) casts)
    //let casts = (cast TOPHORO_WALK [30,1] (Cons [0,1] Nil) casts)
    //let casts = (cast EARTH_PULL [30,2] [0,1] casts)
    //let board = (exec_casts casts board)

    (print_board board)

  dup export = 
    [#new_board,
    [exec_casts_with,
    [#empty_casts,
    [#cast,
    [#get_hero_skill,
      0]]]]]

  # export
