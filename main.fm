type Empty {
}

type Unit {
  new
}

type Bool {
  true,
  false,
}

type Bit {
  0,
  1,
}

type Cmp {
  ltn,
  eql,
  gtn,
}

type Bits {
  nil,
  0(pred: Bits),
  1(pred: Bits),
}

type Nat {
  zero,
  succ(pred: Nat),
}

type Word ~ (size: Nat) {
  nil                            ~ (Nat.zero),
  0<size: Nat>(pred: Word(size)) ~ (Nat.succ(size)),
  1<size: Nat>(pred: Word(size)) ~ (Nat.succ(size)),
}

type Maybe <A: Type> {
  none,
  some(value: A),
}

type Either <A: Type, B: Type> {
  left(value: A),
  right(value: B),
}

type Pair <A: Type, B: Type> {
  new(fst: A, snd: B)
}

type List <A: Type> {
  nil,
  cons(head: A, tail: List(A)),
}

type Map<A: Type> {
  new,
  tie(val: Maybe(A), lft: Map(A), rgt: Map(A)),
}

Set: Type
  Map(Unit)

type U16 {
  new(value: Word(16))
}

Char: Type
  U16

type String {
  nil,
  cons(head: Char, tail: String),
}

type Monad<M: Type -> Type> {
  new(
    bind: <A: Type, B: Type> -> M(A) -> (A -> M(B)) -> M(B),
    pure: <A: Type> -> A -> M(A)
  )
}

type Parser.Reply<V: Type> {
  error(code: String, error: String),
  value(code: String, value: V),
}

type IO<A: Type> {
  end(value: A),
  ask(query: String, param: String, then: String -> IO(A)),
}

// Prereqs
// =======

// If we have an element of the empty type, then we can prove anything.
Empty.absurd<P: Type>(x: Empty): P
  case x {}

Bool.not(a: Bool):  Bool
  case a {
    true: Bool.false,
    false: Bool.true,
  }

Bool.and(a: Bool, b: Bool): Bool
  case a {
    true: b,
    false: Bool.false,
  }

Bool.or(a: Bool, b: Bool): Bool
  case a {
    true: Bool.true,
    false: b,
  }

// n == m
Cmp.as_eql(cmp: Cmp): Bool
  case cmp {
    ltn: Bool.false,
    eql: Bool.true,
    gtn: Bool.false,
  }

// n >= m
Cmp.as_gte(cmp: Cmp): Bool
  case cmp {
    ltn: Bool.false,
    eql: Bool.true,
    gtn: Bool.true,
  }

// n > m
Cmp.as_gtn(cmp: Cmp): Bool
  case cmp {
    ltn: Bool.false,
    eql: Bool.false,
    gtn: Bool.true,
  }

// n <= m
Cmp.as_lte(cmp: Cmp): Bool
  case cmp {
    ltn: Bool.true,
    eql: Bool.true,
    gtn: Bool.false,
  }

// n < m
Cmp.as_ltn(cmp: Cmp): Bool
  case cmp {
    ltn: Bool.true,
    eql: Bool.false,
    gtn: Bool.false,
  }

Nat.pred(n: Nat): Nat
  case n {
    zero: Nat.zero,
    succ: n.pred
  }

Nat.apply<A: Type>(n: Nat, f: A -> A, x: A): A
  case n {
    zero: x,
    succ: Nat.apply<A>(n.pred, f, f(x)),
  }

Nat.to_base(base: Nat, nat: Nat): List(Nat)
  Nat.to_base.go(base, nat, List.nil<Nat>)

Nat.to_base.go(base: Nat, nat: Nat, res: List(Nat)): List(Nat)
  case Nat.div_mod(nat, base) as div_mod {
    new: case div_mod.fst {
      zero: List.cons<>(div_mod.snd, res),
      succ: Nat.to_base.go(base, div_mod.fst, List.cons<>(div_mod.snd, res))
    } 
  }

Nat.from_base(base: Nat, ds: List(Nat)) : Nat
  Nat.from_base.go(base,List.reverse<>(ds),1,0)

Nat.from_base.go(b: Nat, ds: List(Nat), p: Nat, res : Nat) : Nat
  case ds {
    nil : res,
    cons: Nat.from_base.go(b,ds.tail,Nat.mul(b,p), Nat.add(Nat.mul(ds.head,p),res))
  }

Nat.to_string_base(base: Nat, nat: Nat): String
  List.fold<>(Nat.to_base(base, nat))<>(
    String.nil,
    (n, str) String.cons(Nat.show_digit(base,n), str))

Nat.to_bits(n: Nat): Bits
  case n {
    zero: Bits.nil,
    succ: Bits.inc(Nat.to_bits(n.pred))
  }

Nat.add(n: Nat, m: Nat): Nat
  case n {
    zero: m,
    succ: Nat.succ(Nat.add(n.pred, m)),
  }

Nat.sub(n: Nat, m: Nat): Nat
  case n {
    zero: 0,
    succ: case m {
      zero: n,
      succ: Nat.sub(n.pred, m.pred)
    }
  }

Nat.cmp(a: Nat, b: Nat): Cmp
  case a {
    zero: case b {
      zero: Cmp.eql,
      succ: Cmp.ltn,
    },
    succ: case b {
      zero: Cmp.gtn,
      succ: Nat.cmp(a.pred, b.pred),
    }
  }

Nat.mul(n: Nat, m: Nat): Nat
  case n {
    zero: Nat.zero,
    succ: Nat.add(m, Nat.mul(n.pred, m))
  }

Nat.sub_rem(n: Nat, m: Nat): Either(Nat, Nat)
  case m {
    zero: Either.left<_,_>(n),
    succ: case n {
      zero: Either.right<_,_>(Nat.succ(m.pred)),
      succ: Nat.sub_rem(n.pred, m.pred),
    }
  }

Nat.div_mod(n: Nat, m: Nat): Pair(Nat, Nat)
  Nat.div_mod.go(n, m, Nat.zero)

Nat.div_mod.go(n: Nat, m: Nat, d: Nat): Pair(Nat, Nat)
  case Nat.sub_rem(n, m) as p {
    left: Nat.div_mod.go(p.value, m, Nat.succ(d)),
    right: Pair.new<_,_>(d, n),
  }

Nat.div(n: Nat, m: Nat): Nat
  Pair.fst<_,_>(Nat.div_mod(n, m))

Nat.mod(n: Nat, m: Nat): Nat
  Pair.snd<_,_>(Nat.div_mod(n, m))

Nat.double(n: Nat): Nat
  case n {
    zero: Nat.zero,
    succ: Nat.succ(Nat.double(n.pred)),
  }

// n >= m
Nat.gte(n: Nat, m: Nat): Bool
  Cmp.as_gte(Nat.cmp(n, m))

// n > m
Nat.gtn(n: Nat, m: Nat): Bool
  Cmp.as_gtn(Nat.cmp(n, m))

// n == m
Nat.eql(n: Nat, m: Nat): Bool
  Cmp.as_eql(Nat.cmp(n, m))

// n <= m
Nat.lte(n: Nat, m: Nat): Bool
  Cmp.as_lte(Nat.cmp(n, m))

// n < m
Nat.ltn(n: Nat, m: Nat): Bool
  Cmp.as_ltn(Nat.cmp(n, m))

Nat.show(n: Nat): String
  Nat.to_string_base(10,n)

Nat.show_digit(base: Nat, n: Nat) : Char
  let m = Nat.mod(n,base)
  def base64 =
    ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
    ,'G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V'
    ,'W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l'
    ,'m','n','o','p','q','r','s','t','u','v','w','x','y','z','+','/']
  if Bool.and(Nat.gtn(base,0),Nat.lte(base,64)) then 
    case List.at<>(m,base64) as c {
      none: '#',
      some: c.value
    }
  else '#'

Nat.to_u16(n: Nat): U16
  Nat.apply<U16>(n, U16.inc, U16.zero)

Bits.inc(a: Bits): Bits
  case a {
    nil: Bits.1(Bits.nil),
    0: Bits.1(a.pred),
    1: Bits.0(Bits.inc(a.pred)),
  }

Bits.add(a: Bits, b: Bits): Bits
  case b {
    nil: a,
    0: case a {
      nil: b,
      0: Bits.0(Bits.add(a.pred, b.pred)),
      1: Bits.1(Bits.add(a.pred, b.pred)),
    },
    1: case a {
      nil: b,
      0: Bits.1(Bits.add(a.pred, b.pred)),
      1: Bits.0(Bits.add(Bits.inc(a.pred), b.pred))
    }
  }

Bits.eql(a: Bits, b: Bits): Bool
  case a {
    nil: case b {
      nil: Bool.true,
       0 : Bool.false,
       1 : Bool.false,
    },
    0: case b {
      nil: Bool.false,
       0 : Bits.eql(a.pred, b.pred),
       1 : Bool.false,
    },
    1: case b {
      nil: Bool.false,
       0 : Bool.false,
       1 : Bits.eql(a.pred, b.pred),
    }
  }

Bits.tail(a: Bits): Bits
  case a {
    nil: Bits.nil,
    0: a.pred,
    1: a.pred,
  }

Bits.show(a: Bits): String
  case a {
    nil: "",
    0: String.cons('0', Bits.show(a.pred)),
    1: String.cons('1', Bits.show(a.pred)),
  }

Bits.reverse(a: Bits): Bits
  Bits.reverse.tco(a, Bits.nil)

Bits.reverse.tco(a: Bits, r: Bits): Bits
  case a {
    nil: r,
     0 : Bits.reverse.tco(a.pred, Bits.0(r)),
     1 : Bits.reverse.tco(a.pred, Bits.1(r))
  }

Bits.concat(a: Bits, b: Bits): Bits
  case a {
    nil: b,
    0: Bits.0(Bits.concat(a.pred, b)),
    1: Bits.1(Bits.concat(a.pred, b))
  }

Bits.chunks_of.go(
  len   : Nat,  // length of each chunk
  bits  : Bits, // bits to be split
  need  : Nat,  // number of vals to complete chunk
  chunk : Bits  // current chunk
) : List(Bits)
  case bits {
    nil: List.cons<>(Bits.reverse(chunk), List.nil<>),
    0: case need {
      zero: 
        let head = Bits.reverse(chunk)
        let tail = Bits.chunks_of.go(len, bits, len, Bits.nil)
        List.cons<>(head, tail),
      succ:
        let chunk = Bits.0(chunk)
        Bits.chunks_of.go(len, bits.pred, need.pred, chunk)
    },
    1: case need {
      zero:
        let head = Bits.reverse(chunk)
        let tail = Bits.chunks_of.go(len, bits, len, Bits.nil)
        List.cons<>(head, tail),
      succ:
        let chunk = Bits.1(chunk)
        Bits.chunks_of.go(len, bits.pred, need.pred, chunk)
    }
  }

Bits.chunks_of(len: Nat, bits: Bits): List(Bits)
  Bits.chunks_of.go(len, bits, len, Bits.nil)

Bits.to_nat(b: Bits): Nat
  case b {
    nil: 0,
     0 : Nat.mul(2, Bits.to_nat(b.pred)),
     1 : Nat.succ(Nat.mul(2, Bits.to_nat(b.pred)))
  }

Word.to_bits<size: Nat>(a: Word(size)): Bits
  case a {
    nil: Bits.nil,
    0: Bits.0(Word.to_bits<a.size>(a.pred)),
    1: Bits.1(Word.to_bits<a.size>(a.pred)),
  }

Word.from_bits(size: Nat, bits: Bits): Word(size)
  case size {
    zero: Word.nil,
    succ: case bits {
      nil: Word.0<size.pred>(Word.from_bits(size.pred, Bits.nil)),
       0 : Word.0<size.pred>(Word.from_bits(size.pred, bits.pred)),
       1 : Word.1<size.pred>(Word.from_bits(size.pred, bits.pred))
    } : Word(Nat.succ(size.pred))
  } : Word(size.self)

Word.zero(size: Nat): Word(size)
  case size {
    zero: Word.nil,
    succ: Word.0<size.pred>(Word.zero(size.pred))
  } : Word(size.self)

Word.adder<size: Nat>(a: Word(size), b: Word(size), c: Bool): Word(size)
  case a with b: Word(a.size) = b {
    nil: Word.nil,
    0 : case b with a.pred: Word(Nat.pred(b.size)) = a.pred {
      nil: Word.nil,
      0: case c {
        true : Word.1<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.false)),
        false: Word.0<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.false)),
      },
      1: case c {
        true:  Word.0<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.true)),
        false: Word.1<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.false)),
      }
    } : Word(b.size),
    1: case b with a.pred: Word(Nat.pred(b.size)) = a.pred {
      nil: Word.nil,
      0: case c {
        true : Word.0<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.true)),
        false: Word.1<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.false)),
      },
      1: case c {
        true : Word.1<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.true)),
        false: Word.0<b.size>(Word.adder<b.size>(a.pred, b.pred, Bool.true)),
      }
    } : Word(b.size)
  } : Word(a.size)

Word.cmp.go<size: Nat>(a: Word(size), b: Word(size), c: Cmp): Cmp
  case a with b : Word(a.size) = b {
    nil: c,
    0 : case b with a.pred : Word(Nat.pred(b.size)) = a.pred {
      nil: c,
      0  : Word.cmp.go<b.size>(a.pred, b.pred, c),
      1  : Word.cmp.go<b.size>(a.pred, b.pred, Cmp.ltn)
    },
    1: case b with a.pred : Word(Nat.pred(b.size)) = a.pred {
      nil: c,
      0  : Word.cmp.go<b.size>(a.pred, b.pred, Cmp.gtn),
      1  : Word.cmp.go<b.size>(a.pred, b.pred, c)
    }
  }

// Right fold a word
Word.fold<P: Nat -> Type, m: Nat>
(nil  : P(Nat.zero))
(w0   : <n: Nat> -> P(n) -> P(Nat.succ(n)))
(w1   : <n: Nat> -> P(n) -> P(Nat.succ(n)))
(word : Word(m))
: P(m)
  case word {
    nil: nil,
     0 : w0<word.size>(Word.fold<P,word.size>(nil, w0, w1, word.pred)),
     1 : w1<word.size>(Word.fold<P,word.size>(nil, w0, w1, word.pred))
  } : P(word.size)

// Left fold a word
Word.foldl<P: Nat -> Type, m: Nat>
(nil  : P(Nat.zero))
(w0   : <n: Nat> -> P(n) -> P(Nat.succ(n)))
(w1   : <n: Nat> -> P(n) -> P(Nat.succ(n)))
(word : Word(m))
: P(m)
  case word {
    nil: nil,
    0: 
      def P   = (n) P(Nat.succ(n))
      def nil = w0<Nat.zero>(nil)
      def w0  = <x> w0<Nat.succ(x)>
      def w1  = <x> w1<Nat.succ(x)>
      Word.foldl<P, word.size>(nil, w0, w1, word.pred),
    1: 
      def P   = (n) P(Nat.succ(n))
      def nil = w1<Nat.zero>(nil)
      def w0  = <x> w0<Nat.succ(x)>
      def w1  = <x> w1<Nat.succ(x)>
      Word.foldl<P, word.size>(nil, w0, w1, word.pred)
  } : P(word.size)

Word.trim<size: Nat>(new_size: Nat, word: Word(size)): Word(new_size)
  case new_size {
    zero: Word.nil,
    succ: case word {
      nil: Word.0<new_size.pred>(Word.trim<Nat.zero>(new_size.pred, Word.nil)),
       0 : Word.0<new_size.pred>(Word.trim<word.size>(new_size.pred, word.pred)),
       1 : Word.1<new_size.pred>(Word.trim<word.size>(new_size.pred, word.pred))
    }
  } : Word(new_size.self)

// a - b
Word.subber<size: Nat>(a: Word(size), b: Word(size), c: Bool): Word(size)
  case a with b: Word(a.size) = b {
    nil: Word.nil,
    0 : case b with a.pred: Word(Nat.pred(b.size)) = a.pred {
      nil: Word.nil,
      0: case c {
        true : Word.1<b.size>(Word.subber<b.size>(a.pred, b.pred, Bool.true)),
        false: Word.0<b.size>(Word.subber<b.size>(a.pred, b.pred, Bool.false)),
      },
      1: case c {
        true:  Word.0<b.size>(Word.subber<b.size>(a.pred, b.pred, Bool.true)),
        false: Word.1<b.size>(Word.subber<b.size>(a.pred, b.pred, Bool.true)),
      }
    } : Word(b.size),
    1: case b with a.pred: Word(Nat.pred(b.size)) = a.pred {
      nil: Word.nil,
      0: case c {
        true : Word.0<b.size>(Word.subber<b.size>(a.pred, b.pred, Bool.false)),
        false: Word.1<b.size>(Word.subber<b.size>(a.pred, b.pred, Bool.false)),
      },
      1: case c {
        true : Word.1<b.size>(Word.subber<b.size>(a.pred, b.pred, Bool.true)),
        false: Word.0<b.size>(Word.subber<b.size>(a.pred, b.pred, Bool.false)),
      }
    } : Word(b.size)
  } : Word(a.size)

// ++a
Word.inc<size: Nat>(word: Word(size)): Word(size)
  case word {
    nil: Word.nil,
     0 : Word.1<word.size>(word.pred),
     1 : Word.0<word.size>(Word.inc<word.size>(word.pred))
  } : Word(word.size)

// a + b
Word.add<size: Nat>(a: Word(size), b: Word(size)): Word(size)
  Word.adder<size>(a)(b)(Bool.false)

// a - b
Word.sub<size: Nat>(a: Word(size), b: Word(size)): Word(size)
  Word.subber<size>(a, b, Bool.false)

// a ? b
Word.cmp<size: Nat>(a: Word(size), b: Word(size)): Cmp
  Word.cmp.go<size>(a, b, Cmp.eql)

// a <= b
Word.lte<size:Nat>(a: Word(size), b: Word(size)): Bool
  Cmp.as_lte(Word.cmp<size>(a, b))

// a < b
Word.ltn<size:Nat>(a: Word(size), b: Word(size)): Bool
  Cmp.as_ltn(Word.cmp<size>(a, b))

// a == b
Word.eql<size:Nat>(a: Word(size), b: Word(size)): Bool
  Cmp.as_eql(Word.cmp<size>(a, b))

// a >= b
Word.gte<size:Nat>(a: Word(size), b: Word(size)): Bool
  Cmp.as_gte(Word.cmp<size>(a, b))

// a > b
Word.gtn<size:Nat>(a: Word(size), b: Word(size)): Bool
  Cmp.as_gtn(Word.cmp<size>(a, b))

// a <= b <= c
Word.btw<size:Nat>(a: Word(size), b: Word(size), c: Word(size)): Bool
  Bool.and(Word.lte<size>(a, b), Word.lte<size>(b, c))

U16.to_word(a: U16): Word(16)
  open a
  a.value

// 0
U16.zero: U16
  U16.new(Word.zero(16))

// ++a
U16.inc(a: U16): U16
  get a_val = a 
  U16.new(Word.inc<>(a_val))

// a + b
U16.add(a: U16, b: U16): U16
  get a_val = a 
  get b_val = b 
  U16.new(Word.add<>(a_val, b_val))

// a - b
U16.sub(a: U16, b: U16): U16
  get a_val = a
  get b_val = b 
  U16.new(Word.sub<>(a_val, b_val))  

// a == b
U16.eql(a: U16, b: U16): Bool
  open a
  open b
  Word.eql<>(a.value, b.value)

// a >= b
U16.gte(a: U16, b: U16): Bool
  get a_val = a
  get b_val = b 
  Word.gte<>(a_val, b_val)

// a > b
U16.gtn(a: U16, b: U16): Bool
  get a_val = a
  get b_val = b 
  Word.gtn<>(a_val, b_val)

// a <= b
U16.lte(a: U16, b: U16): Bool
  get a_val = a
  get b_val = b 
  Word.lte<>(a_val, b_val)

// a < b
U16.ltn(a: U16, b: U16): Bool
  get a_val = a
  get b_val = b 
  Word.ltn<>(a_val, b_val)

// a <= b <= c
U16.btw(a: U16, b: U16, c: U16): Bool
  Bool.and(U16.lte(a, b), U16.lte(b, c))

Maybe.mapped<A: Type>(m: Maybe(A))<B: Type>(f: A -> B): Maybe(B)
  case m {
    none: Maybe.none<B>,
    some: Maybe.some<B>(f(m.value)),
  }

Maybe.pure<A: Type>(a: A): Maybe(A)
  Maybe.some<A>(a)

Maybe.bind<A: Type, B: Type>(m: Maybe(A), f: A -> Maybe(B)): Maybe(B)
  case m {
    none: Maybe.none<B>,
    some: f(m.value),
  }

Maybe.monad: Monad(Maybe)
  Monad.new<Maybe>(Maybe.bind, Maybe.some)

Maybe.default<A: Type>(a: A, m: Maybe(A)): A
  case m {
    none: a,
    some: m.value,
  }

Maybe.to_bool<A: Type>(m: Maybe(A)): Bool
  case m {
    none: Bool.false,
    some: Bool.true,
  }

Pair.fst<A: Type, B: Type>(pair: Pair(A, B)): A
  case pair {
    new: pair.fst
  }

Pair.snd<A: Type, B: Type>(pair: Pair(A, B)): B
  case pair {
    new: pair.snd
  }

List.fold<A: Type>(list: List(A)): <P: Type> -> P -> (A -> P -> P) -> P
  <P> (nil, cons)
  case list {
    nil : nil,
    cons: cons(list.head, List.fold<A>(list.tail)<P>(nil, cons))
  }

List.for<A: Type>(xs: List(A))<B: Type>(b: B, f: A -> B -> B): B
  case xs {
    nil : b,
    cons: List.for<A>(xs.tail)<B>(f(xs.head,b),f)
  }

List.map<A: Type, B: Type>(f: A -> B, as: List(A)): List(B)
  case as {
    nil : List.nil<>,
    cons: List.cons<>(f(as.head),List.map<,>(f,as.tail))
  }

List.reverse<A: Type>(xs: List(A)) : List(A)
  List.reverse.go<>(xs,List.nil<>)

List.reverse.go<A: Type>(xs: List(A), res: List(A)): List(A)
  case xs {
    nil : res,
    cons: List.reverse.go<>(xs.tail,List.cons<>(xs.head,res))
  }

List.concat<A: Type>(as: List(A), bs: List(A)): List(A)
  case as {
    nil : bs,
    cons: List.cons<>(as.head, List.concat<>(as.tail,bs))
  }

List.flatten<A: Type>(xs: List(List(A))): List(A)
  case xs {
    nil : List.nil<>,
    cons: List.concat<>(xs.head, List.flatten<>(xs.tail))
  }

// Computes the length of the list.
List.length<A: Type>(xs: List(A)): Nat
  List.length.go<>(xs, 0)

// Computes the length of the list.
List.length.go<A: Type>(xs: List(A), n: Nat): Nat
  case xs {
    nil : n,
    cons: List.length.go<A>(xs.tail, Nat.succ(n))
  }

List.eql<A: Type>(eql: A -> A -> Bool, a: List(A), b: List(A)): Bool
  case a {
    nil: case b {
      nil: Bool.true,
      cons: Bool.false,
    },
    cons: case b {
      nil: Bool.false,
      cons: Bool.and(eql(a.head, b.head), List.eql<A>(eql, a.tail, b.tail)),
    },
  }

List.mapped<A: Type>(as: List(A))<B: Type>(f: A -> B): List(B)
  case as {
    nil : List.nil<>,
    cons: List.cons<>(f(as.head),List.mapped<A>(as.tail)<B>(f))
  }

List.at<A: Type>(index: Nat, list: List(A)): Maybe(A)
  case list {
    nil: Maybe.none<>,
    cons: case index {
      zero: Maybe.some<>(list.head),
      succ: List.at<>(index.pred, list.tail),
    }
  }

List.at_last<A: Type>(index: Nat, list: List(A)): Maybe(A)
  List.at<A>(index, List.reverse<>(list))

Map.fold<A: Type>(map: Map(A)): <P: Type> -> P -> (Maybe(A) -> P -> P -> P) -> P
  <P> (new, tie)
  case map {
    new: new,
    tie: 
      tie
      | map.val;
      | Map.fold<A>(map.lft)<P>(new, tie); 
      | Map.fold<A>(map.rgt)<P>(new, tie);
  }

Map.from_list<A: Type, B: Type>(f: A -> Bits, xs: List(Pair(A,B))) : Map(B)
  case xs {
    nil : Map.new<>,
    cons: case xs.head as p {
      new: Map.set<>(f(p.fst), p.snd, Map.from_list<,>(f, xs.tail))
    }
  }

Map.get<A: Type>(bits: Bits, map: Map(A)): Maybe(A)
  case bits {
    nil: case map {
      new: Maybe.none<>,
      tie: map.val
    }, 
    0: case map {
      new: Maybe.none<>,
      tie: Map.get<>(bits.pred, map.lft)
    },
    1: case map {
      new: Maybe.none<>,
      tie: Map.get<>(bits.pred, map.rgt)
    }
  }

Map.set<A: Type>(bits: Bits, val: A, map: Map(A)): Map(A)
  case bits {
    nil: case map {
      new: Map.tie<>(Maybe.some<>(val), Map.new<>, Map.new<>),
      tie: Map.tie<>(Maybe.some<>(val), map.lft, map.rgt)
    },
    0: case map {
      new: Map.tie<>(Maybe.none<>, Map.set<>(bits.pred, val, Map.new<>), Map.new<>),
      tie: Map.tie<>(map.val, Map.set<>(bits.pred, val, map.lft), map.rgt)
    },
    1: case map {
      new: Map.tie<>(Maybe.none<>, Map.new<>, Map.set<>(bits.pred, val, Map.new<>)),
      tie: Map.tie<>(map.val, map.lft, Map.set<>(bits.pred, val, map.rgt))
    }
  }

Map.delete<A: Type>(key: Bits, map: Map(A)) : Map(A)
  case map {
    new: Map.new<>,
    tie: case key {
      nil: Map.tie<>(Maybe.none<>, map.lft, map.rgt),
       0 : Map.delete<>(key.pred, map.lft),
       1 : Map.delete<>(key.pred, map.rgt)
    }
  }

Map.to_list<A: Type>(xs: Map(A)): List(Pair(Bits,A))
  List.reverse<>(Map.to_list.go<>(xs, Bits.nil, List.nil<>))

Map.to_list.go<A: Type>(xs: Map(A), key: Bits, list: List(Pair(Bits,A))): List(Pair(Bits,A))
  case xs {
    new: list,
    tie: 
      let list0 = case xs.val {
        none: list,
        some: List.cons<>(Pair.new<_,_>(Bits.reverse(key), xs.val.value), list),
      }
      let list1 = Map.to_list.go<>(xs.lft, Bits.0(key), list0)
      let list2 = Map.to_list.go<>(xs.rgt, Bits.1(key), list1)
      list2
  }

Set.new: Set
  Map.new<Unit>

Set.del<A: Type>(key: Bits, set: Set): Set
  Map.delete<Unit>(key, set)

Set.set(bits: Bits, set: Set): Set
  Map.set<Unit>(bits, Unit.new, set)

Set.has(bits: Bits, set: Set): Bool
  case Map.get<Unit>(bits, set) {
    none: Bool.false,
    some: Bool.true,
  }

Char.new
  (b0: Bit) (b1: Bit) (b2: Bit) (b3: Bit)
  (b4: Bit) (b5: Bit) (b6: Bit) (b7: Bit)
  (b8: Bit) (b9: Bit) (bA: Bit) (bB: Bit)
  (bC: Bit) (bD: Bit) (bE: Bit) (bF: Bit)
  : U16
  let kF = b0<() Word(0) -> Word(1)>(Word.0<>, Word.1<>)
  let kE = b1<() Word(1) -> Word(2)>(Word.0<>, Word.1<>)
  let kD = b2<() Word(2) -> Word(3)>(Word.0<>, Word.1<>)
  let kC = b3<() Word(3) -> Word(4)>(Word.0<>, Word.1<>)
  let kB = b4<() Word(4) -> Word(5)>(Word.0<>, Word.1<>)
  let kA = b5<() Word(5) -> Word(6)>(Word.0<>, Word.1<>)
  let k9 = b6<() Word(6) -> Word(7)>(Word.0<>, Word.1<>)
  let k8 = b7<() Word(7) -> Word(8)>(Word.0<>, Word.1<>)
  let k7 = b8<() Word(8) -> Word(9)>(Word.0<>, Word.1<>)
  let k6 = b9<() Word(9) -> Word(10)>(Word.0<>, Word.1<>)
  let k5 = bA<() Word(10) -> Word(11)>(Word.0<>, Word.1<>)
  let k4 = bB<() Word(11) -> Word(12)>(Word.0<>, Word.1<>)
  let k3 = bC<() Word(12) -> Word(13)>(Word.0<>, Word.1<>)
  let k2 = bD<() Word(13) -> Word(14)>(Word.0<>, Word.1<>)
  let k1 = bE<() Word(14) -> Word(15)>(Word.0<>, Word.1<>)
  let k0 = bF<() Word(15) -> Word(16)>(Word.0<>, Word.1<>)
  let kx = Word.nil
  U16.new(k0(k1(k2(k3(k4(k5(k6(k7(k8(k9(kA(kB(kC(kD(kE(kF(kx)))))))))))))))))

String.is_empty(str: String): Bool
  case str {
    nil: Bool.true,
    cons: Bool.false,
  }

String.concat(as: String, bs: String): String
  case as {
    nil: bs,
    cons: String.cons(as.head, String.concat(as.tail,bs)),
  }

String.join.go(sep: String, list: List(String), fst: Bool): String
  case list {
    nil: "",
    cons: String.flatten([
      if fst then "" else sep,
      list.head, 
      String.join.go(sep, list.tail, Bool.false),
    ]),
  }
  
String.join(sep: String, list: List(String)): String
  String.join.go(sep, list, Bool.true)

String.flatten.go(xs: List(String), res: String): String
  case xs {
    nil: res,
    cons: String.flatten.go(xs.tail, String.concat(res, xs.head)),
  }

String.flatten(xs: List(String)): String
  String.flatten.go(xs, "")

Monad.pure<M: Type -> Type>(m: Monad(M)): <A: Type> -> A -> M(A)
  case m {
    new: m.pure
  }

Monad.bind<M: Type -> Type>(m: Monad(M)): <A: Type, B: Type> -> M(A) -> (A -> M(B)) -> M(B)
  case m {
    new: m.bind
  }

IO.bind<A: Type, B: Type>(a: IO(A), f: A -> IO(B)): IO(B)
  case a {
    end: f(a.value),
    ask: IO.ask<B>(a.query, a.param, (x) IO.bind<A,B>(a.then(x), f)),
  }

IO.get_line: IO(String)
  use line = IO.ask<String>("get_line", "")
  IO.end<String>(line)

IO.monad: Monad(IO)
  Monad.new<IO>(IO.bind, IO.end)

IO.print(text: String): IO(Unit)
  use skip = IO.ask<Unit>("print", text)
  IO.end<Unit>(Unit.new)

IO.prompt(text: String): IO(String)
  use skip = IO.ask<String>("print", text)
  use line = IO.ask<String>("get_line", "")
  IO.end<String>(line)

// A parser is a function that receives a string and returns a reply
Parser(V: Type): Type
  String -> Parser.Reply(V)

// Parser monadic binder
Parser.bind<A: Type, B: Type>(parse: Parser(A), next: A -> Parser(B)): Parser(B)
  (code) case parse(code) as reply {
    error: Parser.Reply.error<B>(reply.code, reply.error),
    value: next(reply.value, reply.code),
  }

// Parser monadic injection
Parser.pure<V: Type>(value: V): Parser(V)
  (code) Parser.Reply.value<V>(code, value)

// Perser monad
Parser.monad: Monad(Parser)
  Monad.new<Parser>(Parser.bind, Parser.pure)

// Consumes a specific text, returns the remaining code
Parser.text.go(text: String): Parser(Unit)
  (code) case text {
    nil:
      Parser.Reply.value<Unit>(code, Unit.new),
    cons: case code {
      nil:
        let error = String.flatten(["Expected '", text, "', found end of file."])
        Parser.Reply.error<Unit>(code, error)
      cons:
        if U16.eql(text.head, code.head) then
          Parser.text(text.tail, code.tail)
        else
          let error = String.flatten(["Expected '", text, "', found '", String.cons(code.head, String.nil), "'."])
          Parser.Reply.error<Unit>(code, error)
    }
  }

Parser.text(text: String): Parser(Unit)
  (code) case Parser.text.go(text, code) as reply {
    error: Parser.Reply.error<Unit>(code, reply.error),
    value: Parser.Reply.value<Unit>(reply.code, reply.value),
  }

Parser.one: Parser(Char)
  (code) case code {
    nil: Parser.Reply.error<Char>(code, "Unexpected end of file."),
    cons: Parser.Reply.value<Char>(code.tail, code.head),
  }
  
Parser.if_not<A: Type>(a: Parser(Unit), b: Parser(A)): Parser(A)
  (code) case a(code) {
    error: b(code),
    value: Parser.Reply.error<A>(code, "Prevented."),
  }

// Repeats a parse until it fails, returns a list of results
Parser.many<V: Type>(parser: Parser(V)): Parser(List(V))
  Parser.many.go<V>(parser, (x) x)

Parser.many.go<V: Type>(parse: Parser(V), values: List(V) -> List(V), code: String): Parser.Reply(List(V))
  case parse(code) as reply {
    error: Parser.Reply.value<List(V)>(code, values([])),
    value: Parser.many.go<V>(parse, (xs) values(List.cons<>(reply.value, xs)), reply.code),
  }

// Same as Parser.many, but parses at least one instance
Parser.many1<V: Type>(parser: Parser(V)): Parser(List(V))
  do Parser {
    var head = parser;
    var tail = Parser.many<V>(parser);
    return List.cons<V>(head, tail);
  }

Parser.until<A: Type>(cond: Parser(Unit), parser: Parser(A)): Parser(List(A))
  Parser.many<>(Parser.if_not<_>(cond, parser))

// Parses an optional
Parser.maybe<V: Type>(parse: Parser(V)): Parser(Maybe(V))
  (code) case parse(code) as reply {
    error: Parser.Reply.value<Maybe(V)>(code, Maybe.none<V>),
    value: Parser.Reply.value<Maybe(V)>(reply.code, Maybe.some<V>(reply.value)),
  }

// Parses the first in a list
Parser.first_of<A: Type>(pars: List(Parser(A))): Parser(A)
  (code) case pars {
    nil: Parser.Reply.error<>(code, "No parse."),
    cons:
      let parsed = pars.head(code)
      case parsed {
        error: Parser.first_of<>(pars.tail, code),
        value: Parser.Reply.value<>(parsed.code, parsed.value),
      }
  }

// Skips whitespaces
Parser.spaces: Parser(List(Unit))
  Parser.many<>(Parser.first_of<>([
    Parser.text(" "),
    Parser.text("\n")
  ]))

// Parses spaces then a text
Parser.spaces_text(text: String): Parser(Unit)
  do Parser {
    Parser.spaces;
    Parser.text(text);
  }

// Parses a character
Parser.char_if(fun: Char -> Bool): Parser(Char)
  (code) case code {
    nil: Parser.Reply.error<>(code, "No parse."),
    cons:
      if fun(code.head) then
        Parser.Reply.value<>(code.tail, code.head)
      else
        Parser.Reply.error<>(code, "No parse."),
  }

// Parses a digit: `[0123456789]`
Parser.digit: Parser(Nat)
  (code) case code {
    nil: Parser.Reply.error<>(code, "No parse."),
    cons:
      if      U16.eql(code.head, '0') then Parser.Reply.value<>(code.tail, 0)
      else if U16.eql(code.head, '1') then Parser.Reply.value<>(code.tail, 1)
      else if U16.eql(code.head, '2') then Parser.Reply.value<>(code.tail, 2)
      else if U16.eql(code.head, '3') then Parser.Reply.value<>(code.tail, 3)
      else if U16.eql(code.head, '4') then Parser.Reply.value<>(code.tail, 4)
      else if U16.eql(code.head, '5') then Parser.Reply.value<>(code.tail, 5)
      else if U16.eql(code.head, '6') then Parser.Reply.value<>(code.tail, 6)
      else if U16.eql(code.head, '7') then Parser.Reply.value<>(code.tail, 7)
      else if U16.eql(code.head, '8') then Parser.Reply.value<>(code.tail, 8)
      else if U16.eql(code.head, '9') then Parser.Reply.value<>(code.tail, 9)
      else Parser.Reply.error<>(code, "No parse."),
  }

// Parses a natural number
Parser.nat: Parser(Nat)
  do Parser {
    var digits = Parser.many1<Nat>(Parser.digit);
    return Nat.from_base(10, digits);
  }

// Gets the current code
Parser.get_code: Parser(String)
  (code) Parser.Reply.value<>(code, code)

// Gets the current code
Parser.log_code: Parser(Unit)
  (code) Debug.log<>(code, () Parser.Reply.value<>(code, Unit.new))

// Parses something
Parser.log(str: String): Parser(Unit)
  (code) Debug.log<>(str, () Parser.Reply.value<>(code, Unit.new))

// Logs to the console
Debug.log<A: Type>(s: String, x: Unit -> A): A
  x(Unit.new)

// Types
// =====

// A Formality Letter is a 6-bit value:
//  0-25 is A-Z
// 26-51 is a-z
// 52-61 is 0-9
//    62 is .
//    63 is _
Fm.Letter: Type
  Char

// A Formality Name is a list of letters
Fm.Name: Type
  String

// A Formality term (high-order)
type Fm.Term {
  // A variable bound by another constructor
  var(
    name: Fm.Name, // the variable name, used for pretty printing
    indx: Nat, // the variable bruijn level, used for equality and binding
  ),
  // A reference to a top-level definition
  ref(
    name: Fm.Name, // the reference name
  ),
  // The type of types
  typ,
  // The self-dependent function type (self-Pi)
  all(
    eras: Bool, // if it is erased at runtime
    self: Fm.Name, // the term name
    name: Fm.Name, // the input name
    xtyp: Fm.Term, // the input type
    body: Fm.Term -> Fm.Term -> Fm.Term, // the returned type
  ),
  // An anonymous function (lambda)
  lam(
    name: Fm.Name, // the input name
    body: Fm.Term -> Fm.Term, // the returned body
  ),
  // A function application
  app(
    func: Fm.Term, // the function
    argm: Fm.Term, // the argument
  ),
  // A local definition
  let(
    name: Fm.Name, // the expression name
    expr: Fm.Term, // the expression value
    body: Fm.Term -> Fm.Term, // the body where name=value
  ),
  // An inline annotation
  ann(
    done: Bool, // was this type-checked?
    term: Fm.Term, // the annotated term
    type: Fm.Term, // the annotated type
  ),
  // A hole to show the goal
  gol(
    name: Fm.Name, // the goal's name
    dref: List(Bits), // a list of labels to expand when displaying it
    verb: Bool, // show labels of expandable terms?
  ),
  // A hole to be auto-filled
  hol(
    path: Bits,
  ),
  // A natural number
  nat(
    natx: Nat,
  ),
  // A character
  chr(
    chrx: Char,
  ),
  // A string
  str(
    strx: String,
  ),
  // A syntax sugar
  sug(
    sugx: Fm.Sugar,
  ),
}

// A syntax sugar
type Fm.Sugar {
  // A named application `f(x: 1, y: 2, z: 3)`
  app(
    func: Fm.Term,
    args: Map(Fm.Term),
  ),
  // A case-of: `case f(x) as k with a:A = X; { zero: x, succ: y } : T`
  cse(
    expr: Fm.Term,
    name: Fm.Name,
    with: List(Fm.Def),
    cses: Map(Fm.Term),
    moti: Fm.Term,
  ),
}

// A compilable term intermediate format
type Fm.Comp {
  nil,
  var(name: Fm.Name),
  ref(name: Fm.Name),
  lam(name: Fm.Name, body: Fm.Comp),
  app(func: Fm.Comp, argm: Fm.Comp),
  let(name: Fm.Name, expr: Fm.Comp, body: Fm.Comp),
}

// A constructor
type Fm.Constructor {
  new(
    name: Fm.Name,
    args: List(Fm.Binder),
    inds: List(Fm.Binder),
  )
}

// An algebraic datatype
type Fm.Datatype {
  new(
    name: Fm.Name,
    pars: List(Fm.Binder),
    inds: List(Fm.Binder),
    ctrs: List(Fm.Constructor),
  )
}

// A type error
type Fm.Error {
  // Two types do not match
  type_mismatch(
    expected: Either(String, Fm.Term),
    detected: Either(String, Fm.Term),
    context: Fm.Context,
  ),
  // Found a goal to be shown
  show_goal(
    name: Fm.Name,
    dref: List(Bits),
    verb: Bool,
    goal: Maybe(Fm.Term),
    context: Fm.Context,
  ),
  // Patch the original term
  patch(
    path: Bits,
    term: Fm.Term,
  ),
  // Some reference isn't found
  undefined_reference(
    name: Fm.Name,
  ),
  // A lambda without a type
  cant_infer(
    term: Fm.Term,
    context: Fm.Context,
  ),
}

// The result of a type-checking attempt
type Fm.Check<V: Type> {
  result(
    value: Maybe(V), // the returned value
    errors: List(Fm.Error), // a list of errors
  ),
}

// A top-level definition
type Fm.Def {
  new(
    name: Fm.Name,
    term: Fm.Term,
    type: Fm.Term,
    done: Bool,
  ),
}

type Fm.Binder {
  new(
    eras: Bool,
    name: Fm.Name,
    term: Fm.Term,
  )
}

// A map from Names to definitions
Fm.Defs: Type
  Map(Fm.Def)

// A context is a list of (name, term) pairs
Fm.Context: Type
  List(Pair(Fm.Name,Fm.Term))

// A path
Fm.Path: Type
  Bits -> Bits

// Maybe a path
Fm.MPath: Type
  Maybe(Fm.Path)

// Paths
// =====

Fm.Path.to_bits(path: Fm.Path): Bits
  path(Bits.nil)

Fm.Path.nil: Fm.Path
  (x) x

Fm.Path.0(path: Fm.Path): Fm.Path
  (x) path(Bits.0(x))

Fm.Path.1(path: Fm.Path): Fm.Path
  (x) path(Bits.1(x))

Fm.MPath.to_bits(path: Maybe(Fm.Path)): Bits
  case path {
    none: Bits.nil,
    some: path.value(Bits.nil),
  }

Fm.MPath.nil: Maybe(Fm.Path)
  Maybe.some<>(Fm.Path.nil)

Fm.MPath.0(path: Maybe(Fm.Path)): Maybe(Fm.Path)
  Maybe.mapped<>(path)<>(Fm.Path.0)

Fm.MPath.1(path: Maybe(Fm.Path)): Maybe(Fm.Path)
  Maybe.mapped<>(path)<>(Fm.Path.1)

//// Contexts
//// ========

// Gets a core term from a map by its name
Fm.get<A: Type>(name: Fm.Name, map: Map(A)): Maybe(A)
  Map.get<A>(Fm.Name.to_bits(name), map)

// Adds a name, core term pair to a map
Fm.set<A: Type>(name: Fm.Name, val: A, map: Map(A)): Map(A)
  Map.set<A>(Fm.Name.to_bits(name), val, map)

// Finds a value in a context
Fm.Context.find(name: Fm.Name, ctx: Fm.Context): Maybe(Fm.Term)
  case ctx {
    nil:
      Maybe.none<>,
    cons:
      open ctx.head
      if Fm.Name.eql(name, ctx.head.fst) then
        Maybe.some<>(ctx.head.snd)
      else
        Fm.Context.find(name, ctx.tail)
  }

// Gets the names of a context
Fm.Context.names(ctx: Fm.Context): List(Fm.Name)
  List.mapped<>(ctx)<>((x) Pair.fst<_,_>(x))

// Stringification
// ===============

// Stringifies an error
Fm.Error.show(error: Fm.Error, defs: Fm.Defs): String
  case error {
    type_mismatch: 
      let expected = case error.expected {
        left: error.expected.value,
        right: Fm.Term.show(Fm.Term.normalize(error.expected.value, Map.new<>)),
      }
      let detected = case error.detected {
        left: error.detected.value,
        right: Fm.Term.show(Fm.Term.normalize(error.detected.value, Map.new<>)),
      }
      let context = Fm.Context.show(error.context)
      String.flatten([
        "Type mismatch.\n",
        "- Expected: ", expected, "\n",
        "- Detected: ", detected, "\n",
        "With context:\n", context,
      ]),
    show_goal:
      let goal_name = String.flatten([
        "Goal ?",
        Fm.Name.show(error.name),
        ":\n",
      ])
      let with_type = case error.goal {
        none: "",
        some: 
          let goal = Fm.Term.expand(error.dref, error.goal.value, defs)
          String.flatten([
            "With type: ",
            if error.verb then
              Fm.Term.show.go(goal, Maybe.some<>((x) x))
            else
              Fm.Term.show(goal),
            "\n",
          ]),
      }
      let with_ctxt = String.flatten([
        "With ctxt:\n",
        Fm.Context.show(error.context),
      ])
      String.flatten([goal_name, with_type, with_ctxt]),
    patch:
      String.flatten([
        "Patching: ", Fm.Term.show(error.term),
      ]),
    undefined_reference: 
      String.flatten([
        "Undefined reference: ", Fm.Name.show(error.name)
      ]),
    cant_infer:
      let term = Fm.Term.show(error.term)
      let context = Fm.Context.show(error.context)
      String.flatten([
        "Can't infer type of: ", term, "\n",
        "With ctxt:\n", context,
      ])
  }

// Stringifies a context
Fm.Context.show(context: Fm.Context): String
  case context {
    nil: "",
    cons: case context.head {
      new:
        let name = Fm.Name.show(context.head.fst)
        let type = Fm.Term.show(context.head.snd)
        let rest = Fm.Context.show(context.tail)
        String.flatten([
          rest,
          if String.is_empty(rest) then "" else "\n",
          "- ",
          name,
          ": ",
          type,
        ])
    }
  }

// SHOW: Stringifies a term
Fm.Term.show.go(term: Fm.Term, path: Maybe(Bits -> Bits)): String
  case term {
    ref:
      let name = Fm.Name.show(term.name)
      case path {
        none:
          name,
        some: 
          let path_val = Bits.concat(Fm.Path.to_bits(path.value), Bits.1(Bits.nil))
          let path_str = Nat.show(Bits.to_nat(path_val))
          String.flatten([name, "\x1b[2m-", path_str, "\x1b[0m"]),
      }
    var:
      Fm.Name.show(term.name),
    typ:
      "Type",
    all:
      let eras = term.eras
      let self = Fm.Name.show(term.self)
      let name = Fm.Name.show(term.name)
      let type = Fm.Term.show.go(term.xtyp, Fm.MPath.0(path))
      let open = if eras then "<" else "("
      let clos = if eras then ">" else ")"
      let body = Fm.Term.show.go(
        term.body(
          Fm.Term.var(term.self, 0),
          Fm.Term.var(term.name, 0)),
        Fm.MPath.1(path))
      String.flatten([self,open,name,":",type,clos," ",body]),
    lam:
      let name = Fm.Name.show(term.name)
      let body = Fm.Term.show.go(
        term.body(Fm.Term.var(term.name, 0)),
        Fm.MPath.0(path))
      String.flatten(["(",name,") ",body]),
    app:
      let func = Fm.Term.show.go(term.func, Fm.MPath.0(path))
      let argm = Fm.Term.show.go(term.argm, Fm.MPath.1(path))
      let wrap = case func {nil: Bool.false, cons: U16.eql(func.head,'(')}
      if wrap then
        String.flatten(["(",func,")","(",argm,")"])
      else
        String.flatten([func,"(",argm,")"]),
    let:
      let name = Fm.Name.show(term.name)
      let expr = Fm.Term.show.go(term.expr, Fm.MPath.0(path))
      let body = Fm.Term.show.go(
        term.body(Fm.Term.var(term.name, 0)),
        Fm.MPath.1(path))
      String.flatten(["let ", name, " = ", expr, "; ", body]),
    ann:
      let term = Fm.Term.show.go(term.term, Fm.MPath.0(path))
      let type = Fm.Term.show.go(term.type, Fm.MPath.1(path))
      String.flatten([term,"::",type]),
    gol:
      let name = Fm.Name.show(term.name)
      String.flatten(["?", name]),
    hol:
      //let path = Bits.show(term.path)
      "_",
    nat:
      String.flatten([Nat.show(term.natx)]),
    chr:
      String.cons(term.chrx, String.nil),
    str:
      String.flatten(["\"", term.strx, "\""]),
    sug:
      case term.sugx {
        app:
          let func = Fm.Term.show.go(term.sugx.func, Fm.MPath.0(path))
          let args = Map.to_list<>(term.sugx.args)
          let args = List.mapped<>(args)<>((x) case x {
            new: String.flatten([
              Fm.Name.show(Fm.Name.from_bits(x.fst)),
              ": ",
              Fm.Term.show.go(x.snd, Maybe.none<>),
            ])
          })
          let args = String.join(", ", args)
          let wrap = case func {nil: Bool.false, cons: U16.eql(func.head,'(')}
          if wrap then
            String.flatten(["(",func,")","(",args,")"])
          else
            String.flatten([func,"(",args,")"]),
        cse:
          let expr = Fm.Term.show.go(term.sugx.expr, Fm.MPath.0(path))
          let name = Fm.Name.show(term.sugx.name)
          let with = String.join("", List.mapped<>(term.sugx.with)<>((def)
            case def {
              new:
                let name = Fm.Name.show(def.name)
                let type = Fm.Term.show.go(def.type, Maybe.none<>)
                let term = Fm.Term.show.go(def.term, Maybe.none<>)
                String.flatten([name, ": ", type, " = " term, ";"])
            }))
          let cses = Map.to_list<>(term.sugx.cses)
          let cses = String.join("", List.mapped<>(cses)<>((x)
            let name = Fm.Name.show(Fm.Name.from_bits(Pair.fst<_,_>(x)))
            let term = Fm.Term.show.go(Pair.snd<_,_>(x), Maybe.none<>)
            String.flatten([name, ": ", term, "; "])))
          let moti = Fm.Term.show.go(term.sugx.moti, Maybe.none<>)
          String.flatten(["case ",expr," as ",name,with," { ",cses,"} : ",moti])
      },
  }

Fm.Term.show(term: Fm.Term): String
  Fm.Term.show.go(term, Maybe.none<>)

// Stringifies a defs
Fm.Defs.show(defs: Fm.Defs): String
  let str = ""
  for name_def in Map.to_list<>(defs) with str:
    get name def = name_def
    open def
    String.flatten([
      str,
      Fm.Name.show(Fm.Name.from_bits(name)),
      ": ",
      Fm.Term.show(def.type),
      "\n  ",
      Fm.Term.show(def.term),
      "\n",
    ])

// Reduction
// =========

// BIND: Binds named variables to their lambdas
Fm.Term.bind(vars: Fm.Context, path: Fm.Path, term: Fm.Term): Fm.Term 
  case term {
    ref: case Fm.Context.find(term.name, vars) as got {
      none: Fm.Term.ref(term.name),
      some: got.value,
    },
    var: case List.at_last<>(term.indx, vars) as got {
      none: Fm.Term.var(term.name, term.indx),
      some: Pair.snd<_,_>(got.value),
    },
    all: 
      let vlen = List.length<>(vars)
      def xtyp = Fm.Term.bind(vars, Fm.Path.0(path), term.xtyp)
      def body = (s,x) Fm.Term.bind(
        List.cons<>({term.name,x},
          List.cons<>({term.self,s},
          vars)),
        Fm.Path.1(path),
        term.body(
          Fm.Term.var(term.self, vlen),
          Fm.Term.var(term.name, Nat.succ(vlen))))
      Fm.Term.all(term.eras, term.self, term.name, xtyp, body),
    lam:
      let vlen = List.length<>(vars)
      def body = (x) Fm.Term.bind(
        List.cons<>({term.name,x},vars),
        Fm.Path.0(path),
        term.body(Fm.Term.var(term.name, vlen)))
      Fm.Term.lam(term.name, body),
    app:
      def func = Fm.Term.bind(vars, Fm.Path.0(path), term.func)
      def argm = Fm.Term.bind(vars, Fm.Path.1(path), term.argm)
      Fm.Term.app(func, argm),
    let:
      let vlen = List.length<>(vars)
      def expr = Fm.Term.bind(vars, Fm.Path.0(path), term.expr)
      def body = (x) Fm.Term.bind(
        List.cons<>({term.name,x}, vars),
        Fm.Path.1(path),
        term.body(Fm.Term.var(term.name, vlen)))
      Fm.Term.let(term.name, expr, body),
    ann:
      def term = Fm.Term.bind(vars, Fm.Path.0(path), term.term)
      def type = Fm.Term.bind(vars, Fm.Path.1(path), term.type)
      Fm.Term.ann(term.done, term, type),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb),
    hol:
      Fm.Term.hol(Fm.Path.to_bits(path)),
    nat:
      Fm.Term.nat(term.natx),
    chr:
      Fm.Term.chr(term.chrx),
    str:
      Fm.Term.str(term.strx),
    sug: case term.sugx { // The TODOs below aren't essential/reachable (for now)
      app:
        let func = Fm.Term.bind(vars, Fm.Path.0(path), term.sugx.func)
        let args = term.sugx.args // TODO
        Fm.Term.sug(Fm.Sugar.app(func, args)),
      cse:
        let expr = Fm.Term.bind(vars, Fm.Path.0(path), term.sugx.expr)
        let name = term.sugx.name // TODO
        let with = term.sugx.with // TODO
        let cses = term.sugx.cses // TODO
        let moti = term.sugx.moti // TODO
        Fm.Term.sug(Fm.Sugar.cse(expr, name, with, cses, moti)),
    },
    _: term,
  }

// REDUCE: Reduces a high order term to weak head normal form
Fm.Term.reduce(term: Fm.Term, defs: Fm.Defs): Fm.Term
  case term {
    ref: case Fm.get<>(term.name, defs) as got {
      none: Fm.Term.ref(term.name),
      some: case got.value { new: Fm.Term.reduce(got.value.term, defs) },
    },
    app:
      let func = Fm.Term.reduce(term.func, defs)
      case func {
        lam: Fm.Term.reduce(func.body(term.argm), defs),
        _: term,
      },
    let:
      Fm.Term.reduce(term.body(term.expr), defs),
    ann:
      Fm.Term.reduce(term.term, defs),
    nat:
      Fm.Term.reduce(Fm.Term.unroll_nat(term.natx), defs),
    chr:
      Fm.Term.reduce(Fm.Term.unroll_chr(term.chrx), defs),
    str:
      Fm.Term.reduce(Fm.Term.unroll_str(term.strx), defs),
    _: term,
  }

// NORMALIZE: Normalizes a high order term
Fm.Term.normalize(term: Fm.Term, defs: Fm.Defs): Fm.Term
  case Fm.Term.reduce(term, defs) as term {
    ref:
      Fm.Term.ref(term.name),
    var:
      Fm.Term.var(term.name, term.indx),
    typ:
      Fm.Term.typ,
    all: 
      def xtyp = Fm.Term.normalize(term.xtyp, defs)
      def body = (s,x) Fm.Term.normalize(term.body(s,x), defs)
      Fm.Term.all(term.eras, term.self, term.name, xtyp, body),
    lam:
      def body = (x) Fm.Term.normalize(term.body(x), defs)
      Fm.Term.lam(term.name, body),
    app:
      def func = Fm.Term.normalize(term.func, defs)
      def argm = Fm.Term.normalize(term.argm, defs)
      Fm.Term.app(func, argm),
    let:
      def expr = Fm.Term.normalize(term.expr, defs)
      def body = (x) Fm.Term.normalize(term.body(x), defs)
      Fm.Term.let(term.name, expr, body),
    ann:
      def term = Fm.Term.normalize(term.term, defs)
      def type = Fm.Term.normalize(term.type, defs)
      Fm.Term.ann(term.done, term, type),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb),
    hol:
      Fm.Term.hol(term.path),
    nat:
      Fm.Term.nat(term.natx),
    chr:
      Fm.Term.chr(term.chrx),
    str:
      Fm.Term.str(term.strx),
    sug:
      term,
  }

// Patching
// ========

// PATCH_AT Does something at a specific path
Fm.Term.patch_at(path: Bits, term: Fm.Term, fn: Fm.Term -> Fm.Term): Fm.Term
  case term {
    all: case path {
      nil: fn(term),
      0: Fm.Term.all(term.eras, term.self, term.name, Fm.Term.patch_at(path.pred,term.xtyp,fn), term.body),
      1: Fm.Term.all(term.eras, term.self, term.name, term.xtyp, (s,x) Fm.Term.patch_at(path.pred,term.body(s,x),fn)),
    },
    lam: case path {
      nil: fn(term),
      _: 
        def body = (x) Fm.Term.patch_at(Bits.tail(path), term.body(x), fn)
        Fm.Term.lam(term.name, body),
    },
    app: case path {
      nil: fn(term),
      0: Fm.Term.app(Fm.Term.patch_at(path.pred,term.func,fn), term.argm),
      1: Fm.Term.app(term.func, Fm.Term.patch_at(path.pred,term.argm,fn)),
    },
    let: case path {
      nil: fn(term),
      0: Fm.Term.let(term.name, Fm.Term.patch_at(path.pred,term.expr,fn), term.body),
      1: Fm.Term.let(term.name, term.expr, (x) Fm.Term.patch_at(path.pred,term.body(x),fn)),
    },
    ann: case path {
      nil: fn(term),
      _: Fm.Term.ann(term.done, Fm.Term.patch_at(path,term.term,fn), term.type),
    },
    sug: case path {
      nil: fn(term),
      _: term, // TODO: we can't patch inside sugars (yet)
    },
    _: case path {
      nil: fn(term),
      _: term,
    },
  }

// Expands the ref at given path
Fm.Term.expand_at(path: Bits, term: Fm.Term, defs: Fm.Defs): Fm.Term
  Fm.Term.patch_at(path, term, (term) case term {
    ref: case Fm.get<>(term.name, defs) as got {
      none: Fm.Term.ref(term.name),
      some: case got.value { new: got.value.term },
    },
    _: term,
  })

// Expands a term for pretty printing
Fm.Term.expand(dref: List(Bits), term: Fm.Term, defs: Fm.Defs): Fm.Term
  let term = Fm.Term.normalize(term, Map.new<>)
  for path in dref with term:
    Fm.Term.normalize(Fm.Term.expand_at(path, term, defs), Map.new<>)

// Equality
// ========

// Helper function
Fm.Term.serialize.go(term: Fm.Term, depth: Nat, init: Nat, x: Bits): Bits
case term {
  ref:
    let name = Bits.concat(Fm.Name.to_bits(term.name))
    Bits.0(Bits.0(Bits.0(name(x)))),
  var:
    if Nat.gte(term.indx, init) then
      let name = Bits.concat(Nat.to_bits(Nat.pred(Nat.sub(depth,term.indx))))
      Bits.0(Bits.0(Bits.1(name(x))))
    else
      let name = Bits.concat(Nat.to_bits(term.indx))
      Bits.0(Bits.1(Bits.0(name(x)))),
  typ:
    Bits.0(Bits.1(Bits.1(x))),
  all:
    let xtyp = Fm.Term.serialize.go(term.xtyp, depth, init)
    let body = Fm.Term.serialize.go(
      term.body(
        Fm.Term.var(term.self, depth),
        Fm.Term.var(term.name, Nat.succ(depth))),
      Nat.succ(Nat.succ(depth)),
      init)
    Bits.1(Bits.0(Bits.0(xtyp(body(x))))),
  lam:
    let body = Fm.Term.serialize.go(
      term.body(Fm.Term.var(term.name, depth)),
      Nat.succ(depth),
      init)
    Bits.1(Bits.0(Bits.1(body(x)))),
  app:
    let func = Fm.Term.serialize.go(term.func, depth, init)
    let argm = Fm.Term.serialize.go(term.argm, depth, init)
    Bits.1(Bits.1(Bits.0(func(argm(x))))),
  let:
    let expr = Fm.Term.serialize.go(term.expr, depth, init)
    let body = Fm.Term.serialize.go(
      term.body(Fm.Term.var(term.name, depth)),
      Nat.succ(depth),
      init)
    Bits.1(Bits.1(Bits.1(expr(body(x))))),
  ann:
    Fm.Term.serialize.go(term.term, depth, init, x),
  gol:
    let name = Bits.concat(Fm.Name.to_bits(term.name))
    Bits.0(Bits.0(Bits.0(name(x)))),
  hol:
    x,
  nat:
    x,
  chr:
    x,
  str:
    x,
  sug:
    x,
}

// SERIALIZE: Serializes a term to a representative bitstring
Fm.Term.serialize(term: Fm.Term, depth: Nat): Bits
  Fm.Term.serialize.go(term, depth, depth, Bits.nil)

// Helper function
Fm.Term.equal.patch(path: Bits, term: Fm.Term): Fm.Check(Bool)
  Fm.Check.result<>(Maybe.some<>(Bool.true), [Fm.Error.patch(path, Fm.Term.normalize(term, Map.new<>))])

// EQUAL: Determines if two terms are equal
Fm.Term.equal(a: Fm.Term, b: Fm.Term, defs: Fm.Defs, lv: Nat, seen: Set): Fm.Check(Bool)
  let a1 = Fm.Term.reduce(a, defs)
  let b1 = Fm.Term.reduce(b, defs)
  let ah = Fm.Term.serialize(a1, lv)
  let bh = Fm.Term.serialize(b1, lv)
  let id = Bits.concat(ah, bh)
  if Bool.or(Bits.eql(ah, bh), Set.has(id, seen)) then
    Fm.Check.result<>(Maybe.some<>(Bool.true), [])
  else
    let seen = Set.set(id, seen)
    case a1 {
      all:
        case b1 {
          all:
            let a1_body = a1.body(
              Fm.Term.var(a1.self, lv),
              Fm.Term.var(a1.name, Nat.succ(lv)))
            let b1_body = b1.body(
              Fm.Term.var(b1.self, lv),
              Fm.Term.var(b1.name, Nat.succ(lv)))
            do Fm.Check {
              var eq_type = Fm.Term.equal(a1.xtyp, b1.xtyp, defs, lv, seen);
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(Nat.succ(lv)), seen);
              return Bool.and(eq_type, eq_body);
            },
          hol:
            Fm.Term.equal.patch(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      lam:
        case b1 {
          lam:
            let a1_body = a1.body(Fm.Term.var(a1.name, lv))
            let b1_body = b1.body(Fm.Term.var(b1.name, lv))
            do Fm.Check {
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(lv), seen);
              return eq_body;
            },
          hol: Fm.Term.equal.patch(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      app:
        case b1 {
          app: do Fm.Check {
            var eq_func = Fm.Term.equal(a1.func, b1.func, defs, lv, seen);
            var eq_argm = Fm.Term.equal(a1.argm, b1.argm, defs, lv, seen);
            return Bool.and(eq_func, eq_argm);
          },
          hol: Fm.Term.equal.patch(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      let:
        case b1 {
          let: 
            let a1_body = a1.body(Fm.Term.var(a1.name, lv))
            let b1_body = b1.body(Fm.Term.var(b1.name, lv))
            do Fm.Check {
              var eq_expr = Fm.Term.equal(a1.expr, b1.expr, defs, lv, seen);
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(lv), seen);
              return Bool.and(eq_expr, eq_body);
            },
          hol:
            Fm.Term.equal.patch(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      hol:
        Fm.Term.equal.patch(a1.path, b),
      _: case b1 {
        hol: Fm.Term.equal.patch(b1.path, a),
        _: do Fm.Check {
          return Bool.false;
        },
      },
    }

// Type Checking
// =============

// Fm.Check monad pure
Fm.Check.pure<V: Type>(value: V): Fm.Check(V)
  Fm.Check.result<V>(Maybe.some<V>(value), [])

// Fm.Check monad bind
Fm.Check.bind<A: Type, B: Type>(a: Fm.Check(A), f: A -> Fm.Check(B)): Fm.Check(B)
  case a {
    result: case a.value as got {
      none: Fm.Check.result<B>(Maybe.none<B>, a.errors),
      some: case f(got.value) as b {
        result: Fm.Check.result<B>(b.value, List.concat<>(a.errors,b.errors)),
      }
    }
  }

// Fm.Check monad
Fm.Check.monad: Monad(Fm.Check)
  Monad.new<Fm.Check>(Fm.Check.bind, Fm.Check.pure)

// Fm.Check to Maybe
Fm.Check.value<A: Type>(chk: Fm.Check(A)): Maybe(A)
  case chk {
    result: chk.value
  }

// Fm.Check none
Fm.Check.none<A: Type>: Fm.Check(A)
  Fm.Check.result<A>(Maybe.none<A>, [])

// CHECK: Checks the type of a core term
Fm.Term.check(
  term: Fm.Term,
  type: Maybe(Fm.Term),
  defs: Fm.Defs,
  ctx: Fm.Context,
  path: Fm.MPath,
): Fm.Check(Fm.Term)
  //use skip = Debug.log<>(String.flatten([
    //"[debug] - check: ",
    //Fm.Term.show(term),
    //case type {
      //none: "",
      //some: String.flatten([
        //" :: ",
        //Fm.Term.show(type.value),
      //]),
    //},
    ////" at ",
    ////Bits.show(Fm.MPath.to_bits(path)),
  //]))
  do Fm.Check {
    var infr = case term {
      ref:
        case Fm.get<>(term.name, defs) as got {
          none: Fm.Check.result<>(Maybe.none<>, [Fm.Error.undefined_reference(term.name)]),
          some: case got.value { new: Fm.Check.result<>(Maybe.some<>(got.value.type), []) }
        },
      var:
        case List.at_last<>(term.indx, ctx) as got {
          none: Fm.Check.result<>(Maybe.none<>, [Fm.Error.undefined_reference(term.name)]),
          some: Fm.Check.result<>(Maybe.some<>(Pair.snd<_,_>(got.value)), []),
        }
      typ:
        Fm.Check.result<>(Maybe.some<>(Fm.Term.typ), []),
      all: 
        let ctx_size = List.length<>(ctx)
        let self_var = Fm.Term.var(term.self, ctx_size)
        let body_var = Fm.Term.var(term.name, Nat.succ(ctx_size))
        let body_ctx = List.cons<>({term.name,term.xtyp}, List.cons<>({term.self,term}, ctx))
        do Fm.Check {
          Fm.Term.check(term.xtyp, Maybe.some<>(Fm.Term.typ), defs, ctx, Fm.MPath.0(path));
          Fm.Term.check(term.body(self_var,body_var), Maybe.some<>(Fm.Term.typ), defs, body_ctx, Fm.MPath.1(path));
          return Fm.Term.typ;
        },
      lam:
        case type {
          none:
            Fm.Check.result<>(Maybe.none<>, [Fm.Error.cant_infer(term, ctx)]),
          some: 
            let typv = Fm.Term.reduce(type.value, defs)
            case typv {
              all:
                let ctx_size = List.length<>(ctx)
                let self_var = term
                let body_var = Fm.Term.var(term.name, ctx_size)
                let body_typ = typv.body(self_var, body_var)
                let body_ctx = List.cons<>({term.name,typv.xtyp}, ctx)
                do Fm.Check {
                  Fm.Term.check(term.body(body_var), Maybe.some<>(body_typ), defs, body_ctx, Fm.MPath.0(path));
                  return type.value;
                },
              _: Fm.Check.result<>(Maybe.none<>, [
                Fm.Error.type_mismatch(
                  Either.left<_,_>("Function"),
                  Either.right<_,_>(type.value),
                  ctx)
                ]),
            }
        },
      app: 
        do Fm.Check {
          var func_typ = Fm.Term.check(term.func, Maybe.none<>, defs, ctx, Fm.MPath.0(path));
          let func_typ = Fm.Term.reduce(func_typ, defs);
          case func_typ {
            all: do Fm.Check {
              Fm.Term.check(term.argm, Maybe.some<>(func_typ.xtyp), defs, ctx, Fm.MPath.1(path));
              return func_typ.body(term.func, term.argm);
            },
            _: Fm.Check.result<>(Maybe.none<>, [
              Fm.Error.type_mismatch(
                Either.left<_,_>("Function"),
                Either.right<_,_>(func_typ),
                ctx)
            ]),
          };
        },
      ann:
        if term.done then do Fm.Check {
          return term.type;
        } else do Fm.Check {
          Fm.Term.check(term.term, Maybe.some<>(term.type), defs, ctx, Fm.MPath.0(path));
          Fm.Term.check(term.type, Maybe.some<>(Fm.Term.typ), defs, ctx, Fm.MPath.1(path));
          return term.type;
        },
      let:
        let ctx_size = List.length<>(ctx)
        do Fm.Check {
          var expr_typ = Fm.Term.check(term.expr, Maybe.none<>, defs, ctx, Fm.MPath.0(path));
          let body_val = term.body(Fm.Term.var(term.name, ctx_size));
          let body_ctx = List.cons<>({term.name, expr_typ}, ctx);
          var body_typ = Fm.Term.check(body_val, type, defs, body_ctx, Fm.MPath.1(path));
          return body_typ;
        },
      nat:
        Fm.Term.check(Fm.Term.unroll_nat(term.natx), type, defs, ctx, path),
      chr:
        Fm.Term.check(Fm.Term.unroll_chr(term.chrx), type, defs, ctx, path),
      str:
        Fm.Term.check(Fm.Term.unroll_str(term.strx), type, defs, ctx, path),
      sug: do Fm.Check {
        let expr = case term.sugx {
          app: term.sugx.func,
          cse: term.sugx.expr,
        };
        var expr_typ = Fm.Term.check(expr, Maybe.none<>, defs, ctx, Fm.MPath.0(path));
        let term = case term.sugx {
          app: Fm.Term.desugar_app(
            term.sugx.func,
            term.sugx.args,
            expr_typ,
            defs),
          cse: Fm.Term.desugar_cse(
            term.sugx.expr,
            term.sugx.name,
            term.sugx.with,
            term.sugx.cses,
            term.sugx.moti,
            expr_typ,
            defs,
            ctx),
        };
        Fm.Check.result<>(Maybe.none<>, [Fm.Error.patch(Fm.MPath.to_bits(path),term)]);
      },
      gol: 
        Fm.Check.result<>(type, [
          Fm.Error.show_goal(term.name, term.dref, term.verb, type, ctx)
        ]),
      hol:
        Fm.Check.result<>(type, []),
    };
    case type {
      none:
        Fm.Check.result<>(Maybe.some<>(infr), []),
      some: do Fm.Check {
        var eqls = 
          //use skip = Debug.log<>(String.flatten([
            //"[debug] - equal: ",
            //Fm.Term.show(type.value),
            //" == ",
            //Fm.Term.show(infr),
            ////" at ",
            ////Bits.show(Fm.MPath.to_bits(path)),
          //]))
          Fm.Term.equal(type.value, infr, defs, List.length<>(ctx), Set.new);
        if eqls then do Fm.Check {
          return type.value;
        } else Fm.Check.result<>(Maybe.none<>, [
          Fm.Error.type_mismatch(
            Either.right<_,_>(type.value),
            Either.right<_,_>(infr),
            ctx)
        ]);
      }
    };
  }

// SYNTH: Fixes a list of errors, if possible
Fm.synth.fix(
  term: Fm.Term,
  type: Fm.Term,
  defs: Fm.Defs,
  errs: List(Fm.Error),
  fixs: Bool,
): Maybe(Pair(Fm.Term, Fm.Term))
  case errs {
    nil:
      if fixs then
        Maybe.some<>({term, type})
      else
        Maybe.none<>,
    cons: 
      //use skip = Debug.log<>(String.flatten([
        //"[fixing]",
        //"\n- ", Fm.Term.show(type),
        //"\n- ", Fm.Term.show(term),
        //"\n- ", Fm.Error.show(errs.head, defs)
      //]))
      case errs.head {
        // The error is a fill
        //fill:
          //let filled_term = Fm.Term.fill(errs.head.name, errs.head.term, term)
          //let filled_type = Fm.Term.fill(errs.head.name, errs.head.term, type)
          ////use skip = Debug.log<>(String.flatten([
            ////"FILLING_TERM ",
            ////"\n-name:", Fm.Name.show(errs.head.name),
            ////"\n-hval:", Fm.Term.show(errs.head.term),
            ////"\n-term:", Fm.Term.show(term),
            ////"\n-type:", Fm.Term.show(type),
            ////"\n~term:", Fm.Term.show(filled_term),
            ////"\n~type:", Fm.Term.show(filled_type),
          ////]))
          //Fm.synth.fix(filled_term, filled_type, defs, errs.tail, Bool.true),
        // The error is a patch
        patch: 
          case errs.head.path {
            nil: Maybe.none<>, // shouldn't happen
            0: // hole is on term
              let patched_term = Fm.Term.patch_at(errs.head.path.pred, term, () errs.head.term)
              //use skip = Debug.log<>(String.flatten([
                //"PATCHING_TERM ",
                //"\n-path:",Bits.show(errs.head.path),
                //"\n-pval:", Fm.Term.show(errs.head.term),
                //"\n-term:", Fm.Term.show(term),
                //"\n~term:",Fm.Term.show(patched_term)]))
              Fm.synth.fix(patched_term, type, defs, errs.tail, Bool.true),
            1: // hole is on type
              let patched_type = Fm.Term.patch_at(errs.head.path.pred, type, () errs.head.term)
              //use skip = Debug.log<>(String.flatten([
                //"PATCHING_TYPE ",
                //"\n-path:",Bits.show(errs.head.path),
                //"\n-pval:", Fm.Term.show(errs.head.term),
                //"\n-term:", Fm.Term.show(term),
                //"\n~type:",Fm.Term.show(patched_type)]))
              Fm.synth.fix(term, patched_type, defs, errs.tail, Bool.true),
          },
        // The error isn't fixable
        _: Fm.synth.fix(term, type, defs, errs.tail, fixs),
      }
  }

Fm.synth.one(name: Fm.Name, term: Fm.Term, type: Fm.Term, defs: Fm.Defs): Fm.Def
  let checked = do Fm.Check {
    var chk_type = Fm.Term.check(type, Maybe.some<>(Fm.Term.typ), defs, [], Fm.MPath.1(Fm.MPath.nil));
    var chk_term = Fm.Term.check(term, Maybe.some<>(type), defs, [], Fm.MPath.0(Fm.MPath.nil));
    return Unit.new;
  }
  case checked {
    result: case checked.errors {
      nil:
        Fm.Def.new(name, term, type, Bool.true),
      cons:
        let fixed = Fm.synth.fix(term, type, defs, checked.errors, Bool.false)
        case fixed {
          none:
            Fm.Def.new(name, term, type, Bool.true),
          some:
            open fixed.value
            let term = Fm.Term.bind([], Fm.Path.0(Fm.Path.nil), fixed.value.fst)
            let type = Fm.Term.bind([], Fm.Path.1(Fm.Path.nil), fixed.value.snd)
            Fm.synth.one(name, term, type, defs),
        }
    }
  }


// SYNTH: Checks the type of a core term, fixing repairable errors
Fm.synth(defs: Fm.Defs): Fm.Defs
  for def in Map.to_list<>(defs) with defs:
    open def
    open def.snd
    let name = Fm.Name.from_bits(def.fst)
    let term = def.snd.term
    let type = def.snd.type
    let done = def.snd.done
    let defn = Fm.synth.one(name, term, type, defs)
    Fm.set<>(name, defn, defs)

// REPORT: Synths, checks and reports errors of a defs
Fm.report(defs: Fm.Defs): String
  let state = {"# Types:\n\n", "# Errors:\n\n"}
  let state = for def in Map.to_list<>(defs):
    open state
    open def
    open def.snd
    let name = Fm.Name.from_bits(def.fst)
    let term = def.snd.term
    let type = def.snd.type
    case Fm.Term.check(term, Maybe.some<>(type), defs, [], Fm.MPath.nil) as check {
      result: case check.errors {
        nil: 
          let name_str = Fm.Name.show(name)
          let type_str = Fm.Term.show(type)
          let term_str = Fm.Term.show(term)
          let string_0 = String.flatten([
            state.fst,
            name_str, ": ", type_str, "\n",
          ])
          let string_1 = state.snd
          {string_0, string_1},
        cons: 
          let name_str = Fm.Name.show(name)
          let type_str = "<error>"
          let string_0 = String.flatten([
            state.fst,
            name_str, ": ", type_str, "\n",
          ])
          let string_1 = state.snd
          let string_1 = for error in check.errors:
            String.flatten([
              string_1,
              "\n", Fm.Error.show(error, defs), "\n",
            ])
          {string_0, string_1},
      }
    }
  case state {
    new: String.flatten([state.fst, "\n", state.snd])
  }

// Sugars
// ======

// Unrolls a natural number
Fm.Term.unroll_nat(natx: Nat): Fm.Term
  case natx {
    zero:
      Fm.Term.ref(Fm.Name.read("Nat.zero")),
    succ:
      let func = Fm.Term.ref(Fm.Name.read("Nat.succ"))
      let argm = Fm.Term.nat(natx.pred)
      Fm.Term.app(func, argm),
  }

// Unrolls a character
Fm.Term.unroll_chr(chrx: Char): Fm.Term
  case chrx {
    new: 
      let term = Fm.Term.ref(Fm.Name.read("Word.from_bits"))
      let term = Fm.Term.app(term, Fm.Term.nat(16))
      let term = Fm.Term.app(term, Fm.Term.unroll_chr.bits(Word.to_bits<16>(chrx.value)))
      let term = Fm.Term.app(Fm.Term.ref(Fm.Name.read("U16.new")), term)
      term
  }

Fm.Term.unroll_chr.bits(bits: Bits): Fm.Term
  case bits {
    nil: Fm.Term.ref(Fm.Name.read("Bits.nil")),
    0: Fm.Term.app(Fm.Term.ref(Fm.Name.read("Bits.0")), Fm.Term.unroll_chr.bits(bits.pred)),
    1: Fm.Term.app(Fm.Term.ref(Fm.Name.read("Bits.1")), Fm.Term.unroll_chr.bits(bits.pred)),
  }

// Unrolls a string
Fm.Term.unroll_str(strx: String): Fm.Term
  case strx {
    nil:
      Fm.Term.ref(Fm.Name.read("String.nil")),
    cons:
      let char = Fm.Term.chr(strx.head)
      let term = Fm.Term.ref(Fm.Name.read("String.cons"))
      let term = Fm.Term.app(term, char)
      let term = Fm.Term.app(term, Fm.Term.str(strx.tail))
      term,
  }

// Desugars the named app syntax
Fm.Term.desugar_app(func: Fm.Term, args: Map(Fm.Term), type: Fm.Term, defs: Fm.Defs): Fm.Term
  case Fm.Term.reduce(type, defs) as type {
    all: case Fm.get<>(type.name, args) as got {
      none: func,
      some:
        let func = Fm.Term.app(func, got.value)
        let type = type.body(
          Fm.Term.var(type.self,0),
          Fm.Term.var(type.name,0))
        Fm.Term.desugar_app(func, args, type, defs)
    },
    _: func,
  }

// Desugars the case-of expression (wraps lambdas around arguments)
Fm.Term.desugar_cse(
  expr: Fm.Term,
  name: Fm.Name,
  with: List(Fm.Def),
  cses: Map(Fm.Term),
  moti: Fm.Term,
  type: Fm.Term,
  defs: Fm.Defs,
  ctxt: Fm.Context,
): Fm.Term
  //use skip = Debug.log<>(String.flatten([
    //"DESUGAR_CASE:",
    //"\nexpr: ", Fm.Term.show(expr),
    //"\ntype: ", Fm.Term.show(Fm.Term.reduce(type, defs)),
  //]))
  case Fm.Term.reduce(type, defs) as type {
    all:
      let moti = Fm.Term.desugar_cse.motive(with, moti)
      let argm = Fm.Term.desugar_cse.argument(name, [], type.xtyp, moti, defs)
      let expr = Fm.Term.app(expr, argm)
      let type = type.body(Fm.Term.var(type.self,0), Fm.Term.var(type.name,0))
      Fm.Term.desugar_cse.cases(expr, name, with, cses, type, defs, ctxt),
    _: expr,
  }

// Desugars the case-of expression (cases)
Fm.Term.desugar_cse.cases(
  expr: Fm.Term,
  name: Fm.Name,
  with: List(Fm.Def),
  cses: Map(Fm.Term),
  type: Fm.Term,
  defs: Fm.Defs,
  ctxt: Fm.Context,
): Fm.Term
  //use skip = Debug.log<>(String.flatten([
    //"DESUGAR_CASE (cses):",
    //"\nexpr: ", Fm.Term.show(expr),
    //"\ntype: ", Fm.Term.show(type),
    ////"\nname: ", Fm.Name.show(name),
  //]))
  case Fm.Term.reduce(type, defs) as type {
    all: case Fm.get<>(type.name, cses) as got {
      some:
        let argm = Fm.Term.desugar_cse.argument(name, with, type.xtyp, got.value, defs)
        let expr = Fm.Term.app(expr, argm)
        let type = type.body(
          Fm.Term.var(type.self,0),
          Fm.Term.var(type.name,0))
        Fm.Term.desugar_cse.cases(expr, name, with, cses, type, defs, ctxt),
      none:
        for def in with with expr:
          case def {
            new: Fm.Term.app(expr, def.term)
          },
    },
    _:
      for def in with with expr:
        Fm.Term.app(expr, case def { new: def.term }),
  }

// Extends a type with motive variables
Fm.Term.desugar_cse.motive(
  with: List(Fm.Def),
  moti: Fm.Term,
): Fm.Term
  case with {
    cons: case with.head {
      new:
        def all_name = with.head.name
        def all_xtyp = with.head.type
        def all_body = (s,x) Fm.Term.desugar_cse.motive(with.tail, moti)
        Fm.Term.all(Bool.false, "", all_name, all_xtyp, all_body)
    },
    nil: moti,
  }

// Desugars the case-of expression (wraps lambdas around an argument)
Fm.Term.desugar_cse.argument(
  name: Fm.Name,
  with: List(Fm.Def),
  type: Fm.Term,
  body: Fm.Term,
  defs: Fm.Defs,
): Fm.Term
  case Fm.Term.reduce(type, defs) as type {
    all:
      def type = type.body(Fm.Term.var(type.self,0), Fm.Term.var(type.name,0))
      def lam_name = String.flatten([name, Fm.Name.read("."), type.name])
      def lam_body = (x) Fm.Term.desugar_cse.argument(name, with, type, body, defs)
      Fm.Term.lam(lam_name, lam_body),
    _: case with {
      cons: case with.head {
        new:
          def lam_name = with.head.name
          def lam_body = (x) Fm.Term.desugar_cse.argument(name, with.tail, type, body, defs)
          Fm.Term.lam(lam_name, lam_body)
      },
      nil: body,
    }
  }

// Builds the type of a datatype
Fm.Datatype.build_type(type: Fm.Datatype): Fm.Term
  case type {
    new: Fm.Datatype.build_type.go(type, type.name, type.pars, type.inds),
  }

Fm.Datatype.build_type.go(
  type: Fm.Datatype,
  name: Fm.Name,
  pars: List(Fm.Binder),
  inds: List(Fm.Binder),
): Fm.Term
  case pars {
    cons: case pars.head {
      new:
        def par_eras = pars.head.eras
        def par_name = pars.head.name
        def par_xtyp = pars.head.term
        def par_body = (s,x) Fm.Datatype.build_type.go(type, name, pars.tail, inds)
        Fm.Term.all(Bool.false, "", par_name, par_xtyp, par_body)
    },
    nil: case inds {
      cons: case inds.head {
        new: 
          def ind_eras = inds.head.eras
          def ind_name = inds.head.name
          def ind_xtyp = inds.head.term
          def ind_body = (s,x) Fm.Datatype.build_type.go(type, name, pars, inds.tail)
          Fm.Term.all(Bool.false, "", ind_name, ind_xtyp, ind_body)
      },
      nil: Fm.Term.typ,
    }
  }

// Builds the term of a datatype (motive)
Fm.Datatype.build_term.motive(
  type: Fm.Datatype,
): Fm.Term
  case type {
    new: Fm.Datatype.build_term.motive.go(type, type.name, type.inds),
  }

Fm.Datatype.build_term.motive.go(
  type: Fm.Datatype,
  name: Fm.Name,
  inds: List(Fm.Binder),
): Fm.Term
  case inds {
    cons:
      def ind_eras = case inds.head { new: inds.head.eras }
      def ind_name = case inds.head { new: inds.head.name }
      def ind_xtyp = case inds.head { new: inds.head.term }
      def ind_body = (s,x) Fm.Datatype.build_term.motive.go(type, name, inds.tail)
      Fm.Term.all(ind_eras, "", ind_name, ind_xtyp, ind_body),
    nil:
      open type
      let slf = Fm.Term.ref(name)
      let slf = for var in type.pars:
        Fm.Term.app(slf, Fm.Term.ref(case var { new: var.name }))
      let slf = for var in type.inds:
        Fm.Term.app(slf, Fm.Term.ref(case var { new: var.name }))
      Fm.Term.all(Bool.false, "", Fm.Name.read("self"), slf, (s,x) Fm.Term.typ)
  }

// Builds the term of a datatype (constructors)
Fm.Datatype.build_term.constructors(type: Fm.Datatype): Fm.Term
  case type {
    new: Fm.Datatype.build_term.constructors.go(type, type.ctrs)
  }

Fm.Datatype.build_term.constructors.go(
  type: Fm.Datatype,
  ctrs: List(Fm.Constructor),
): Fm.Term
  case ctrs {
    cons: case ctrs.head {
      new: Fm.Term.all(Bool.false, "",
        ctrs.head.name,
        Fm.Datatype.build_term.constructor(type, ctrs.head),
        (s,x) Fm.Datatype.build_term.constructors.go(type, ctrs.tail))
    },
    nil:
      open type
      let ret = Fm.Term.ref(Fm.Name.read("P"));
      let ret = for var in type.inds:
        Fm.Term.app(ret, Fm.Term.ref(case var { new: var.name }));
      Fm.Term.app(ret, Fm.Term.ref(Fm.Name.read("self")))
  }

// Builds the term of a datatype (constructor)
Fm.Datatype.build_term.constructor(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case ctor {
    new: Fm.Datatype.build_term.constructor.go(type, ctor, ctor.args),
  }

Fm.Datatype.build_term.constructor.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  args: List(Fm.Binder),
): Fm.Term
  case args {
    cons:
      let eras = case args.head { new: args.head.eras }
      let name = case args.head { new: args.head.name }
      let xtyp = case args.head { new: args.head.term }
      let body = Fm.Datatype.build_term.constructor.go(type, ctor, args.tail)
      Fm.Term.all(eras, "", name, xtyp, (s,x) body),
    nil:
      open type
      open ctor
      let ret = Fm.Term.ref(Fm.Name.read("P"))
      let ret = for var in ctor.inds:
        Fm.Term.app(ret, case var { new: var.term })
      let ctr = String.flatten([type.name,Fm.Name.read("."),ctor.name])
      let slf = Fm.Term.ref(ctr)
      let slf = for var in type.pars:
        Fm.Term.app(slf, Fm.Term.ref(case var { new: var.name }))
      let slf = for var in ctor.args:
        Fm.Term.app(slf, Fm.Term.ref(case var { new: var.name }))
      Fm.Term.app(ret, slf)
  }
        
// Builds the term of a datatype
Fm.Datatype.build_term(type: Fm.Datatype): Fm.Term
  case type {
    new: Fm.Datatype.build_term.go(type, type.name, type.pars, type.inds),
  }

Fm.Datatype.build_term.go(
  type: Fm.Datatype,
  name: Fm.Name,
  pars: List(Fm.Binder),
  inds: List(Fm.Binder),
): Fm.Term
  case pars {
    cons:
      def par_name = case pars.head { new: pars.head.name }
      def par_body = (x) Fm.Datatype.build_term.go(type, name, pars.tail, inds)
      Fm.Term.lam(par_name, par_body),
    nil: case inds {
      cons:
        def ind_name = case inds.head { new: inds.head.name }
        def ind_body = (x) Fm.Datatype.build_term.go(type, name, pars, inds.tail)
        Fm.Term.lam(ind_name, ind_body),
      nil: 
        def moti = Fm.Datatype.build_term.motive(type)
        def body = (s,x) Fm.Datatype.build_term.constructors(type) // TODO
        Fm.Term.all(Bool.false, Fm.Name.read("self"), Fm.Name.read("P"), moti, body)
    }
  }

Fm.Constructor.build_type(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case type {
    new: case ctor {
      new: Fm.Constructor.build_type.go(
        type,
        ctor,
        type.name,
        type.pars,
        ctor.args)
    }
  }

Fm.Constructor.build_type.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  name: Fm.Name,
  pars: List(Fm.Binder),
  args: List(Fm.Binder),
): Fm.Term
  case pars {
    cons: 
      def par_eras = case pars.head { new: pars.head.eras }
      def par_name = case pars.head { new: pars.head.name }
      def par_xtyp = case pars.head { new: pars.head.term }
      def par_body = (s,x) Fm.Constructor.build_type.go(type, ctor, name, pars.tail, args)
      Fm.Term.all(par_eras, "", par_name, par_xtyp, par_body),
    nil: case args {
      cons:
        def ctr_eras = case args.head { new: args.head.eras }
        def ctr_name = case args.head { new: args.head.name }
        def ctr_xtyp = case args.head { new: args.head.term }
        def ctr_body = (s,x) Fm.Constructor.build_type.go(type, ctor, name, pars, args.tail)
        Fm.Term.all(ctr_eras, "", ctr_name, ctr_xtyp, ctr_body),
      nil:
        open type
        open ctor
        let type = Fm.Term.ref(name)
        let type = for var in type.pars:
          Fm.Term.app(type, Fm.Term.ref(case var { new: var.name }))
        let type = for var in ctor.inds:
          Fm.Term.app(type, case var { new: var.term })
        type
    }
  }

Fm.Constructor.build_term.opt(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case type {
    new: Fm.Constructor.build_term.opt.go(type, ctor, type.ctrs)
  }

Fm.Constructor.build_term.opt.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  ctrs: List(Fm.Constructor),
): Fm.Term
  case ctrs {
    cons: case ctrs.head {
      new:
        def name = ctrs.head.name
        def body = (x) Fm.Constructor.build_term.opt.go(type, ctor, ctrs.tail)
        Fm.Term.lam(name, body)
    },
    nil: 
      open ctor
      let ret = Fm.Term.ref(ctor.name)
      let ret = for arg in ctor.args:
        Fm.Term.app(ret, Fm.Term.ref(case arg { new: arg.name }))
      ret,
  }

Fm.Constructor.build_term(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case type {
    new: case ctor {
      new: Fm.Constructor.build_term.go(
        type,
        ctor,
        type.name,
        type.pars,
        ctor.args,
      )
    }
  }

Fm.Constructor.build_term.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  name: Fm.Name,
  pars: List(Fm.Binder),
  args: List(Fm.Binder),
): Fm.Term
  case pars {
    cons: 
      def par_name = case pars.head { new: pars.head.name }
      def par_body = (x) Fm.Constructor.build_term.go(type, ctor, name, pars.tail, args)
      Fm.Term.lam(par_name, par_body),
    nil: case args {
      cons:
        def ctr_name = case args.head { new: args.head.name }
        def ctr_xtyp = case args.head { new: args.head.type }
        def ctr_body = (x) Fm.Constructor.build_term.go(type, ctor, name, pars, args.tail)
        Fm.Term.lam(ctr_name, ctr_body),
      nil:
        def lam_name = Fm.Name.read("P")
        def lam_body = (x) Fm.Constructor.build_term.opt(type, ctor)
        Fm.Term.lam(lam_name, lam_body),
    }
  }

// Parsing
// =======

// Is this character a valid letter?
Fm.Name.is_letter(chr: Char): Bool
  if      U16.btw('A', chr, 'Z') then Bool.true
  else if U16.btw('a', chr, 'z') then Bool.true
  else if U16.btw('0', chr, '9') then Bool.true
  else if U16.eql('.', chr)      then Bool.true
  else if U16.eql('_', chr)      then Bool.true
  else                                Bool.false

// Converts a String to a Fm.Name
Fm.Name.read(str: String): Fm.Name
  str

// Converts a Fm.Name to a String
Fm.Name.show(name: Fm.Name): String
  name
  
// Converts a name to a bits
Fm.Name.to_bits(name: Fm.Name): Bits
  case name {
    nil:
      Bits.nil,
    cons:
      let chr = name.head
      let u16 = 
        if      U16.btw('A', chr, 'Z') then U16.sub(chr, 65s)
        else if U16.btw('a', chr, 'z') then U16.sub(chr, 71s)
        else if U16.btw('0', chr, '9') then U16.add(chr, 4s)
        else if U16.eql('.', chr)      then 62s
        else if U16.eql('_', chr)      then 63s
        else                                0s
      let bts = case u16 { new: Word.to_bits<6>(Word.trim<16>(6, u16.value)) }
      Bits.concat(Bits.reverse(bts), Fm.Name.to_bits(name.tail)),
  }

//// Converts a bits to a name
Fm.Name.from_bits(bits: Bits): Fm.Name
  let list = Bits.chunks_of(6, bits)
  let name = List.fold<>(list)<>(String.nil, (bts, name)
    let u16 = U16.new(Word.from_bits(16, Bits.reverse(bts)))
    let chr = 
      if      U16.btw( 0s, u16, 25s) then U16.add(u16, 65s)
      else if U16.btw(26s, u16, 51s) then U16.add(u16, 71s)
      else if U16.btw(52s, u16, 61s) then U16.sub(u16, 4s)
      else if U16.eql(62s, u16)      then 46s
      else                                95s
    String.cons(chr, name))
  name

// Are two names the same?
Fm.Name.eql(a: Fm.Name, b: Fm.Name): Bool
  String.eql(a, b)

// Spaces and comments
Fm.Parser.spaces: Parser(List(Unit))
  Parser.many<>(Parser.first_of<>([
    Parser.text(" "),
    Parser.text("\n"),
    do Parser {
      Parser.text("//");
      Parser.many<>(Parser.char_if((chr) Bool.not(U16.eql(chr,'\n'))));
      Parser.text("\n");
    }
  ]))

// Parses spaces then a text
Fm.Parser.spaces_text(text: String): Parser(Unit)
  do Parser {
    Fm.Parser.spaces;
    Parser.text(text);
  }

// Parses a letter: `[a-zA-Z_.]`
Fm.Parser.letter: Parser(Fm.Letter)
  (code) case code {
    nil: Parser.Reply.error<>(code, "Unexpected eof."),
    cons:
      if Fm.Name.is_letter(code.head) then
        Parser.Reply.value<>(code.tail, code.head)
      else
        Parser.Reply.error<>(code, "Expected letter."),
  }
  
// Parses a (possibly empty) name: `[a-zA-Z_.]*`
Fm.Parser.name: Parser(Fm.Name)
  do Parser {
    var chrs = Parser.many<Fm.Letter>(Fm.Parser.letter);
    return List.fold<>(chrs)<>(String.nil, String.cons);
  }

// Parses a non-empty name: `[a-zA-Z_.]+`
Fm.Parser.name1: Parser(Fm.Name)
  do Parser {
    var chrs = Parser.many1<Fm.Letter>(Fm.Parser.letter);
    return List.fold<>(chrs)<>(String.nil, String.cons);
  }

// Parses a type: `Type`
Fm.Parser.type: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("Type");
    return Fm.Term.typ;
  }

// Parses a lambda: `(name) body`
Fm.Parser.lambda: Parser(Fm.Term)
  do Parser {
    Parser.first_of<>([
      Parser.spaces_text("("),
      Parser.spaces_text("<"),
    ]);
    var name = Parser.many1<>(Fm.Parser.item<>(Fm.Parser.name1));
    Parser.first_of<>([
      Parser.text(")"),
      Parser.text(">"),
    ]);
    var body = Fm.Parser.term;
    return Fm.Parser.make_lambda(name, body);
  }

// Parses a parenthesis: `(term)`
Fm.Parser.parenthesis: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("(");
    var term = Fm.Parser.term;
    Fm.Parser.spaces_text(")");
    return term;
  }

// Parses a name:term pair
Fm.Parser.name_term: Parser(Pair(Fm.Name, Fm.Term))
  do Parser {
    var name = Fm.Parser.name;
    Fm.Parser.spaces_text(":");
    var type = Fm.Parser.term;
    return {name, type};
  }

// Parses a binding list, `(a: A, b: B, c: C)`
Fm.Parser.binder.homo(eras: Bool): Parser(List(Fm.Binder))
  do Parser {
    Fm.Parser.spaces_text(if eras then "<" else "(");
    var bind = Parser.many1<>(Fm.Parser.item<>(Fm.Parser.name_term));
    Fm.Parser.spaces_text(if eras then ">" else ")");
    return List.mapped<>(bind)<>((pair) case pair {
      new: Fm.Binder.new(eras, pair.fst, pair.snd)
    });
  }

// Parses a mixed binding list, `<a: A, b: B>(c: C, d: D)<e: E>`
Fm.Parser.binder: Parser(List(Fm.Binder))
  do Parser {
    var lists = Parser.many1<>(Parser.first_of<>([
      Fm.Parser.binder.homo(Bool.true),
      Fm.Parser.binder.homo(Bool.false),
    ]));
    return List.flatten<>(lists);
  }

// Parses a forall: `self(a: A, b: B, c: C) D`
Fm.Parser.forall: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces;
    var self = Fm.Parser.name;
    var bind = Fm.Parser.binder;
    Parser.maybe<>(Parser.spaces_text("->"));
    var body = Fm.Parser.term;
    let term = List.fold<>(bind)<>(body, (x,t) case x {
      new: Fm.Term.all(x.eras, "", x.name, x.term, (s,x) t)
    });
    return case term {
      all: Fm.Term.all(term.eras, self, term.name, term.xtyp, term.body),
      _: term,
    };
  }

// Parses a let: `let name = expr; body`
Fm.Parser.let: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("let ");
    Fm.Parser.spaces;
    var name = Fm.Parser.name;
    Fm.Parser.spaces_text("=");
    var expr = Fm.Parser.term;
    Fm.Parser.spaces_text(";");
    var body = Fm.Parser.term;
    return Fm.Term.let(name, expr, (x) body);
  }

// Parses an if-then-else: `if b then t else f`
Fm.Parser.if: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("if ");
    var cond = Fm.Parser.term;
    Fm.Parser.spaces_text("then");
    var tcse = Fm.Parser.term;
    Fm.Parser.spaces_text("else");
    var fcse = Fm.Parser.term;
    let term = cond;
    let term = Fm.Term.app(term, Fm.Term.lam("", (x) Fm.Term.hol(Bits.nil)));
    let term = Fm.Term.app(term, tcse);
    let term = Fm.Term.app(term, fcse);
    return term;
  }

// Parses a single char: `\n`
Fm.Parser.char.single: Parser(Char)
  let escs = [
    {"\\b" , '\b'},
    {"\\f" , '\f'},
    {"\\n" , '\n'},
    {"\\r" , '\r'},
    {"\\t" , '\t'},
    {"\\v" , '\v'},
    {"\\\\", '\\'},
    {"\\\"", '"'},
    {"\\0" , '\0'},
    {"\\'" , '\''},
  ]
  Parser.first_of<>([
    Parser.first_of<>(List.mapped<>(escs)<>((esc) case esc {
      new: do Parser {
        Parser.text(esc.fst);
        return esc.snd;
      }
    })),
    Parser.one,
  ])

// Parses a char literal: `'x'`
Fm.Parser.char: Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("'");
    var chrx = Fm.Parser.char.single;
    Parser.text("'");
    return Fm.Term.chr(chrx);
  }

// Parses a string literal: `"foo"`
Fm.Parser.string: Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("\"");
    var chrs = Parser.until<>(Parser.text("\""), Fm.Parser.char.single);
    Parser.text("\"");
    let strx = List.fold<>(chrs)<>(String.nil, String.cons);
    return Fm.Term.str(strx);
  }

// Parses a list literal: `[1, 2, 3]`
Fm.Parser.list: Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("[");
    var vals = Parser.many<>(Fm.Parser.item<>(Fm.Parser.term));
    Parser.spaces_text("]");
    return List.fold<>(vals)<>(
      Fm.Term.app(Fm.Term.ref(Fm.Name.read("List.nil")), Fm.Term.hol(Bits.nil)),
      (x,xs)
        let term = Fm.Term.ref(Fm.Name.read("List.cons"))
        let term = Fm.Term.app(term, Fm.Term.hol(Bits.nil))
        let term = Fm.Term.app(term, x)
        let term = Fm.Term.app(term, xs)
        term);
  }

// Parses a with statement of a case
Fm.Parser.case.with: Parser(Fm.Def)
  do Parser {
    Fm.Parser.spaces_text("with");
    Fm.Parser.spaces;
    var name = Fm.Parser.name1;
    Fm.Parser.spaces_text(":");
    var type = Fm.Parser.term;
    Fm.Parser.spaces_text("=");
    var term = Fm.Parser.term;
    return Fm.Def.new(name, term, type, Bool.false);
  }

// Parses a case statement of a case
Fm.Parser.case.case: Parser(Pair(Fm.Name, Fm.Term))
  do Parser {
    Fm.Parser.spaces;
    var name = Fm.Parser.name1;
    Fm.Parser.spaces_text(":");
    var term = Fm.Parser.term;
    Parser.maybe<>(Fm.Parser.spaces_text(","));
    return {name, term};
  }

// Parses a case: `case f(x) as k with a:A = X; { zero: x, succ: y } : T`
Fm.Parser.case: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("case ");
    Fm.Parser.spaces;
    var expr = Fm.Parser.term;
    var name = Parser.maybe<>(do Parser {
      Fm.Parser.spaces_text("as");
      Fm.Parser.spaces;
      Fm.Parser.name1;
    });
    let name = case name {
      none: case expr {
        ref: expr.name,
        var: expr.name,
        _: Fm.Name.read("self"),
      },
      some: name.value,
    };
    var with = Parser.many<>(Fm.Parser.case.with);
    Fm.Parser.spaces_text("{");
    var cses = Parser.many<>(Fm.Parser.case.case);
    let cses = Map.from_list<_,_>(Fm.Name.to_bits, cses);
    Fm.Parser.spaces_text("}");
    var moti = Parser.maybe<>(do Parser {
      Fm.Parser.spaces_text(":");
      Fm.Parser.term;
    });
    let moti = case moti { none: Fm.Term.hol(Bits.nil), some: moti.value };
    let sugr = Fm.Sugar.cse(expr, name, with, cses, moti);
    let term = Fm.Term.sug(sugr);
    return 
      //use skip = Debug.log<>(String.flatten(["Parsed case: ", Fm.Term.show(term)]))
      term;
  }

// Parses a goal: `?name`
Fm.Parser.goal: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("?");
    var name = Fm.Parser.name;
    var dref = Parser.many<>(do Parser {
      Fm.Parser.spaces_text("-");
      var nat = Parser.nat;
      let bits = Bits.reverse(Bits.tail(Bits.reverse(Nat.to_bits(nat))))
      //var digits = Parser.many1<>(Parser.digit);
      //let bits = Bits.nil
      //let bits = for digit in digits with bits:
        //case digit {zero: Bits.0(bits), succ: Bits.1(bits)};
      do Parser { return bits; };
    });
    var verb = do Parser {
      var verb = Parser.maybe<>(Parser.text("-"));
      return Maybe.to_bool<>(verb);
    };
    return Fm.Term.gol(name, dref, verb);
  }

// Parses a hole: `_`
Fm.Parser.hole: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("_");
    return Fm.Term.hol(Bits.nil);
  }

// Parses a natural number: `123`
Fm.Parser.nat: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces;
    var natx = Parser.nat;
    return Fm.Term.nat(natx);
  }

// Parses a reference: `name`
Fm.Parser.reference: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces;
    var name = Fm.Parser.name1;
    return Fm.Term.ref(name);
  }

// Parses an optional comma after
Fm.Parser.item<V: Type>(parser: Parser(V)): Parser(V)
  do Parser {
    Fm.Parser.spaces;
    var value = parser;
    Parser.maybe<>(Fm.Parser.spaces_text(","));
    return value;
  }

// Parses an application: `func(argm0)`
Fm.Parser.application(func: Fm.Term): Parser(Fm.Term)
  do Parser {
    Parser.first_of<>([
      Parser.text("("),
      Parser.text("<"),
    ]);
    var args = Parser.many1<>(Fm.Parser.item<>(Fm.Parser.term));
    Parser.first_of<>([
      Parser.spaces_text(")"),
      Parser.spaces_text(">"),
    ]);
    return List.for<>(args)<>(func, (x,f) Fm.Term.app(f, x));
  }

// Parses an arrow: `A -> B`
Fm.Parser.arrow(xtyp: Fm.Term): Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("->");
    var body = Fm.Parser.term;
    return Fm.Term.all(Bool.false, "", "", xtyp, (s,x) body);
  }

// Parses an annotation: `term :: type`
Fm.Parser.annotation(term: Fm.Term): Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("::");
    var type = Fm.Parser.term;
    return Fm.Term.ann(Bool.false, term, type);
  }

// Parses a fancy application (sugar): `func(x: 1, y: 2, z: 3)`
Fm.Parser.sugar.application(func: Fm.Term): Parser(Fm.Term)
  do Parser {
    Parser.text("(");
    var args = Parser.many1<>(Fm.Parser.item<>(Fm.Parser.name_term));
    Fm.Parser.spaces_text(")");
    let args = Map.from_list<_,_>(Fm.Name.to_bits, args);
    let term = Fm.Term.sug(Fm.Sugar.app(func, args));
    return term;
  }
  
// Parses a core term (prefix phase)
Fm.Parser.term: Parser(Fm.Term)
  do Parser {
    var term = Parser.first_of<>([
      Fm.Parser.type,
      Fm.Parser.forall,
      Fm.Parser.lambda,
      Fm.Parser.parenthesis,
      Fm.Parser.let,
      Fm.Parser.if,
      Fm.Parser.char,
      Fm.Parser.string,
      Fm.Parser.list,
      Fm.Parser.case,
      Fm.Parser.goal,
      Fm.Parser.hole,
      Fm.Parser.nat,
      Fm.Parser.reference,
    ]);
    Fm.Parser.suffix(term);
  }

// Parses a core term (suffix phase)
Fm.Parser.suffix(term: Fm.Term): Parser(Fm.Term)
  (code)
  let suffix_parser = Parser.first_of<>([
    Fm.Parser.sugar.application(term),
    Fm.Parser.application(term),
    Fm.Parser.arrow(term),
    Fm.Parser.annotation(term),
  ])
  case suffix_parser(code) as suffix_parsed {
    error: Parser.Reply.value<>(code, term),
    value: Fm.Parser.suffix(suffix_parsed.value, suffix_parsed.code),
  }

// Builds a chained forall
Fm.Parser.make_forall(binds: List(Fm.Binder), body: Fm.Term): Fm.Term
  case binds {
    nil: body,
    cons: case binds.head {
      new:
        def all_eras = binds.head.eras
        def all_self = ""
        def all_name = binds.head.name
        def all_xtyp = binds.head.term
        def all_body = (s,x) Fm.Parser.make_forall(binds.tail, body)
        Fm.Term.all(all_eras, all_self, all_name, all_xtyp, all_body),
    }
  }

// Builds a chained lambda
Fm.Parser.make_lambda(names: List(Fm.Name), body: Fm.Term): Fm.Term
  case names {
    nil: body,
    cons: Fm.Term.lam(names.head, (x) Fm.Parser.make_lambda(names.tail, body)),
  }

// Parses a constructor: `foo(a: A, b: B, c: C) ~ (i: I, j: J)`
Fm.Parser.constructor(namespace: Fm.Name): Parser(Fm.Constructor)
  do Parser {
    var name = Fm.Parser.name1;
    var args = Parser.maybe<>(Fm.Parser.binder);
    var inds = Parser.maybe<>(do Parser {
      Fm.Parser.spaces_text("~");
      Fm.Parser.binder;
    });
    let args = Maybe.default<>([], args);
    let inds = Maybe.default<>([], inds);
    return Fm.Constructor.new(name, args, inds);
  }

// Parses a datatype: `type Foo (x: A) ~ (i: I) { ctor0(a: A) ~ (i: I), ... }`
Fm.Parser.datatype: Parser(Fm.Datatype)
  do Parser {
    Fm.Parser.spaces_text("type ");
    var name = Fm.Parser.name1; 
    var pars = Parser.maybe<>(Fm.Parser.binder);
    var inds = Parser.maybe<>(do Parser {
      Fm.Parser.spaces_text("~");
      Fm.Parser.binder;
    });
    let pars = Maybe.default<>([], pars);
    let inds = Maybe.default<>([], inds);
    Fm.Parser.spaces_text("{");
    var ctrs = Parser.many<>(Fm.Parser.item<>(Fm.Parser.constructor(name)));
    Fm.Parser.spaces_text("}");
    return Fm.Datatype.new(name, pars, inds, ctrs);
  }

// Parses a definition
Fm.Parser.def: Parser(Fm.Def)
  do Parser {
    Fm.Parser.spaces;
    var name = Fm.Parser.name;
    var args = Parser.many<>(Fm.Parser.binder);
    let args = List.flatten<>(args);
    Fm.Parser.spaces_text(":");
    var type = Fm.Parser.term;
    var term = Fm.Parser.term;
    let type = Fm.Parser.make_forall(args, type);
    let term = Fm.Parser.make_lambda(List.mapped<>(args)<>((x) case x { new: x.name }),term);
    let type = Fm.Term.bind([], (x) Bits.1(x), type);
    let term = Fm.Term.bind([], (x) Bits.0(x), term);
    return Fm.Def.new(name, term, type, Bool.false);
  }

// Parses many definitions
Fm.Parser.file.go(defs: Fm.Defs): Parser(Fm.Defs)
  do Parser {
    var def = Parser.maybe<>(Fm.Parser.def);
    case def {
      some: case def.value {
        new: Fm.Parser.file.go(Fm.set<>(def.value.name, def.value, defs))
      },
      none: do Parser {
        var adt = Parser.maybe<>(Fm.Parser.datatype);
        case adt {
          some: case adt.value {
            new:
              open adt.value
              let term = Fm.Datatype.build_term(adt.value)
              let term = Fm.Term.bind([], (x) Bits.1(x), term)
              let type = Fm.Datatype.build_type(adt.value)
              let type = Fm.Term.bind([], (x) Bits.0(x), type)
              let defs = Fm.set<>(adt.value.name, Fm.Def.new(adt.value.name, term, type, Bool.false), defs)
              let defs = List.fold<>(adt.value.ctrs)<>(defs, (ctr, defs)
                let typ_name = adt.value.name
                let ctr_name = String.flatten([typ_name, Fm.Name.read("."), case ctr { new: ctr.name }])
                let ctr_term = Fm.Constructor.build_term(adt.value, ctr)
                let ctr_term = Fm.Term.bind([], (x) Bits.1(x), ctr_term)
                let ctr_type = Fm.Constructor.build_type(adt.value, ctr)
                let ctr_type = Fm.Term.bind([], (x) Bits.0(x), ctr_type)
                Fm.set<>(ctr_name, Fm.Def.new(ctr_name, ctr_term, ctr_type, Bool.false), defs))
              //use skip = Debug.log<>("Parsed ADT!")
              //use skip = Debug.log<>(Fm.Name.show(adt.value.name))
              //use skip = Debug.log<>(String.flatten([": ", Fm.Term.show(term)]))
              //use skip = Debug.log<>(String.flatten(["= ", Fm.Term.show(type)]))
              //use skip = Debug.log<>(
                //String.join("", List.mapped<>(adt.value.ctrs)<>((x)
                  //String.flatten([
                    //Fm.Name.show(List.flatten<>([adt.value.name, Fm.Name.read("."), case x { new: x.name }])),
                    //"\n: ", Fm.Term.show(Fm.Constructor.build_type(adt.value, x)),
                    //"\n= ", Fm.Term.show(Fm.Constructor.build_term(adt.value, x)),
                    //"\n"
                  //]))))
              Fm.Parser.file.go(defs)
          },
          none: do Parser {
            return defs;
          }
        };
      }
    };
  }

// Parses many definitions
Fm.Parser.file: Parser(Fm.Defs)
  Fm.Parser.file.go(Map.new<>)

// Reads a term from string
Fm.Term.read(code: String): Maybe(Fm.Term)
  case Fm.Parser.term(code) as parsed {
    error: Maybe.none<>,
    value: Maybe.some<>(parsed.value),
  }

// Reads a defs from string
Fm.Defs.read(code: String): Maybe(Fm.Defs)
  case Fm.Parser.file(code) as parsed {
    error: Maybe.none<>,
    value: Maybe.some<>(parsed.value),
  }

// Compilers
// =========

// Compiles a term to js
Fm.Comp.compile(
  term: Fm.Term,
  type: Maybe(Fm.Term),
  defs: Fm.Defs,
  ctx: Fm.Context,
): Maybe(Fm.Comp)
  case term {
    ref: do Maybe {
      return Fm.Comp.ref(term.name);
    },
    var: do Maybe {
      return Fm.Comp.var(term.name);
    },
    typ: do Maybe {
      return Fm.Comp.nil;
    },
    all: do Maybe {
      return Fm.Comp.nil;
    },
    lam: case type {
      none:
        Maybe.none<>,
      some: 
        let typv = Fm.Term.reduce(type.value, defs)
        case typv {
          all: do Maybe {
            let ctx_size = List.length<>(ctx);
            let self_var = term;
            let body_var = Fm.Term.var(term.name, ctx_size);
            let body_typ = typv.body(self_var, body_var);
            let body_ctx = List.cons<>({term.name,typv.xtyp}, ctx);
            var body_cmp = Fm.Comp.compile(
              term.body(body_var),
              Maybe.some<>(body_typ),
              defs,
              body_ctx);
            return Fm.Comp.lam(term.name, body_cmp);
          },
          _: Maybe.none<>,
        }
      },
    app: 
      do Maybe {
        var func_typ = Fm.Check.value<>(Fm.Term.check(term.func, Maybe.none<>, defs, ctx, Maybe.none<>));
        let func_typ = Fm.Term.reduce(func_typ, defs);
        case func_typ {
          all: do Maybe {
            var func_cmp = Fm.Comp.compile(term.func, Maybe.none<>, defs, ctx);
            var argm_cmp = Fm.Comp.compile(term.argm, Maybe.some<>(func_typ.xtyp), defs, ctx);
            return Fm.Comp.app(func_cmp, argm_cmp);
          },
          _: Maybe.none<>,
        };
      },
    ann:
      Fm.Comp.compile(term.term, Maybe.some<>(term.type), defs, ctx)
    let:
      let ctx_size = List.length<>(ctx)
      do Maybe {
        var expr_typ = Fm.Check.value<>(Fm.Term.check(term.expr, Maybe.none<>, defs, ctx, Maybe.none<>));
        var expr_cmp = Fm.Comp.compile(term.expr, Maybe.none<>, defs, ctx);
        let body_val = term.body(Fm.Term.var(term.name, ctx_size));
        let body_ctx = List.cons<>({term.name, expr_typ}, ctx);
        var body_cmp = Fm.Comp.compile(body_val, type, defs, body_ctx);
        return Fm.Comp.let(term.name, body_cmp, expr_cmp);
      },
    nat:
      Fm.Comp.compile(Fm.Term.unroll_nat(term.natx), type, defs, ctx),
    chr:
      Fm.Comp.compile(Fm.Term.unroll_chr(term.chrx), type, defs, ctx),
    str:
      Fm.Comp.compile(Fm.Term.unroll_str(term.strx), type, defs, ctx),
    sug:
      Maybe.none<>,
    gol: do Maybe {
      return Fm.Comp.nil;
    },
    hol: do Maybe {
      return Fm.Comp.nil;
    },
  }

// Compile a term to JS
Fm.Comp.js(comp: Fm.Comp): String
  case comp {
    nil: "null",
    var: Fm.Name.show(comp.name),
    ref: Fm.Name.show(comp.name),
    lam: String.flatten([
      "((", Fm.Name.show(comp.name), ")=>",
      Fm.Comp.js(comp.body), ")"
    ]),
    app: String.flatten([
      Fm.Comp.js(comp.func),
      "(", Fm.Comp.js(comp.argm), ")",
    ]),
    let: String.flatten([
      "((", Fm.Name.show(comp.name), ")=>",
      Fm.Comp.js(comp.body), ")",
      "(", Fm.Comp.js(comp.expr), ")",
    ]),
  }

// Compile defs to JS
Fm.Comp.js.defs(defs: Fm.Defs): String
  let list = Map.to_list<>(defs)
  let code = ""
  for def in list with code:
    open def
    open def.snd
    let name = Fm.Name.from_bits(def.fst)
    let comp = Fm.Comp.compile(def.snd.term, Maybe.some<>(def.snd.type), defs, [])
    String.flatten([
      code,
      "var ",
      Fm.Name.show(name),
      " = ",
      case comp {
        none: "'error'",
        some: Fm.Comp.js(comp.value),
      },
      ";\n",
    ])

// Tests
// =====

Fm.source: String
  "{{FMFM}}"

main: IO(Unit)
  let defs = Maybe.default<>(Map.new<>, Fm.Defs.read(Fm.source));
  let defs = Fm.synth(defs)
  do IO {
    let report = Fm.report(defs);
    IO.print(report);
    let main = case Fm.get<>(Fm.Name.read("main"), defs) as got {
      none: Fm.Term.ref(Fm.Name.read("undefined")),
      some: case got.value { new: got.value.term },
    };
    IO.print("# Main:\n");
    IO.print(Fm.Term.show(Fm.Term.normalize(main, defs)));
    //IO.print("");
    //IO.print("# JS:\n");
    //IO.print(Fm.Comp.js.defs(defs));
  }

  //type Bool {
    //true,
    //false,
  //}

  //Bool.elim(b: Bool, P: (x:Bool) Type, t: P(Bool.true), f: P(Bool.false)): P(b)
    //case b {
      //true: t,
      //false: f,
    //} : P(b.self)

  //type Nat {
    //zero,
    //succ(pred: Nat),
  //}

  //type Vector (A: Type) ~ (size: Nat) {
    //nil ~ (size: Nat.zero),
    //ext(size: Nat, head: A, tail: Vector(A, size)) ~ (size: Nat.succ(size)),
  //}

  //type Equal (A: Type, a: A) ~ (b: A) {
    //refl ~ (b: a),
  //}

  //id(A: Type, x: A): A
    //x

  //const(A: Type, B: Type, x: A, y: B): A
    //x

  //Nat.double(n: Nat): Nat
    //case n {
      //zero: Nat.zero,
      //succ: Nat.succ(Nat.succ(Nat.double(n.pred))),
    //}

  //Nat.induce(n: Nat, P: (x:Nat) Type, z: P(Nat.zero), s: (n: Nat) (i: P(n)) P(Nat.succ(n))): P(n)
    //case n {
      //zero: z,
      //succ: s(n.pred, Nat.induce(n.pred, P, z, s)),
    //} : P(n.self)

  //Equal.apply(A: Type, B: Type, a: A, b: A, f: (x:A) B, e: Equal(A, a, b)): Equal(B, f(a), f(b))
    //case e {
      //refl: Equal.refl(B, f(a)),
    //} : Equal(B, f(a), f(e.b))

  //Nat.same(n: Nat): Nat
    //case n {
      //zero: Nat.zero,
      //succ: Nat.succ(Nat.same(n.pred)),
    //}

  //Nat.add(a: Nat, b: Nat): Nat
    //case a with b : Nat = b {
      //zero: b,
      //succ: Nat.succ(Nat.add(a.pred, b)),
    //} : Nat

  //test0: Nat
    //let n0 = Nat.zero;
    //let n1 = Nat.succ(n0);
    //let n2 = Nat.succ(n1);
    //Nat.same(n2)

  //test1(A: Type, B: Type, x: A, y: B): A
    //const(_, _, x, y)

  //Nat.add_zero(a: Nat): Equal(Nat, Nat.add(Nat.zero, a), Nat.add(a, Nat.zero))
    //case a {
      //zero:
        //Equal.refl(Nat, Nat.zero),
      //succ: 
        //let p0 = Nat.add_zero(a.pred);
        //let p1 = Equal.apply(_, _, _, _, Nat.succ, p0);
        //p1,
    //} : Equal(Nat, Nat.add(Nat.zero, a.self), Nat.add(a.self, Nat.zero))

  //Nat.add_succ(a: Nat, b: Nat): Equal(Nat, Nat.add(a, Nat.succ(b)), Nat.succ(Nat.add(a, b)))
    //case a {
      //zero:
        //Equal.refl(Nat, Nat.succ(b)),
      //succ: 
        //let p0 = Nat.add_succ(a.pred, b);
        //let p1 = Equal.apply(_, _, _, _, Nat.succ, p0);
        //p1,
    //} : Equal(Nat, Nat.add(a.self, Nat.succ(b)), Nat.succ(Nat.add(a.self, b)))

  //main: Nat
    //Nat.double(3)


