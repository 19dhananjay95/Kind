// Litereum: a minimal decentralized computer
// ==========================================

// Types
// -----

// A Litereum term
type Lit.Core.Term {
  // A variable
  var(
    bvar: Nat
  )
  // Creates a value
  create(
    type: String
    form: Nat
    vals: List<Lit.Core.Term>
  )
  // Pattern-matches a value
  match(
    type: String
    name: String
    expr: Lit.Core.Term
    cses: List<Lit.Core.Term>
  )
  // Creates a symbol
  label( 
    name: String
  )
  // Compares two labels
  compare(
    val0: Lit.Core.Term
    val1: Lit.Core.Term
    iflt: Lit.Core.Term
    ifeq: Lit.Core.Term
    ifgt: Lit.Core.Term
  )
  // Calls an external program
  call(
    bvar: String
    func: String
    argm: Lit.Core.Term
    cont: Lit.Core.Term
  )
  // Binds an new program
  bind(
    name: String
    main: Lit.Core.Term
    cont: Lit.Core.Term
  )
}

// Lit.Core types are algebraic datatypes (ADTs)
type Lit.Core.Type {
  lab
  adt(
    name: String
    forms: List<Lit.Core.Type.Form>
  )
}

// A constructor of an ADT
type Lit.Core.Type.Form {
  new(
    name: String
    fields: List<Lit.Core.Type.Field>
  )
}

// A field of an ADT's constructor
type Lit.Core.Type.Field {
  new(
    name: String
    type: String
  )
}

// A user
type Lit.Core.User {
  new(
    name: String
    pkey: String
  )
}

// A bond
type Lit.Core.Bond {
  new(
    name: String
    ownr: Maybe<String>
    main: Lit.Core.Term
    inty: String
    outy: String
  )
}

// An external call
type Lit.Core.Exec {
  new(
    user: String
    sign: String
    expr: Lit.Core.Term
  )
}

// A paragraph in a Litereum page
type Lit.Core.Line {
  new_type(value: Lit.Core.Type)
  new_bond(value: Lit.Core.Bond)
  new_user(value: Lit.Core.User)
  ext_exec(value: Lit.Core.Exec)
}

// A page of the Litereum book
Lit.Core.Page: Type
  List<Lit.Core.Line>

// A Lit.Core global entry
type Lit.Core.Entry {
  type(value: Lit.Core.Type)
  bond(value: Lit.Core.Bond)
  user(value: Lit.Core.User)
}

// Lit.Core's global state
Lit.Core.World: Type
  Map<Lit.Core.Entry>

// Getters and Setters
// -------------------

Lit.Core.World.get_type(name: String, world: Lit.Core.World): Maybe<Lit.Core.Type>
  case world{name} as entry {
    some: case entry.value {
      type: some(entry.value.value)
    } default none
  } default none
  
Lit.Core.World.get_bond(name: String, world: Lit.Core.World): Maybe<Lit.Core.Bond>
  case world{name} as entry {
    some: case entry.value {
      bond: some(entry.value.value)
    } default none
  } default none

Lit.Core.World.get_user(name: String, world: Lit.Core.World): Maybe<Lit.Core.User>
  case world{name} as entry {
    some: case entry.value {
      user: some(entry.value.value)
    } default none
  } default none

Lit.Core.Type.find_form(name: String, type: Lit.Core.Type): Maybe<Pair<Nat,Lit.Core.Type.Form>>
  case type {
    lab: none
    adt: List.ifind!((i,f) String.eql(f@name,name), type.forms)
  }

// Type-Checking
// -------------

Lit.Core.Type.equal(a: Lit.Core.Type, b: Lit.Core.Type): Bool
  case a b {
    lab lab: true
    adt adt: String.eql(a.name, b.name)
  } default false

Lit.Core.World.check.term(
  term: Lit.Core.Term
  type: Lit.Core.Type
  ctx: List<Lit.Core.Type>
  world: Lit.Core.World
): Bool
  //log("- chk " | Lit.Lang.show.term(term,world,[],0) | " : " | Lit.Lang.show.type.short(type))
  //log("- ctx " | String.join(",", List.map!!(Lit.Lang.show.type.short, ctx)))
  //log("")
  open world
  case term {
    var:
      let var_type = ctx[term.bvar] abort false
      //log("-- var " | Lit.Core.Type.show(var_type) | " " | Lit.Core.Type.show(type))
      Lit.Core.Type.equal(var_type, type)
    create: case type {
      lab:
        false
      adt:
        use term_type = Lit.Core.World.get_type(term.type,world) abort false
        if Lit.Core.Type.equal(term_type, type) then
          use form = type.forms[term.form] abort false
          Lit.Core.World.check.fields(term.vals, form.fields, ctx, world)
        else
          false
    }
    match:
      let expr_type = Lit.Core.World.get_type(term.type,world) abort false
      case expr_type {
        lab:
          false
        adt:
          let expr = Lit.Core.World.check.term(term.expr, expr_type, ctx, world)
          let cses = Lit.Core.World.check.cases(term.cses, type, expr_type.forms, ctx, world)
          expr && cses
      }
    call:
      use bond = Lit.Core.World.get_bond(term.func,world) abort false
      use inty = Lit.Core.World.get_type(bond.inty,world) abort false
      use outy = Lit.Core.World.get_type(bond.outy,world) abort false
      let argm = Lit.Core.World.check.term(term.argm, inty, ctx, world)
      let cont = Lit.Core.World.check.term(term.cont, inty, outy & ctx, world)
      argm && cont
    bind:
      // TODO: check access
      use bond = Lit.Core.World.get_bond(term.name,world) abort false
      use inty = Lit.Core.World.get_type(bond.inty,world) abort false
      use outy = Lit.Core.World.get_type(bond.outy,world) abort false
      let ctx2 = [inty, Lit.Core.Type.lab] ++ ctx
      let main = Lit.Core.World.check.term(term.main, outy, ctx2, world)
      main
  } default false

Lit.Core.World.check.fields(
  terms: List<Lit.Core.Term>
  fields: List<Lit.Core.Type.Field>
  ctx: List<Lit.Core.Type>
  world: Lit.Core.World
): Bool
  open world
  case terms fields {
    cons cons:
      let type = Lit.Core.World.get_type(fields.head@type,world) abort false
      let head = Lit.Core.World.check.term(terms.head, type, ctx, world)
      let tail = Lit.Core.World.check.fields(terms.tail, fields.tail, ctx, world)
      head && tail
    nil nil:
      true
  } default false

Lit.Core.World.check.cases(
  cases: List<Lit.Core.Term>
  type: Lit.Core.Type
  forms: List<Lit.Core.Type.Form>
  ctx: List<Lit.Core.Type>
  world: Lit.Core.World
): Bool
  case cases forms {
    cons cons:
      let ext_ctx = Lit.Core.World.check.cases.extend(forms.head@fields, ctx, world) abort false
      let case_ok = Lit.Core.World.check.term(cases.head, type, ext_ctx, world)
      let rest_ok = Lit.Core.World.check.cases(cases.tail, type, forms.tail, ctx, world)
      case_ok && rest_ok
    nil nil:
      true
  } default false

Lit.Core.World.check.cases.extend(
  fields: List<Lit.Core.Type.Field>
  ctx: List<Lit.Core.Type>
  world: Lit.Core.World
): Maybe<List<Lit.Core.Type>>
  case fields {
    nil: Maybe {
      return ctx
    }
    cons: Maybe {
      get type = Lit.Core.World.get_type(fields.head@type, world)
      Lit.Core.World.check.cases.extend(fields.tail, type & ctx, world)
    }
  }

// Execution
// ---------

Lit.Core.World.run.page(
  page: Lit.Core.Page
  world: Lit.Core.World
): Maybe<Lit.Core.World>
  case page {
    nil: some(world)
    cons: case Lit.Core.World.run.line(page.head, world) as new_world {
      none: none
      some: Lit.Core.World.run.page(page.tail, new_world.value)
    }
  }

Lit.Core.World.run.line(
  line: Lit.Core.Line
  world: Lit.Core.World
): Maybe<Lit.Core.World>
  case line {
    new_type:
      // TODO: check something?
      let type = line.value
      case type {
        lab:
          none
        adt: 
          log("- new_type: " | type.name)
          case world{type.name} as got_type {
            none: some(world{type.name} <- Lit.Core.Entry.type(type))
          } default log("error: type redefinition: " | type.name) none
      }
    new_bond:
      use bond = line.value
      log("- new_bond: " | bond.name)
      case world{bond.name} as got {
        none:
          let new_world = world{bond.name} <- Lit.Core.Entry.bond(bond)
          let inty = Lit.Core.World.get_type(bond.inty, world) abort log("error: bond inty not found: " | bond.name) none
          let outy = Lit.Core.World.get_type(bond.outy, world) abort log("error: bond outy not found: " | bond.name) none
          let pass = Lit.Core.World.check.term(bond.main, outy, [inty, Lit.Core.Type.lab], new_world)
          if pass then
            some(new_world)
          else
            log("error: bond ill-typed: " | bond.name) none
      } default log("error: bond redefinition: " | bond.name) none
    new_user:
      use user = line.value
      log("- new_user: " | user.name)
      case world{user.name} as got {
        none: some(world{user.name} <- Lit.Core.Entry.user(user))
      } default log("error: user redefinition: " | user.name) none
    ext_exec:
      use exec = line.value
      case world{exec.user} as got_entry {
        some: case got_entry.value as entry {
          user: 
            use user = entry.value
            let {result, world} = Lit.Core.World.run.term(exec.expr, exec.user, world, [])
            // TODO: swap new public_key
            //let world = world{exec.user} <- Lit.Core.Entry.user(user@pkey <- exec.pkey)
            log("- ext_exec: " | Lit.Lang.show.term(result, world, [], 0))
            some(world)
        } default log("error: exec user not a user") none
      } default log("error: exec user undefined") none
  }

Lit.Core.World.run.term(
  term: Lit.Core.Term
  self: String
  world: Lit.Core.World
  vars: List<Lit.Core.Term>
): Pair<Lit.Core.Term, Lit.Core.World>
  //log("- run " | Lit.Lang.show.term(term,world,[],0))
  //log("- var " | String.join(",", List.map!!((x) Lit.Lang.show.term(x,world,[],0), vars)))
  //log("")
  case term {
    var: 
      case vars[term.bvar] as got {
        none: {term, world}
        some: Lit.Core.World.run.term(got.value, self, world, vars)
      }
    match: Maybe {
      let {expr, world} = Lit.Core.World.run.term(term.expr, self, world, vars)
      case expr {
        create:
          let body = term.cses[expr.form] abort {term,world}
          let vars = List.reverse!(expr.vals) ++ vars
          Lit.Core.World.run.term(body, self, world, vars)
      } default {term,world}
    }
    create:
      let {vals, world} = Lit.Core.World.run.terms(term.vals, self, world, vars)
      {Lit.Core.Term.create(term.type, term.form, vals), world}
    call: case world{term.func} as got {
      none:
        {term, world}
      some: case got.value as entry {
        bond:
          use bond = entry.value
          let {argm, world} = Lit.Core.World.run.term(term.argm, self, world, vars)
          let {done, world} = Lit.Core.World.run.term(bond.main, term.func, world, argm & Lit.Core.Term.label(self) & vars)
          Lit.Core.World.run.term(term.cont, self, world, done & vars)
      } default {term,world}
    }
    bind: case world{term.name} as got {
      none:
        {term, world}
      some: case got.value as entry {
        bond:
          use bond = entry.value
          let main_vars = Lit.Core.Term.var(0) & Lit.Core.Term.var(1) & vars
          let {main, world} = Lit.Core.World.run.term(term.main, self, world, main_vars)
          let world = world{term.name} <- Lit.Core.Entry.bond(bond@main <- main)
          Lit.Core.World.run.term(term.cont, self, world, vars)
      } default {term, world}
    }
    compare: case term.val0 term.val1 {
      label label: 
        let result = case String.cmp(term.val0.name, term.val1.name) {
          ltn: term.iflt
          eql: term.ifeq
          gtn: term.ifgt
        }
        Lit.Core.World.run.term(result, self, world, vars)
    } default {term, world}
  } default {term,world}

Lit.Core.World.run.terms(
  terms: List<Lit.Core.Term>
  self: String
  world: Lit.Core.World
  vars: List<Lit.Core.Term>
): Pair<List<Lit.Core.Term>, Lit.Core.World>
  case terms {
    nil:
      {[], world}
    cons:
      let {head, world} = Lit.Core.World.run.term(terms.head, self, world, vars)
      let {tail, world} = Lit.Core.World.run.terms(terms.tail, self, world, vars)
      {head & tail, world}
  }

// Printing
// --------

Lit.Core.Type.show(type: Lit.Core.Type): String
  case type {
    lab: "Label"
    adt: type.name
  }

// Tests
// -----


Lit.Core: _

  let world = {}

  let code = `
    user MrDog {
      0123456789abcdef
    }

    type Unit {
      new
    }

    type Bool {
      true
      false
    }

    type Nat {
      zero
      succ{pred: Nat}
    }

    type NatBool {
      new{x: Nat, y: Bool}
    }

    bond not {
      case input : Bool {
        true: Bool/false
        false: Bool/true
      }
    } : Bool -> Bool

    bond double {
      case input : Nat {
        zero:
          Nat/zero
        succ:
          call rest = double(input.pred)
          Nat/succ{pred: Nat/succ{pred: rest}}
      }
    } : Nat -> Nat

    with MrDog {
      call n = double(Nat/succ{pred: Nat/succ{pred: Nat/succ{pred: Nat/zero}}})
      call b = not(Bool/true)
      NatBool/new{x: n, y: b}
    } signed {}

    bond Count.get of Count {
      Nat/zero
    } : Unit -> Nat

    bond Count.inc {
      call count.got = Count.get(Unit/new)
      bind Count.get { Nat/succ{pred: count.got} }
      Unit/new
    } : Unit -> Nat

    with MrDog {
      call x = Count.inc(Unit/new)
      call x = Count.inc(Unit/new)
      call x = Count.inc(Unit/new)
      x
    } signed {}

    with MrDog {
      call x = Count.get(Unit/new)
      x
    } signed {}
  `

  let page = Parser.run!(Lit.Lang.parser.page(world), code) abort IO.print("parse error")

  case Lit.Core.World.run.page(page, world) as result {
    none: IO.print("failure")
    some: IO.print("success")
  }
