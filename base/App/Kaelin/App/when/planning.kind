App.Kaelin.App.when.planning(
  event: App.Event,
  state: App.Store<App.Kaelin.State>
): IO<Maybe<App.State.local<App.Kaelin.State>>>
  open state
  case event {
    mouse_click:
      App.new_post!(state.global@room, event.id)
    
    key_down:
      App.set_local!(App.Kaelin.Action.local.set_cast(event.code, state)) // remove mouse pos from cast info as there is no more sense mantain it
      // switch U16.eql(event.code) {
      //   49#16: App.new_post!(state@global@room, App.Kaelin.Event.serialize(App.Kaelin.Event.create_hero(0#8)))
      // } default 

    frame:
      let update    = Bool.not(I32.eql(state@local@control_map, state@global@round))
      let new_local = App.Kaelin.Action.local.env_info(event.time, event.info, state@local)
      let new_local = App.Kaelin.Action.local.area(event.time, state@global, new_local)
      let new_local = new_local@local_map <- if update then state@global@map else new_local@local_map
      let new_local = new_local@control_map <- if update then state@local@control_map + 1 else state@local@control_map
      IO {
        
        App.set_local!(new_local)
      }
      
    mouse_up:
      let cast = state.local@cast_info
      case cast { //Organize
        some:
          open cast.value
          let info       = state.local@env_info
          let target_pos = App.Kaelin.Coord.to_axial(info@mouse_pos)
          let key        = cast.value@skill@key
          let hex        = App.Kaelin.Event.serialize(App.Kaelin.Event.save_skill(state@local@user, target_pos, key, state@local@team))
          let new_local  = state@local@cast_info <- none
          let new_local  = new_local@local_map <- App.Kaelin.Map.exe_skill(new_local@user, target_pos, key, local_map)
          IO { 
            App.new_post!(state@global@room, hex)
            App.set_local!(new_local)
          }
      } default App.pass!
      
  } default App.pass!