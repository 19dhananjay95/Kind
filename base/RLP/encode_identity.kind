RLP.encode_identity(
  rlp: RLP
  H: Equal<Bool>(Nat.lte(List.length(U8, RLP.encode(rlp)), RLP.max), true)
): RLP.decode(RLP.encode(rlp)) == rlp
    // first rewrite the bound on the length of the encoding
    // so we're able to call the lemma
    let H = case List.concat.length(U8, RLP.encode(rlp), List.nil(U8)) {
      refl:
        case mirror(Nat.add.zero_right(List.length(U8, RLP.encode(rlp)))) {
          refl:
            H
         }: Equal<Bool>(Nat.lte(self.b, RLP.max), true)
    }: Equal(Bool, Nat.lte(self.b, RLP.max), true)
    let lemma = RLP.encode_identity.many([rlp], H)

    // simplify concatenation with empty list
    let lemma = case mirror(List.concat.nil_right(U8,RLP.encode(rlp))) {
      refl:
        lemma
    }: Equal(List(RLP), RLP.decode.many(self.b), List.cons(RLP,rlp,List.nil(RLP)))
    let lemma = mirror(lemma)

    // substitute lemma inside goal
    case lemma {
      refl:
        refl
    }: Equal(RLP, Maybe.default(RLP,List.head(RLP,lemma.b),RLP.data(List.nil(U8))), rlp)
