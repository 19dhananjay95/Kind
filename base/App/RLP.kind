App.RLP.article: DOM
  <article> 
  <h3>` Kind is amazing ^-^ `</h3>
  <p>`
  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
  incididunt ut labore et dolore magna aliqua. Nibh ipsum consequat nisl vel
  pretium lectus quam id. Tempor orci eu lobortis elementum nibh. Nulla facilisi
  cras fermentum odio eu feugiat. Est velit egestas dui id. Blandit aliquam
  etiam erat velit. 
  `</p>
  <p>`
  Donec ultrices tincidunt arcu non. Eu nisl nunc mi ipsum faucibus vitae
  aliquet nec. Duis tristique sollicitudin nibh sit amet commodo nulla facilisi
  nullam. Malesuada bibendum arcu vitae elementum curabitur vitae nunc sed
  velit. Nullam eget felis eget nunc lobortis mattis aliquam faucibus purus. 
  `</p>
  </article>

App.RLP.State: App.State
  App.State.new(App.RLP.State.Local, App.RLP.State.Global)

type App.RLP.State.Local {
  new(
    decoded_input: String
    encoded_input: String
    decoded_result: String
    encoded_result: String
    decoded_input_invalid: Bool
    encoded_input_invalid: Bool
  )
}

App.RLP.State.Local.default: App.RLP.State.Local
  let init_decoded = `["hihi"]`
  let init_encoded =
    case Parser.run!(Ether.RLP.parser, init_decoded) {
      none: ""
      some: App.RLP.encode(self.value)
    }
  App.RLP.State.Local.new(
    init_decoded
    init_encoded
    init_decoded
    init_encoded 
    false
    false
  )

App.RLP.State.Global: Type
  Unit

App.RLP.css: String
  `
    .hidden {
      display: none !important;
    }
    .center-box {
      margin: auto;
      max-width: 512px;
    }
    main > * {
      margin-bottom: 1em;
    }
    main hr {
      border-color: #FDFDFD;
    }
    .page-block {
      width: 100%;
      padding: 16px;
    }
    .page-block.bg {
      border-radius: 8px;
      background-color: rgb(245,245,245);
    }
    .block-label {
      padding-bottom: 0.5em;
    }
    textarea.text-input {
      width: 100%;
      min-height: 10em;
    }
    textarea.text-input.invalid {
      border-color: red;
    }
    .button-wrapper button {
      display: inline-block;
      margin-left: auto;
      margin-right: 0;
    }
    article * {
      margin-bottom: 1em;
    }
    footer {
      display: flex;
      justify-content: space-between;
      padding: 2em 1em;
    }
  `

App.RLP.draw(state: App.RLP.State.Local): DOM
  let add_invalid =
    (flag: Bool, txt: String)
      if flag then txt | " invalid" else txt
  <div>
  <style> App.RLP.css </style>
  <script>`
    document.getElementById('btn-decode').onclick = () => {
      const input_el = document.getElementById('decoded-input');
      input_el.value =
        document.getElementById('decoded-result').innerText;
      const ev = new Event('input');
      input_el.dispatchEvent(ev);
    }
    document.getElementById('btn-encode').onclick = () => {
      const input_el = document.getElementById('encoded-input');
      input_el.value =
        document.getElementById('encoded-result').innerText;
      const ev = new Event('input');
      input_el.dispatchEvent(ev);
    }
  `</script>
  <main class="center-box">
    <div class="page-block">
      <h1> "RLP encoder/decoder" </h1>
      <p class="subtitle"> "Formally verified with Kind!" </p>
    </div>
    <div class="page-block bg">
      <p class="block-label">
        "Decoded:"
      </p>
      <textarea id="decoded-input"
        class=add_invalid(state@decoded_input_invalid)("text-input")
        // value=state@decoded_result
        >
        state@decoded_input
      </textarea>
      <div class="button-wrapper">
        <button id="btn-encode">` Encode `</button>
      </div>
    </div>
    <div class="page-block bg">
      <p class="block-label">
        "Encoded:"
      </p>
      <textarea id="encoded-input"
        class=add_invalid(state@encoded_input_invalid)("text-input")
        // value=state@encoded_result
        >
        state@encoded_input
      </textarea>
      <div class="button-wrapper">
        <button id="btn-decode">` Decode `</button>
      </div>
    </div>
    <p class="hidden" id="encoded-result"> state@encoded_result </p>
    <p class="hidden" id="decoded-result"> state@decoded_result </p>
    <hr></hr>
    <div class="page-block bg">
      { App.RLP.article }
    </div>
  </main>
  <footer class="center-box">
    <div id="join-us">
      <p><strong>` Join Us `</strong></p>
      <p><a href="https://github.com/kind-lang/Kind">
        `Github`
      </a></p>
      <p><a href="https://t.me/formality_lang">
        `Telegram`
      </a></p>
    </div>
    <div>
      `made with ‚ù§ using `
      <a href="https://github.com/kind-lang/Kind">
        `Kind-lang`
      </a>
      // ` by ??`
    </div>
  </footer>
  </div>

App.RLP.IO: Type
  IO<Maybe<App.State.local(App.RLP.State)>>

App.RLP.when(
  event: App.Event
  store: App.Store<App.RLP.State>
): App.RLP.IO
  let state = store@local
  case event {
    input:
      switch String.eql(event.id) {
        "decoded-input":
          log("decoded input: " | event.text)
          let input = event.text
          let state = state@decoded_input <- input 
          let state = state@decoded_input_invalid <- false
          App.RLP.do_encode(state, input)
        "encoded-input":
          log("encoded input: " | event.text)
          let input = event.text
          let state = state@encoded_input <- input 
          let state = state@decoded_input_invalid <- false
          App.RLP.do_decode(state, input)
      } default App.pass!
    // mouse_click:
    //   switch String.eql(event.id) {
    //     "btn-encode":
    //       let input = state@decoded_input
    //       App.pass!
    //     "btn-decode":
    //       let input = state@encoded_input
    //       App.pass!
    //   } default App.pass!
  } default App.pass!

App.RLP.do_decode(state: App.RLP.State.Local, input: String): App.RLP.IO
  let valid =
    (Nat.mod(String.length(input), 2) =? 0) && String.is_hex(input)
  if not(valid) then
    App.set_local!(state@encoded_input_invalid <- true)
  else
    App.set_local!(state@decoded_result <- App.RLP.decode(input))

App.RLP.do_encode(state: App.RLP.State.Local, input: String): App.RLP.IO
  case Parser.run!(Ether.RLP.parser, input) {
    none:
      App.set_local!(state@decoded_input_invalid <- true)
    some:
      App.set_local!(state@encoded_result <- App.RLP.encode(self.value))
  }

App.RLP.decode(input: String): String
  Ether.RLP.show(Ether.RLP.decode(Bytes.from_hex(input)))

App.RLP.encode(input: Ether.RLP): String
  Bytes.to_hex(Ether.RLP.encode(input))

App.RLP: App(App.RLP.State)
  let init =
    App.Store.new!(
      App.RLP.State.Local.default
      Unit.new
    )
  def St = App.RLP.State
  let draw = (state) App.RLP.draw(state@local)
  let when = App.RLP.when
  let tick = App.no_tick<St>
  let post = App.no_post<St>
  App.new!(init, draw, when, tick, post)
