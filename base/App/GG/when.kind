// Event handler
App.GG.when: App.When<App.GG.State>
  (event, state)
  let local = state@local
  case event {
    // init: IO {
    //   App.watch!(App.room_zero)
    //   App.new_post!(App.room_zero, "")
    // }
    frame:
      let new_grid = App.GG.when.update_grid(local@grid)
      let new_local = local@grid <- new_grid
      App.set_local<App.GG.State>(new_local)
    key_down:
      log("Key pressed: " |U16.show(event.code))
      let grid = local@grid
      if (event.code <? 41#16) && (event.code >? 36) then
        let coord = App.GG.Slime.find_coord(grid)
        without coord: App.pass!
        let new_grid = App.GG.Creature.modify_at(App.GG.when.add_action(App.GG.Actions.movement(event.code)), coord@snd, grid)
        let new_local = local@grid <- new_grid
        App.set_local<App.GG.State>(new_local)
      else
        switch U16.eql(event.code) {
          // Spacebar
          32#16: 
            let new_grid = App.GG.when.use_chip(local@grid)
            let new_local = local@grid <- new_grid
            App.set_local<App.GG.State>(new_local)
          // Return
          13#16:
            case local@phase as phase {
              setup: 
                let grid = local@grid
                let new_grid = Maybe {
                  get pair = App.GG.Slime.find_coord(grid)
                  let {creature, coord} = pair
                  get slime = 
                    case creature@category as monster {
                      minion: none
                      slime: 
                        let data = monster.data
                        let hand = phase.hand 
                        log(Nat.show(List.length!(hand)))
                        let fold = monster.folder ++ List.somes!(List.map!!((x: App.GG.Table.Slot) x@chip, phase.table))
                        let enrg = monster.energy 
                        some(App.GG.Monster.slime(data, hand, fold, enrg))
                    }
                  let new_grid = App.GG.Creature.modify_at((c: App.GG.Creature) c@category <- slime , coord, grid)
                  return new_grid
                } <> grid
                let new_phase = App.GG.Phase.game
                let new_local = local@grid <- new_grid
                let new_local = new_local@phase <- new_phase
                App.set_local<App.GG.State>(new_local)
              game: App.pass<App.GG.State>
            }
          }default App.pass<App.GG.State>
    mouse_move:
      // log("x: " | U32.show(event.mouse_pos@fst) | "  y: " | U32.show(event.mouse_pos@snd))
      // let {x, y} = {event.mouse_pos@fst / 4, event.mouse_pos@snd / 4}
      // switch Point_to_rectangle({x,y}) {
      //   App.GG.when.table:
      //     let x = x - (App.GG.draw.chips_starting_position@fst - (App.GG.draw.chip_size@fst/2))
      //     let y = y - (App.GG.draw.chips_starting_position@snd - (App.GG.draw.chip_size@snd/2))
      //     let a = App.GG.when.chip({x, y})
      //     let j = 
      //       case a {
      //         none: log("none") unit
      //         some: log(Nat.show(a.value)) unit
      //       }
      //     App.pass<App.GG.State>
      // }default App.pass<App.GG.State>
      let new_local = local@mouse <- event.mouse_pos
      App.set_local<App.GG.State>(new_local)
    mouse_down:
      App.GG.when.click_element(local, local@mouse)      
  } default App.pass<App.GG.State>

App.GG.when.update_grid(grid: App.GG.Grid): App.GG.Grid
  let new_grid = grid 
  for coord:tile in grid with new_grid:
    App.GG.when.update_tile(coord, new_grid)
  new_grid
    

App.GG.when.click_element(local: App.GG.State.local, mouse: Pair<U32, U32>): IO<Maybe<App.State.local<App.GG.State>>>
  //log("x: " | U32.show(event.mouse_pos@fst) | "  y: " | U32.show(event.mouse_pos@snd))
  case local@phase as phase {
    setup:
      let {x, y} = {mouse@fst / 4, mouse@snd / 4}
      switch Point_to_rectangle({x,y}) {
        App.GG.when.table:
          let x = x - (App.GG.draw.chips_starting_position@fst - (App.GG.draw.chip_size@fst/2))
          let y = y - (App.GG.draw.chips_starting_position@snd - (App.GG.draw.chip_size@snd/2))
          let a = App.GG.when.chip({x, y})
          Maybe {
            get nat = App.GG.when.chip({x, y})
            log(Nat.show(nat))
            get item = List.get!(nat, phase.table)
            get chip = item@chip 
            let new_hand = chip & phase.hand
            let new_item = item@chip <- none
            let new_table = phase.table[nat] <- new_item
            let new_local = local@phase <- App.GG.Phase.setup(new_table, new_hand, phase.energy)
            return App.set_local<App.GG.State>(new_local)
          } <> App.pass<App.GG.State>
      }default App.pass<App.GG.State>
    game: App.pass<App.GG.State>
  }


type Rectangle {
  new(x1: U32, x2: U32, y1: U32, y2: U32)
}

Point_to_rectangle(point: Pair<U32, U32>, rect: Rectangle): Bool
  let {x1, x2} = {rect@x1, rect@x2}
  let {y1, y2} = {rect@y1, rect@y2}
  let {px, py} = point
    (px >=? x1) && 
    (px <=? x2) && 
    (py >=? y1) && 
    (py <=? y2)

App.GG.when.table: Rectangle
  let {x1, y1} = {(App.GG.draw.chips_starting_position@fst - (App.GG.draw.chip_size@fst/2)) (App.GG.draw.chips_starting_position@snd - (App.GG.draw.chip_size@snd/2))}
  let {vx, vy} = App.GG.draw.chips_variation
  let {cx, cy} = App.GG.draw.chip_size
  let {r,  c } = App.GG.draw.chips_line_size
  let {x2, y2} = {x1 + ((cx + vx) * r), y1 + ((cy + vy) * c)}
  log(U32.show(x1) | " " | U32.show(x2) | " " | U32.show(y1) | " " | U32.show(y2))
  Rectangle.new(x1, x2, y1, y2)


App.GG.when.chip(mouse_pos: Pair<U32, U32>): Maybe<Nat>
  let {r,   c  } = App.GG.draw.chips_line_size
  let {x,   y  } = mouse_pos
  let {v_x, v_y} = App.GG.draw.chips_variation              // Space between Chips
  let {c_x, c_y} = App.GG.draw.chip_size                    // Chips size
  let {t_x, t_y} = {c_x + v_x, c_y + v_y}
  let {s_x, s_y} = {x % t_x, y % t_y}
  let row        = x / t_x
  let column     = y / t_y
  if ((x % (c_x + v_x)) <? c_x) && ((y % (c_y + v_y)) <? c_y) then 
    some(U32.to_nat(column + (row * c)))
  else
    none


App.GG.when.update_tile(coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  let new_grid = 
    Maybe {
      get creature = App.GG.Creature.get(coord, grid)
      let mod = (x) App.GG.when.update_frame(App.GG.when.update_action(x))
      let new_grid = App.GG.Creature.modify_at(mod, coord, grid)
      return new_grid
    } <> grid

  let new_grid = 
    Maybe {
      get creature = App.GG.Creature.get(coord, new_grid)
      get action = creature@actions@current 
      get hasnt_acted = if creature@actions@has_acted then none else some(unit)
      let origin = App.GG.Effect.Origin.creature
      let result = action@effect(coord, origin, new_grid) 
      get new_grid = case result {err: none, new: some(result.grid)}
      return new_grid
    } <> new_grid

  let new_grid =
    Maybe {
      get projectiles = App.GG.Projectile.get_list(coord, new_grid)
      let pair = {0, new_grid}
      for projectile in projectiles with pair:
        let {idx, new_grid} = pair
        let origin = App.GG.Effect.Origin.projectile(idx)
        let result = projectile@effect(coord, origin, new_grid)
        let new_grid = case result {err: new_grid, new: result.grid}
        {idx +1, new_grid}
      return pair@snd
    } <> new_grid


  new_grid

App.GG.when.use_chip(grid: App.GG.Grid): App.GG.Grid
  let pair = App.GG.Slime.find_coord(grid)
  case pair {
    none: log("1")  grid
    some:
      let {creature, coord} = pair.value
      case creature@category as category {
        minion: log("2") grid
        slime:
          case category.hand {
            nil: log("3") grid
            cons: 
              log("4")
              open category.hand.head
              let action = App.GG.Actions.Data.new(0, category.hand.head.effect, App.GG.Actions.Category.chip)
              App.GG.Creature.modify_at(App.GG.when.add_action(action), coord, grid)
          }
      }
  }

App.GG.when.update_frame(creature: App.GG.Creature): App.GG.Creature
  let new_creature = creature@animation <- {creature@animation@fst, creature@animation@snd + 1}
  new_creature

App.GG.when.update_action(creature: App.GG.Creature): App.GG.Creature
  let as = creature@actions
  let na = as@next
  let a  = as@current
  if as@has_acted then creature else 
    case a {
      none:
        case na {
          none: creature
          some:
            //log("22") 
            let new_actions = as@current <- some(na.value)
            let new_actions = new_actions@next <- none
            let new_creature = creature@actions <- new_actions
            new_creature
        }
      some:
        creature
    }


App.GG.when.add_action(action: App.GG.Actions.Data, creature: App.GG.Creature): App.GG.Creature
  let actions = creature@actions
  
  let new_actions = actions@next <- some(action)
  creature@actions <- new_actions

