// ::::::::::
// :: Bool ::
// ::::::::::

// Bool datatype. Desugars to self-encoded datatypes.
// def Bool       : Type = $ self {~P : {b : Bool} -> Type, T : (P Bool.true), F : (P Bool.false)} -> (P self)
// def Bool.true  : Bool = new Bool {~P, T, F} => T
// def Bool.false : Bool = new Bool {~P, T, F} => F
T Bool
| true
| false 

// Simple not
Bool.not : {|b : Bool} -> Bool
| true  = Bool.false
| false = Bool.true

// Simple and
Bool.and : {|b0 : Bool, |b1 : Bool} -> Bool
| true  | true  = Bool.true
        | false = Bool.false
| false | true  = Bool.false
        | false = Bool.false

// Simple or
Bool.or : {|b0 : Bool, |b1 : Bool} -> Bool
| true  | true  = Bool.true
        | false = Bool.true
| false | true  = Bool.true
        | false = Bool.false

// Not with runtime fusion
Bool.not_f : {b : Bool} -> Bool
  new Bool {~P, T, F} =>
    let moti       = {b} => P(Bool.not_f(b))
    let case_true  = F
    let case_false = T
    (%b)(~moti, case_true, case_false)

// Type of boolean induction
Bool.induction : {b : Bool} -> Type
  {~P : {b : Bool} -> Type
  , T : P(Bool.true)
  , F : P(Bool.false)
  } -> P(b)

// Boolean induction is just `%b`.
Bool.induct : {b : Bool} -> Bool.induction(b)
  %b

// Boolean example
Bool.example
  Bool.and(Bool.or(Bool.true, Bool.false), Bool.true)

// :::::::::
// :: Nat ::
// :::::::::

// A natural number. Desugars to:
// Nat      : Type             = $ self {~P : {n : Nat} -> Type, S : {n : Nat} -> (P (Nat.succ n)), Z : (P Nat.zero)} -> (P self)
// Nat.succ : {n : Nat} -> Nat = {n, ~P, S, Z} => (S n)
// Nat.zero : Nat              = {~P, S, Z} => Z
T Nat
| succ {pred : Nat}
| zero

Nat.pred : {|n : Nat} -> Nat
| succ = n.pred
| zero = Nat.zero

Nat.pred.example
  Nat.pred(Nat.succ(Nat.succ(Nat.zero)))

Nat.predif : {|n : Nat, |b : Bool} -> Nat
| succ | true  = n.pred
       | false = Nat.succ(n.pred)
| zero | true  = Nat.zero
       | false = Nat.zero

// Recursive functions must be boxed (annotated with `:!`). They must also
// provide a "halt" case with `*`, which will be returned in the case the
// function runs out of "gas". That's because Formality is terminating. This is
// NOT a "native" "bounded recursion" feature, instead, it is desugared to
// `rec(TYPE, {r} => func[func <- r], halt)`. Notice that the `rec`, the
// function that repeatedly calls `func` as many times as needed, must be in
// scope. See `rec` below to see how Church nats can be used for that.
Nat.double :! {n : Nat} -> Nat
  case<Nat> n
  | succ => Nat.succ(Nat.succ(Nat.double(pred)))
  | zero => Nat.zero
  : Nat
  * n

// Non-recursive functions that use recursive functions must also be boxed.
// They must unbox the recursive functions they use.
Nat.double.example :! Nat
  unbox Nat.double
  Nat.double(Nat.succ(Nat.zero))

// ::::::::::
// :: List ::
// ::::::::::

T List <A : Type>
| push  {head : A, tail : List(A)}
| empty

// The dependent pattern match syntax is still not able to deal with indices,
// so we must use the `case` syntax
List.head : {~T : Type, default : T, list : List(T)} -> T
  case<List> list
  | push  => head
  | empty => default
  : T

List.tail : {~T : Type, list : List(T)} -> List(T)
  case<List> list
  | push  => tail
  | empty => List.empty(~T)
  : List(T)

List.map :! {~A : Type, fn : !{x : A} -> A, list : List(!A)} -> List(!A)
  dup fn = fn
  case<List> list
  | push =>
    dup head = head
    let head = #fn(head)
    let tail = List.map<A>(#fn, tail)
    List.push<!A>(head, tail)
  | empty =>
    List.empty<!A>
  : List(!A)
  * list
  
List.map.example
  dup List.map = List.map
  let list = List.empty<!U32>
  let list = List.push<!U32>(#1, list)
  let list = List.push<!U32>(#2, list)
  let list = List.push<!U32>(#3, list)
  # List.map<U32>(#{x} => |x * 2|, list)

// ::::::::::::
// :: Vector ::
// ::::::::::::

// A vector with a statically known length.
T Vector <A : Type> {len : Nat}
| push {~len : Nat, head : A, tail : Vector(A, len)} & Nat.succ(len)
| empty                                              & Nat.zero

// A type-safe `head` that *can't* be used on empty vectors.
Vector.head : {~T : Type, n : Nat, vector : Vector(T, Nat.succ(n))} -> T
  case<Vector> vector
  | push  => head
  | empty => 0
  : case<Nat> len
    | succ => T
    | zero => U32
    : Type

Vector.tail : {~T : Type, n : Nat, vector : Vector(T, n)} -> Vector(T, Nat.pred(n))
  case<Vector> vector
  | push  => tail
  | empty => Vector.empty(~T)
  : Vector(T, Nat.pred(len))

// :::::::::
// :: Rec ::
// :::::::::

// A Rec is a Parigot (erased to Church) of a Nat. It has this name because
// those encodings should be used for recursion, not to store data. The ADT
// syntax still doesn't allow making those datatypes, so I encode manually.

Rec : Type
  $ self {
   ~P : {n : Rec} -> Type
  , C : ! {~n : Rec, i : P(n)} -> P(Rec.call(n))
  , S : ! P(Rec.halt)
  }  -> ! P(self)

Rec.call : {n : Rec} -> Rec
  new Rec {~P, C, S} =>
  dup C = C
  dup S = S
  dup A = (%n)(~P, #C, #S)
  # C(~n, A)

Rec.halt : Rec
  new Rec {~P, C, S} =>
  S

// This "fuels" recursive functions. Here, I use `Rec.256` (defined below),
// which gives us a "bound" of 256 calls per recursive function. This can be
// changed to be a very large number (i.e., 2^64 for example).
rec : {~T : Type, call : !{x : T} -> T, halt : !T} -> !T
  dup call = call
  dup halt = halt
  (%Rec.256)(~{r} => T, #{~n} => call, #halt)

Rec.induction : {n : Rec} -> Type
  {~P : {n : Rec} -> Type
  , C : ! {~n : Rec, i : P(n)} -> P(Rec.call(n))
  , S : ! P(Rec.halt)
  } -> ! P(n)

Rec.induct : {n : Rec} -> Rec.induction(n)
  %n

Rec.double : {n : Rec} -> Rec
  new Rec {~P, call, halt} =>
  dup call = call
  dup halt = halt
  let moti = {n} => P(Rec.double(n))
  let call = # {~n, i} => call(~Rec.call(Rec.double(n)), call(~Rec.double(n), i))
  let halt = # halt
  (%n)(~moti, call, halt)

Rec.256 : Rec
  Rec.double(Rec.double(Rec.double(Rec.double(
  Rec.double(Rec.double(Rec.double(Rec.double(
  Rec.call(Rec.halt)))))))))

// Runtime fusion on repeated not
Rec.example
  let moti = {n}     => Bool
  let call = {~n, x} => Bool.not_f(x)
  let halt = Bool.true
  (%Rec.256)(~moti, #call, #halt)

// ::::::::::
// :: Main ::
// ::::::::::

main
  Nat.double.example
