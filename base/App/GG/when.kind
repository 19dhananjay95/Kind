// Event handler
App.GG.when: App.When<App.GG.State>
  (event, state)
  let local = state@local
  let phase = local@phase
  case event {
    // init: IO {
    //   App.watch!(App.room_zero)
    //   App.new_post!(App.room_zero, "")
    // }
    frame:
      case phase {
        setup:
          App.pass<App.GG.State>
        game:
          let new_grid  = App.GG.when.update_grid(local@grid)
          let new_phase = App.GG.when.update_phase(phase)
          let new_local = local@grid <- new_grid
          let new_local = new_local@phase <- new_phase
          App.set_local<App.GG.State>(new_local)
      }
      
    key_down:
      log("Key pressed: " |U16.show(event.code))
      case phase {
        setup:
          switch U16.eql(event.code) {
            13#16: App.GG.when.setup_to_game(local)
          }default App.pass<App.GG.State> 
        game: 
          switch U16.eql(event.code) {
            37#16:  App.GG.when.move(local, App.GG.Arrow.left)
            38#16:  App.GG.when.move(local, App.GG.Arrow.up)
            39#16:  App.GG.when.move(local, App.GG.Arrow.right)
            40#16:  App.GG.when.move(local, App.GG.Arrow.down)
            // X 
            88#16:
              let new_grid = App.GG.when.basic_attack(local@grid)
              let new_local = local@grid <- new_grid
              App.set_local<App.GG.State>(new_local)
            // Spacebar
            32#16: 
              let new_grid = App.GG.when.use_chip(local@grid)
              let new_local = local@grid <- new_grid
              App.set_local<App.GG.State>(new_local)
            // Return
            13#16: App.GG.when.game_to_setup(local)
          }default App.pass<App.GG.State> 
      }
    mouse_move:
      // log("x: " | U32.show(event.mouse_pos@fst) | "  y: " | U32.show(event.mouse_pos@snd))
      let new_local = local@mouse <- event.mouse_pos
      App.set_local<App.GG.State>(new_local)
    mouse_down:
      App.GG.when.click_element(local, local@mouse)      
  }default App.pass<App.GG.State>

App.GG.when.update_grid(grid: App.GG.Grid): App.GG.Grid
  let new_grid = grid 
  for coord:tile in grid with new_grid:
    App.GG.when.update_tile(coord, new_grid)
  new_grid
    
App.GG.when.setup_to_game(local: App.GG.State.local): IO<Maybe<App.State.local<App.GG.State>>>
  let grid = local@grid
  case local@phase as phase {
    setup: 
      let new_grid = Maybe {
        get pair = App.GG.Slime.find_coord(grid)
        let {creature, coord} = pair
        get slime = 
          case creature@category as monster {
            minion: none
            slime: 
              let data = monster.data
              let hand = phase.hand
              let fold = monster.folder ++ List.somes!(List.map!!((x: App.GG.Table.Slot) x@chip, phase.table))
              let enrg = monster.energy 
              some(App.GG.Monster.slime(data, hand, fold, enrg))
          }
        let new_grid = App.GG.Creature.modify_at((c: App.GG.Creature) c@category <- slime , coord, grid)
        return new_grid
      } <> grid
      let new_phase = App.GG.Phase.game(0#64)
      let new_local = local@grid <- new_grid
      let new_local = new_local@phase <- new_phase
      App.set_local<App.GG.State>(new_local)

    game: App.pass<App.GG.State>
  }

App.GG.when.game_to_setup(local: App.GG.State.local): IO<Maybe<App.State.local<App.GG.State>>>
  let grid = local@grid
  case local@phase as phase {
    setup: App.pass<App.GG.State>
    game:
      if U64.gte(phase.turn_bar, 1200) then
        let slime = App.GG.Slime.find_coord(grid)
        without slime: App.pass<App.GG.State>
        let {creature, coord} = slime
        case creature@category as monster {
          minion: App.pass<App.GG.State>
          slime:
            let table_size = 10
            let mod = App.GG.Creature.sub_folder(table_size)
            let table = App.GG.Table.from_folder(table_size, monster.folder)
            let hand = [] :: App.GG.Chips
            let energy = monster.energy + monster.data@dna@attributes@energy
            let phase = App.GG.Phase.setup(table, hand, energy)
            let new_grid  = App.GG.Creature.modify_at(mod, coord, grid)
            let new_local = local@phase <- phase
            let new_local = new_local@grid <- new_grid
            App.set_local<App.GG.State>(new_local)
        }
      else
        App.pass<App.GG.State>
  }

App.GG.when.move(local: App.GG.State.local, arrow: App.GG.Arrow): IO<Maybe<App.State.local<App.GG.State>>>
  let grid            = local@grid
  let slime_coord     = App.GG.Slime.find_coord(grid)
  without slime_coord : App.pass<App.GG.State>
  let {slime, coord}  = slime_coord
  let move_action     = App.GG.Actions.movement(arrow)
  let mod_creature    = App.GG.when.add_action(move_action)
  let new_grid        = App.GG.Creature.modify_at(mod_creature, coord, grid)
  let new_local       = local@grid <- new_grid
  App.set_local<App.GG.State>(new_local)

App.GG.when.click_element(local: App.GG.State.local, mouse: Pair<U32, U32>): IO<Maybe<App.State.local<App.GG.State>>>
  //log("x: " | U32.show(event.mouse_pos@fst) | "  y: " | U32.show(event.mouse_pos@snd))
  case local@phase as phase {
    setup:
      let {x, y} = {mouse@fst / 4, mouse@snd / 4}
      let point = V2.new(U32.to_f64(x), U32.to_f64(y))
      switch Shape.Point.collision.rectangle(point) {
        App.GG.when.table:
          let x = x - (App.GG.Constants.chips_starting_position@fst - (App.GG.Constants.chip_size@fst/2))
          let y = y - (App.GG.Constants.chips_starting_position@snd - (App.GG.Constants.chip_size@snd/2))
          let a = App.GG.when.chip({x, y})
          Maybe {
            get nat = App.GG.when.chip({x, y})
            log(Nat.show(nat))
            get item = List.get!(nat, phase.table)
            get chip = item@chip 
            let new_hand = chip & phase.hand
            let new_item = item@chip <- none
            let new_table = phase.table[nat] <- new_item
            let new_local = local@phase <- App.GG.Phase.setup(new_table, new_hand, phase.energy)
            return App.set_local<App.GG.State>(new_local)
          } <> App.pass<App.GG.State>
      }default App.pass<App.GG.State>
    game: App.pass<App.GG.State>
  }


App.GG.when.update_phase(phase: App.GG.Phase): App.GG.Phase
  case phase {
    setup: phase
    game: App.GG.Phase.game(phase.turn_bar + 2)
  }



App.GG.when.table: Shape.Rectangle
  let {x1, y1} = {(App.GG.Constants.chips_starting_position@fst - (App.GG.Constants.chip_size@fst/2)) (App.GG.Constants.chips_starting_position@snd - (App.GG.Constants.chip_size@snd/2))}
  let {vx, vy} = App.GG.Constants.chips_space_between
  let {cx, cy} = App.GG.Constants.chip_size
  let {r,  c } = App.GG.Constants.chips_array
  let {x2, y2} = {x1 + ((cx + vx) * r), y1 + ((cy + vy) * c)}
  log(U32.show(x1) | " " | U32.show(x2) | " " | U32.show(y1) | " " | U32.show(y2))
  Shape.Rectangle.new(U32.to_f64(x1), U32.to_f64(x2), U32.to_f64(y1), U32.to_f64(y2))


App.GG.when.chip(mouse_pos: Pair<U32, U32>): Maybe<Nat>
  let {r,   c  } = App.GG.Constants.chips_array
  let {x,   y  } = mouse_pos
  let {v_x, v_y} = App.GG.Constants.chips_space_between              // Space between Chips
  let {c_x, c_y} = App.GG.Constants.chip_size                    // Chips size
  let {t_x, t_y} = {c_x + v_x, c_y + v_y}
  let {s_x, s_y} = {x % t_x, y % t_y}
  let row        = x / t_x
  let column     = y / t_y
  if ((x % (c_x + v_x)) <? c_x) && ((y % (c_y + v_y)) <? c_y) then 
    some(U32.to_nat(column + (row * c)))
  else
    none


App.GG.when.update_tile(coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  let new_grid = 
    Maybe {
      get creature = App.GG.Creature.get(coord, grid)
      let mod = (x) App.GG.when.update_frame(App.GG.when.update_action(x))
      let new_grid = App.GG.Creature.modify_at(mod, coord, grid)
      return new_grid
    } <> grid

  let new_grid = 
    Maybe {
      get creature = App.GG.Creature.get(coord, new_grid)
      get action = creature@actions@current 
      get hasnt_acted = if creature@actions@has_acted then none else some(unit)
      let origin = App.GG.Effect.Origin.creature
      let result = action@effect(coord, origin, new_grid) 
      get new_grid = case result {err: none, new: some(result.grid)}
      return new_grid
    } <> new_grid

  let new_grid =
    Maybe {
      get projectiles = App.GG.Projectile.get_list(coord, new_grid)
      let pair = {0, new_grid}
      for projectile in projectiles with pair:
        let {idx, new_grid} = pair
        let origin = App.GG.Effect.Origin.projectile(idx)
        let result = projectile@effect(coord, origin, new_grid)
        let new_grid = case result {err: new_grid, new: result.grid}
        {idx +1, new_grid}
      return pair@snd
    } <> new_grid

  new_grid

App.GG.when.basic_attack(grid: App.GG.Grid): App.GG.Grid
  let pair = App.GG.Slime.find_coord(grid)
  case pair {
    none: grid
    some:
      let {creature, coord} = pair.value
      case creature@category as category {
        minion: grid
        slime:
          case category.hand {
            nil: grid
            cons: 
              let action = App.GG.Actions.basic_attack
              App.GG.Creature.modify_at(App.GG.when.add_action(action), coord, grid)
          }
      }
  }


App.GG.when.use_chip(grid: App.GG.Grid): App.GG.Grid
  let pair = App.GG.Slime.find_coord(grid)
  case pair {
    none: grid
    some:
      let {creature, coord} = pair.value
      case creature@category as category {
        minion: grid
        slime:
          case category.hand {
            nil: grid
            cons: 
              let action = App.GG.Actions.Data.new(0, category.hand.head@effect, App.GG.Actions.Category.chip)
              App.GG.Creature.modify_at(App.GG.when.add_action(action), coord, grid)
          }
      }
  }

App.GG.when.update_frame(creature: App.GG.Creature): App.GG.Creature
  let new_creature = creature@animation <- {creature@animation@fst, creature@animation@snd + 1}
  new_creature

App.GG.when.update_action(creature: App.GG.Creature): App.GG.Creature
  let as = creature@actions
  let na = as@next
  let a  = as@current
  if as@has_acted then creature else 
    case a {
      none:
        case na {
          none: creature
          some:
            //log("22") 
            let new_actions = as@current <- some(na.value)
            let new_actions = new_actions@next <- none
            let new_creature = creature@actions <- new_actions
            new_creature
        }
      some:
        creature
    }


App.GG.when.add_action(action: App.GG.Actions.Data, creature: App.GG.Creature): App.GG.Creature
  let actions = creature@actions
  
  let new_actions = actions@next <- some(action)
  creature@actions <- new_actions

