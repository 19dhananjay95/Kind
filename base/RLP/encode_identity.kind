RLP.encode_identity(
  rlps: List<RLP>
  H: Equal<Bool>(Nat.lte(List.length(U8, RLP.encode.many(rlps)), RLP.max), true)
): RLP.decode.many(RLP.encode.many(rlps)) == rlps
  case rlps {
    nil: 
      refl
    cons:
      case rlps.head {
        data:
          let conditions = Bool.and.split(Nat.eql(List.length!(rlps.head.value),1), Nat.lte(U8.to_nat((List.head_with_default!(0#8,rlps.head.value))), 127))
          def condition = Bool.and(Nat.eql(List.length!(rlps.head.value),1), Nat.lte(U8.to_nat((List.head_with_default!(0#8,rlps.head.value))), 127))
          case condition with conditions {
            true:
              case rlps.head.value with conditions {
                cons:
                  case rlps.head.value.tail with conditions {
                    nil:
                      open conditions
                      let conditions.snd = mirror(conditions.snd)
                      case conditions.snd {
                        refl:
                          // data([rlps.head.value.head]) & RLP.decode.many(RLP.encode.many(rlps.tail)) == data([rlps.head.value.head]) & rlps.tail
                          let ind = RLP.encode_identity(rlps.tail, ?todo.8)
                          apply(List.cons(RLP, RLP.data([rlps.head.value.head])), ind)
                      }: conditions.snd.b( () List(RLP),List.cons(RLP,RLP.data(List.cons(U8,rlps.head.value.head,List.nil(U8))),RLP.decode.many(List.concat(U8,List.nil(U8),RLP.encode.many(rlps.tail)))),Nat.lte(U8.to_nat(rlps.head.value.head),191,() List(RLP),RLP.split.length(128,List.cons(U8,rlps.head.value.head,List.concat(U8,List.nil(U8),RLP.encode.many(rlps.tail))),() List(RLP),(head) (tail) List.cons(RLP,RLP.data(head),RLP.decode.many(tail))),RLP.split.length(192,List.cons(U8,rlps.head.value.head,List.concat(U8,List.nil(U8),RLP.encode.many(rlps.tail))),() List(RLP),(head) (tail) List.cons(RLP,RLP.node(RLP.decode.many(head)),RLP.decode.many(tail))))) == List.cons(RLP,RLP.data(List.cons(U8,rlps.head.value.head,List.nil(U8))),rlps.tail)

                    cons:
                      open conditions
                      Empty.absurd!(Bool.false_neq_true(conditions.fst))
                  }! :: RLP.decode.many(List.concat(U8,List.cons(U8,rlps.head.value.head,rlps.head.value.tail),RLP.encode.many(rlps.tail))) == List.cons(RLP,RLP.data(List.cons(U8,rlps.head.value.head,rlps.head.value.tail)),rlps.tail)
                  //?true-278
                nil:
                  open conditions
                  Empty.absurd!(Bool.false_neq_true(conditions.fst))
              }!
            false:
              //?false-278-10-2370-152742
              case Nat.lte(List.length(U8,rlps.head.value),55) {
                true:
                  let recover_prefix = ?todo.9 :: Nat.add(128, List.length(U8, rlps.head.value)) == U8.to_nat(Nat.to_u8(Nat.add(128,List.length(U8,rlps.head.value))))
                  case recover_prefix {
                    refl:
                      let limit_size = ?todo.10 :: true == Nat.lte(List.length(U8,rlps.head.value), 63)
                      case limit_size {
                        refl:
                          let split_id = RLP.aux.split.0(rlps.head.value, RLP.encode.many(rlps.tail), ?todo.11)
                          case split_id {
                            refl:
                              let ind = RLP.encode_identity(rlps.tail, ?todo.12)
                              apply(List.cons(RLP,RLP.data(rlps.head.value)), ind)
                          }: split_id.b(() List(RLP),(head) (tail) List.cons(RLP,RLP.data(head),RLP.decode.many(tail))) == List.cons(RLP,RLP.data(rlps.head.value),rlps.tail)
                      }: limit_size.b(() List(RLP),RLP.split.length(128,List.concat(U8,List.concat(U8,List.cons(U8,Nat.to_u8(Nat.add(128,List.length(U8,rlps.head.value))),List.nil(U8)),rlps.head.value),RLP.encode.many(rlps.tail)),() List(RLP),(head) (tail) List.cons(RLP,RLP.data(head),RLP.decode.many(tail))),RLP.split.length(192,List.concat(U8,List.concat(U8,RLP.encode.length(128,List.length(U8,rlps.head.value)),rlps.head.value),RLP.encode.many(rlps.tail)),() List(RLP),(head) (tail) List.cons(RLP,RLP.node(RLP.decode.many(head)),RLP.decode.many(tail)))) == List.cons(RLP,RLP.data(rlps.head.value),rlps.tail)

                  }: Nat.lte(    recover_prefix.b    ,127,() List(RLP),List.cons(RLP,RLP.data(List.cons(U8,Nat.to_u8(Nat.add(128,List.length(U8,rlps.head.value))),List.nil(U8))),RLP.decode.many(List.concat(U8,List.concat(U8,List.nil(U8),rlps.head.value),RLP.encode.many(rlps.tail)))),Nat.lte(    recover_prefix.b   ,191,() List(RLP),RLP.split.length(128,List.concat(U8,List.concat(U8,List.cons(U8,Nat.to_u8(Nat.add(128,List.length(U8,rlps.head.value))),List.nil(U8)),rlps.head.value),RLP.encode.many(rlps.tail)),() List(RLP),(head) (tail) List.cons(RLP,RLP.data(head),RLP.decode.many(tail))),RLP.split.length(192,List.concat(U8,List.concat(U8,RLP.encode.length(128,List.length(U8,rlps.head.value)),rlps.head.value),RLP.encode.many(rlps.tail)),() List(RLP),(head) (tail) List.cons(RLP,RLP.node(RLP.decode.many(head)),RLP.decode.many(tail))))) == List.cons(RLP,RLP.data(rlps.head.value),rlps.tail)

//                  ?true-4418-1090-258-258
                false:
                  let recover_prefix = ?todo.13 :: Nat.add(184, List.length(U8,Bytes.from_nat(List.length(U8,rlps.head.value)))) == U8.to_nat(Nat.to_u8(Nat.add(56,Nat.add(128,List.length(U8,Bytes.from_nat(List.length(U8,rlps.head.value)))))))
                  case recover_prefix {
                    refl:
                      let limit_length = ?todo.14 :: true == Nat.lte(List.length(U8,Bytes.from_nat(List.length(U8,rlps.head.value))), 7)
                      case limit_length {
                        refl:
                          let recover_split = RLP.aux.split.1(rlps.head.value, RLP.encode.many(rlps.tail), ?todo.15)
                          case recover_split {
                            refl:
                              let ind = RLP.encode_identity(rlps.tail, ?todo.16)
                              apply(List.cons(RLP,RLP.data(rlps.head.value)), ind)
                          }: recover_split.b(() List(RLP),(head) (tail) List.cons(RLP,RLP.data(head),RLP.decode.many(tail))) == List.cons(RLP,RLP.data(rlps.head.value),rlps.tail)

                      }: limit_length.b(  () List(RLP),RLP.split.length(128,List.concat(U8,List.concat(U8,List.cons(U8,Nat.to_u8(Nat.add(56,Nat.add(128,List.length(U8,Bytes.from_nat(List.length(U8,rlps.head.value)))))),Bytes.from_nat(List.length(U8,rlps.head.value))),rlps.head.value),RLP.encode.many(rlps.tail)),() List(RLP),(head) (tail) List.cons(RLP,RLP.data(head),RLP.decode.many(tail))),RLP.split.length(192,List.concat(U8,List.concat(U8,RLP.encode.length(128,List.length(U8,rlps.head.value)),rlps.head.value),RLP.encode.many(rlps.tail)),() List(RLP),(head) (tail) List.cons(RLP,RLP.node(RLP.decode.many(head)),RLP.decode.many(tail)))) == List.cons(RLP,RLP.data(rlps.head.value),rlps.tail)

                  }: Nat.lte(   recover_prefix.b   ,127,() List(RLP),List.cons(RLP,RLP.data(List.cons(U8,Nat.to_u8(Nat.add(56,Nat.add(128,List.length(U8,Bytes.from_nat(List.length(U8,rlps.head.value)))))),List.nil(U8))),RLP.decode.many(List.concat(U8,List.concat(U8,Bytes.from_nat(List.length(U8,rlps.head.value)),rlps.head.value),RLP.encode.many(rlps.tail)))),Nat.lte(   recover_prefix.b    ,191,() List(RLP),RLP.split.length(128,List.concat(U8,List.concat(U8,List.cons(U8,Nat.to_u8(Nat.add(56,Nat.add(128,List.length(U8,Bytes.from_nat(List.length(U8,rlps.head.value)))))),Bytes.from_nat(List.length(U8,rlps.head.value))),rlps.head.value),RLP.encode.many(rlps.tail)),() List(RLP),(head) (tail) List.cons(RLP,RLP.data(head),RLP.decode.many(tail))),RLP.split.length(192,List.concat(U8,List.concat(U8,RLP.encode.length(128,List.length(U8,rlps.head.value)),rlps.head.value),RLP.encode.many(rlps.tail)),() List(RLP),(head) (tail) List.cons(RLP,RLP.node(RLP.decode.many(head)),RLP.decode.many(tail))))) == List.cons(RLP,RLP.data(rlps.head.value),rlps.tail)

                  //?false-4418-1090-258-258
              }: List.concat(U8,List.concat(U8,    self(    () Bytes,List.cons(U8,Nat.to_u8(Nat.add(128,List.length(U8,rlps.head.value))),List.nil(U8)),List.cons(U8,Nat.to_u8(Nat.add(56,Nat.add(128,List.length(U8,Bytes.from_nat(List.length(U8,rlps.head.value)))))),Bytes.from_nat(List.length(U8,rlps.head.value)))),rlps.head.value),RLP.encode.many(rlps.tail),(bytes) List(RLP),List.nil(RLP),(bytes.head) (bytes.tail) Nat.lte(U8.to_nat(bytes.head),127,() List(RLP),List.cons(RLP,RLP.data(List.cons(U8,bytes.head,List.nil(U8))),RLP.decode.many(bytes.tail)),Nat.lte(U8.to_nat(bytes.head),191,() List(RLP),RLP.split.length(128,List.concat(U8,List.concat(U8,    self(    () Bytes,List.cons(U8,Nat.to_u8(Nat.add(128,List.length(U8,rlps.head.value))),List.nil(U8)),List.cons(U8,Nat.to_u8(Nat.add(56,Nat.add(128,List.length(U8,Bytes.from_nat(List.length(U8,rlps.head.value)))))),Bytes.from_nat(List.length(U8,rlps.head.value)))),rlps.head.value),RLP.encode.many(rlps.tail)),() List(RLP),(head) (tail) List.cons(RLP,RLP.data(head),RLP.decode.many(tail))),RLP.split.length(192,List.concat(U8,List.concat(U8,RLP.encode.length(128,List.length(U8,rlps.head.value)),rlps.head.value),RLP.encode.many(rlps.tail)),() List(RLP),(head) (tail) List.cons(RLP,RLP.node(RLP.decode.many(head)),RLP.decode.many(tail)))))) == List.cons(RLP,RLP.data(rlps.head.value),rlps.tail)

          }! :: RLP.decode.many(List.concat(U8,   condition(    () List(U8),rlps.head.value,List.concat(U8,RLP.encode.length(128,List.length(U8,rlps.head.value)),rlps.head.value)),RLP.encode.many(rlps.tail))) == List.cons(RLP,RLP.data(rlps.head.value),rlps.tail)
        node:
          let ind = RLP.encode_identity(rlps.head.child, ?todo.0)
          case Nat.lte(List.length(U8,RLP.encode.many(rlps.head.child)), 55) {
            true:
              let recover_prefix = ?todo.5 :: Nat.add(192,List.length(U8,RLP.encode.many(rlps.head.child))) == U8.to_nat(Nat.to_u8(Nat.add(192,List.length(U8,RLP.encode.many(rlps.head.child)))))
              case recover_prefix {
                refl:
                  let lemma = RLP.aux.split.2(RLP.encode.many(rlps.head.child), RLP.encode.many(rlps.tail), ?todo.2)
                  case lemma {
                    refl:
                      let ind_right = RLP.encode_identity(rlps.tail, ?todo.7)
                      let ind_left  = apply(RLP.node, RLP.encode_identity(rlps.head.child, ?todo.8))
                      Equal.vapply(2)!!!!(ind_right)!!!(ind_left, List.cons(RLP))
                  }: lemma.b(() List(RLP),(head) (tail) List.cons(RLP,RLP.node(RLP.decode.many(head)),RLP.decode.many(tail))) == _

              }: Nat.lte(    recover_prefix.b    ,127,() List(RLP),List.cons(RLP,RLP.data(List.cons(U8,Nat.to_u8(Nat.add(192,List.length(U8,RLP.encode.many(rlps.head.child)))),List.nil(U8))),RLP.decode.many(List.concat(U8,List.concat(U8,List.nil(U8),RLP.encode.many(rlps.head.child)),RLP.encode.many(rlps.tail)))),Nat.lte(    recover_prefix.b    ,191,() List(RLP),RLP.split.length(128,List.cons(U8,Nat.to_u8(Nat.add(192,List.length(U8,RLP.encode.many(rlps.head.child)))),List.concat(U8,List.concat(U8,List.nil(U8),RLP.encode.many(rlps.head.child)),RLP.encode.many(rlps.tail))),() List(RLP),(head) (tail) List.cons(RLP,RLP.data(head),RLP.decode.many(tail))),RLP.split.length(192,List.cons(U8,Nat.to_u8(Nat.add(192,List.length(U8,RLP.encode.many(rlps.head.child)))),List.concat(U8,List.concat(U8,List.nil(U8),RLP.encode.many(rlps.head.child)),RLP.encode.many(rlps.tail))),() List(RLP),(head) (tail) List.cons(RLP,RLP.node(RLP.decode.many(head)),RLP.decode.many(tail))))) == List.cons(RLP,RLP.node(rlps.head.child),rlps.tail)

            false:
              let recover_prefix = ?todo.1 :: Nat.add(248, List.length(U8,Bytes.from_nat(List.length(U8,RLP.encode.many(rlps.head.child))))) == U8.to_nat(Nat.to_u8(Nat.add(56,Nat.add(192,List.length(U8,Bytes.from_nat(List.length(U8,RLP.encode.many(rlps.head.child))))))))
              case recover_prefix {
                refl:
                  let lemma = RLP.aux.split.3(RLP.encode.many(rlps.head.child), RLP.encode.many(rlps.tail), ?todo.2, ?todo.3)
                  case lemma {
                    refl:
                      let ind_right = RLP.encode_identity(rlps.tail, ?todo.4)
                      let ind_left  = apply(RLP.node, RLP.encode_identity(rlps.head.child, ?todo.5))
                      Equal.vapply(2)!!!!(ind_right)!!!(ind_left, List.cons(RLP))

                  }: lemma.b( () List(RLP),(head) (tail) List.cons(RLP,RLP.node(RLP.decode.many(head)),RLP.decode.many(tail))) == List.cons(RLP,RLP.node(rlps.head.child),rlps.tail)

              }: Nat.lte(    recover_prefix.b,    127,() List(RLP),List.cons(RLP,RLP.data(List.cons(U8,Nat.to_u8(Nat.add(56,Nat.add(192,List.length(U8,Bytes.from_nat(List.length(U8,RLP.encode.many(rlps.head.child))))))),List.nil(U8))),RLP.decode.many(List.concat(U8,List.concat(U8,Bytes.from_nat(List.length(U8,RLP.encode.many(rlps.head.child))),RLP.encode.many(rlps.head.child)),RLP.encode.many(rlps.tail)))),Nat.lte(    recover_prefix.b    ,191,() List(RLP),RLP.split.length(128,List.cons(U8,Nat.to_u8(Nat.add(56,Nat.add(192,List.length(U8,Bytes.from_nat(List.length(U8,RLP.encode.many(rlps.head.child))))))),List.concat(U8,List.concat(U8,Bytes.from_nat(List.length(U8,RLP.encode.many(rlps.head.child))),RLP.encode.many(rlps.head.child)),RLP.encode.many(rlps.tail))),() List(RLP),(head) (tail) List.cons(RLP,RLP.data(head),RLP.decode.many(tail))),RLP.split.length(192,List.cons(U8,Nat.to_u8(Nat.add(56,Nat.add(192,List.length(U8,Bytes.from_nat(List.length(U8,RLP.encode.many(rlps.head.child))))))),List.concat(U8,List.concat(U8,Bytes.from_nat(List.length(U8,RLP.encode.many(rlps.head.child))),RLP.encode.many(rlps.head.child)),RLP.encode.many(rlps.tail))),() List(RLP),(head) (tail) List.cons(RLP,RLP.node(RLP.decode.many(head)),RLP.decode.many(tail))))) == List.cons(RLP,RLP.node(rlps.head.child),rlps.tail)

          }: RLP.decode.many(List.concat(U8,List.concat(U8,    self(    () Bytes,List.cons(U8,Nat.to_u8(Nat.add(192,List.length(U8,RLP.encode.many(rlps.head.child)))),List.nil(U8)),List.cons(U8,Nat.to_u8(Nat.add(56,Nat.add(192,List.length(U8,Bytes.from_nat(List.length(U8,RLP.encode.many(rlps.head.child))))))),Bytes.from_nat(List.length(U8,RLP.encode.many(rlps.head.child))))),RLP.encode.many(rlps.head.child)),RLP.encode.many(rlps.tail))) == List.cons(RLP,RLP.node(rlps.head.child),rlps.tail)
      }!
  }!
