// Bytes
// =====

//Byte: Type
  //Word<8>

Bytes: Type
  List<U8>

Bytes.show(bytes: Bytes): String
  List.show!(Bits.show, List.map!!(U8.to_bits, bytes))

Bytes.split: (bytes: Bytes, n: Nat) -> Pair<Bytes, Bytes>
  List.split<U8>

Bytes.to_nat(bytes: Bytes): Nat
  Bytes.to_nat.go(bytes, 0)

Bytes.to_nat.go(bytes: Bytes, acc: Nat): Nat
  case bytes {
    nil:
      acc
    cons:
      let digit = U8.to_nat(bytes.head)
      Bytes.to_nat.go(bytes.tail, (acc*256) + digit)
  }

Bytes.from_nat(n: Nat): Bytes
  case n {
    zero:
      List.nil!
    succ:
      Bytes.from_nat(n/256) ++ [U8.from_nat(Nat.mod(n, 256))]
  }

Bytes.to_nat.concat(
  b0: Bytes, b1: Bytes
): (Bytes.to_nat(b1) + Nat.pow(256, List.length(U8, b1))*Bytes.to_nat(b0)) == Bytes.to_nat(b0 ++ b1)
  case b1 {
    nil:
      case List.concat.nil_right(U8, b0) {
        refl:
          refl
      }: Nat.add(Bytes.to_nat(List.nil(U8)),Nat.mul(Nat.pow(256,List.length(U8,List.nil(U8))),Bytes.to_nat(b0))) == Bytes.to_nat(self.b)
    cons:
      let reassoc = mirror(List.concat.assoc(U8, b0, [b1.head], b1.tail))
      case reassoc {
        refl:
          let ind = Bytes.to_nat.concat(List.concat(U8,b0,[b1.head]),b1.tail)
          case ind {
// proof sketch:
// to_nat(bh & bt)                         + 256^succ(len(bt)) * to_nat(t)  == to_nat(bt) + 256^len(bt) * to_nat(t ++ [bh])
// (to_nat(bt) + 256^len(bt)*to_nat([bh])) + 256^succ(len(bt)) * to_nat(t)  == to_nat(bt) + 256^len(bt) * to_nat(t ++ [bh])
// to_nat(bt) + (256^len(bt)*to_nat([bh])  + 256^succ(len(bt)) * to_nat(t)) == to_nat(bt) + 256^len(bt) * to_nat(t ++ [bh])
//              (256^len(bt)*to_nat([bh])  + 256^succ(len(bt)) * to_nat(t)) ==              256^len(bt) * to_nat(t ++ [bh])
//              (256^len(bt)*to_nat([bh])  + (256*256^len(bt)) * to_nat(t)) ==              256^len(bt) * to_nat(t ++ [bh])
//              (256^len(bt)*to_nat([bh])  + (256^len(bt)*256) * to_nat(t)) ==              256^len(bt) * to_nat(t ++ [bh])
//              (256^len(bt)*to_nat([bh])  + 256^len(bt)*(256 * to_nat(t))  ==              256^len(bt) * to_nat(t ++ [bh])
//               256^len(bt)*(to_nat([bh]                 + 255*to_nat(t))) ==              256^len(bt) * to_nat(t ++ [bh])
//               256^len(bt)*(to_nat([bh]                 + 255*to_nat(t))) ==  256^len(bt) * (to_nat([bh]) + 256*to_nat(t))
            refl:
              let ind = Bytes.to_nat.concat([b1.head], b1.tail)
              case ind {
                refl:
                  let reassoc = mirror(Nat.add.assoc(Bytes.to_nat(b1.tail), Nat.mul(Nat.pow(256,List.length(U8,b1.tail)),Bytes.to_nat(List.cons(U8,b1.head,List.nil(U8)))), Nat.mul(Nat.pow(256,List.length(U8,List.cons(U8,b1.head,b1.tail))),Bytes.to_nat(b0))))
                  case reassoc {
                    refl:
                      let mul_reassoc = case mirror(Nat.mul.assoc(Nat.pow(256,List.length(U8,b1.tail)),256, Bytes.to_nat(b0))) {
                        refl:
                          case Nat.mul.comm(256, Nat.pow(256,List.length(U8,b1.tail))) {
                            refl:
                              Equal.refl(Nat, Nat.mul(Nat.mul(256,Nat.pow(256,List.length(U8,b1.tail))),Bytes.to_nat(b0)))
                          }: Nat.mul(    self.b,    Bytes.to_nat(b0)) == Nat.mul(Nat.pow(256,List.length(U8,List.cons(U8,b1.head,b1.tail))),Bytes.to_nat(b0))
                      }: self.b == Nat.mul(Nat.pow(256,List.length(U8,List.cons(U8,b1.head,b1.tail))),Bytes.to_nat(b0))
                      let lemma = case mul_reassoc {
                        refl:
                          let mul_factor = Nat.mul.distrib_left(Nat.pow(256,List.length(U8,b1.tail)), Bytes.to_nat(List.cons(U8,b1.head,List.nil(U8))), Nat.mul(256,Bytes.to_nat(b0)))
                          case mul_factor {
                            refl:
                              let ind = Bytes.to_nat.concat(b0, List.cons(U8, b1.head, List.nil(U8)))
                              case ind {
                                refl:
                                  let obvious = mirror(Nat.mul.one_right(256)) :: Equal(Nat, 256, Nat.pow(256,List.length(U8,List.cons(U8,b1.head,List.nil(U8)))))
                                  case obvious {
                                    refl:
                                      refl
                                  }: Nat.mul(Nat.pow(256,List.length(U8,b1.tail)),Nat.add(Bytes.to_nat(List.cons(U8,b1.head,List.nil(U8))),Nat.mul(256,Bytes.to_nat(b0)))) == Nat.mul(Nat.pow(256,List.length(U8,b1.tail)),Nat.add(Bytes.to_nat(List.cons(U8,b1.head,List.nil(U8))),Nat.mul(    obvious.b,    Bytes.to_nat(b0))))
                              }: Nat.mul(Nat.pow(256,List.length(U8,b1.tail)),Nat.add(Bytes.to_nat(List.cons(U8,b1.head,List.nil(U8))),Nat.mul(256,Bytes.to_nat(b0)))) == Nat.mul(Nat.pow(256,List.length(U8,b1.tail)),    ind.b    )

                          }: mul_factor.b == Nat.mul(Nat.pow(256,List.length(U8,b1.tail)),Bytes.to_nat(List.concat(U8,b0,List.cons(U8,b1.head,List.nil(U8)))))
                      }: Nat.add(Nat.mul(Nat.pow(256,List.length(U8,b1.tail)),Bytes.to_nat(List.cons(U8,b1.head,List.nil(U8)))),    mul_reassoc.b    ) == Nat.mul(Nat.pow(256,List.length(U8,b1.tail)),Bytes.to_nat(List.concat(U8,b0,List.cons(U8,b1.head,List.nil(U8)))))
                      case lemma {
                        refl:
                          refl
                      }: Nat.add(Bytes.to_nat(b1.tail),Nat.add(Nat.mul(Nat.pow(256,List.length(U8,b1.tail)),Bytes.to_nat(List.cons(U8,b1.head,List.nil(U8)))),Nat.mul(Nat.pow(256,List.length(U8,List.cons(U8,b1.head,b1.tail))),Bytes.to_nat(b0)))) == Nat.add(Bytes.to_nat(b1.tail),    lemma.b    )

                  }: reassoc.b == Nat.add(Bytes.to_nat(b1.tail),Nat.mul(Nat.pow(256,List.length(U8,b1.tail)),Bytes.to_nat(List.concat(U8,b0,List.cons(U8,b1.head,List.nil(U8))))))

              }: Nat.add(ind.b, Nat.mul(Nat.pow(256,List.length(U8,List.cons(U8,b1.head,b1.tail))),Bytes.to_nat(b0))) == Nat.add(Bytes.to_nat(b1.tail),Nat.mul(Nat.pow(256,List.length(U8,b1.tail)),Bytes.to_nat(List.concat(U8,b0,List.cons(U8,b1.head,List.nil(U8))))))

          }: Nat.add(Bytes.to_nat(List.cons(U8,b1.head,b1.tail)),Nat.mul(Nat.pow(256,List.length(U8,List.cons(U8,b1.head,b1.tail))),Bytes.to_nat(b0))) == ind.b

      }: Nat.add(Bytes.to_nat(List.cons(U8,b1.head,b1.tail)),Nat.mul(Nat.pow(256,List.length(U8,List.cons(U8,b1.head,b1.tail))),Bytes.to_nat(b0))) == Bytes.to_nat(reassoc.b)
  }!

Bytes.to_nat.from_nat(n: Nat): n == Bytes.to_nat(Bytes.from_nat(n))
  case n {
    zero:
      refl
    succ:
      let ind = Bytes.to_nat.concat(Bytes.from_nat(Nat.div(Nat.succ(n.pred),256)),List.cons(U8,U8.from_nat(Nat.mod(Nat.succ(n.pred),256)),List.nil(U8)))
      case ind {
        refl:
          let mod_small = Nat.lte.comm.false(256, Nat.mod(Nat.succ(n.pred), 256), Nat.mod.small(Nat.succ(n.pred), 256, refl))
          let mod_safe_conversion = Nat.to_u8.safe_conversion(Nat.mod(Nat.succ(n.pred),256), mod_small)
          case mod_safe_conversion {
            refl:
              let len_one = refl :: Equal(Nat, 1, List.length(U8,List.cons(U8,U8.from_nat(Nat.mod(Nat.succ(n.pred),256)),List.nil(U8))))
              let pow_one = case len_one {
                refl:
                  Nat.pow.one_right(256)
              }: Equal(Nat, 256, Nat.pow(256, len_one.b))
              case pow_one {
                refl:
                  let ind = Bytes.to_nat.from_nat(Nat.div(Nat.succ(n.pred),256))
                  case ind {
                    refl:
                      let comm = Nat.mul.comm(Nat.div(Nat.succ(n.pred),256), 256)
                      case comm {
                        refl:
                          mirror(Nat.div_mod.recover(Nat.succ(n.pred), 256, refl))
                      }: Equal(Nat, Nat.succ(n.pred), Nat.add(Nat.mod(Nat.succ(n.pred),256),comm.b))
                  }: Equal(Nat, Nat.succ(n.pred), Nat.add(Nat.mod(Nat.succ(n.pred),256),Nat.mul(256,ind.b)))
              }: Equal(Nat, Nat.succ(n.pred), Nat.add(Nat.mod(Nat.succ(n.pred),256),Nat.mul(    pow_one.b,    Bytes.to_nat(Bytes.from_nat(Nat.div(Nat.succ(n.pred),256))))))

          }: Equal(Nat, Nat.succ(n.pred), Nat.add(    mod_safe_conversion.b,    Nat.mul(Nat.pow(256,List.length(U8,List.cons(U8,U8.from_nat(Nat.mod(Nat.succ(n.pred),256)),List.nil(U8)))),Bytes.to_nat(Bytes.from_nat(Nat.div(Nat.succ(n.pred),256))))))

      }: Equal(Nat, Nat.succ(n.pred), ind.b)
  }!

Bytes.from_nat.length(n: Nat): Nat.succ(Nat.log2(n)/8) == List.length(U8, Bytes.from_nat(n))
  ?bytes.from_nat.length

Bytes.to_hex(b: Bytes): String
  Bytes.to_hex.go("", b)

Bytes.to_hex.go(acc: String, b: Bytes): String
  case b {
    nil:
      acc
    cons:
      Bytes.to_hex.go(acc|U8.to_hex(b.head), b.tail)
  }

//Bytes.inc.go<size: Nat>(byte: Word<size>): Pair<Word<size>, Bool>
  //case byte {
    //e: {Word.e, true}
    //o: {Word.i!(byte.pred), false}
    //i: case Bytes.inc.go!(byte.pred) as result {
      //new: {Word.o!(result.fst), result.snd}
    //}
  //}!

Bytes.inc(bytes: Bytes): Bytes
  case bytes {
    nil:
      [1#8]
    cons:
      if U8.eql(bytes.head, 255#8) then
        List.cons!(0#8, Bytes.inc(bytes.tail))
      else
        List.cons!(U8.inc(bytes.head), bytes.tail)
  }
  //case bytes {
    //nil: [1#8]
    //cons: case Bytes.inc.go!(bytes.head@value) as result {
      //new: case result.snd {
        //true: List.cons!(U8.new(result.fst), Bytes.inc(bytes.tail))
        //false: List.cons!(U8.new(result.fst), bytes.tail)
      //}
    //}
  //}

//Bytes.from_nat.identity(n: Nat): Equal<Nat, Bytes.to_nat(Bytes.from_nat(n)), n>
  //Bytes.from_nat.identity(n)

//Aux.1(
  //n: Nat
  //e0: Nat.ltn(0, n) == true
  //e1: Nat.ltn(n, 256) == true
//): Equal<Bytes, Bytes.from_nat(n), [Nat.apply!(n, Word.inc<8>, Word.zero(8))]>
  //Aux.1(n, e0, e1)
