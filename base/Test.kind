Test: _
  asd({130u, 128u})
//   // Web.Kaelin.Coord.show(Web.Kaelin.Coord.to_axial({144u, 136u}))
//   let n1 = Bits.from_string("001101")
//   let n2 = Bits.from_string("000111")
//   let n3 = Bits.shift_right(4, n1)
//   let n5 = Bits.shift_right(4, n3)
//   let n4 = Bits.mask(n1, n2)
//   List.show!(Bits.to_string, asd(Bits.from_string("00010010001101000101011000101000")))

// asd(b: Bits): List(Bits)
//   let aux = Bits.mask(b, Bits.from_string("1111"))
//   let tail = Bits.shift_right(4, b)
//   case tail {
//     e: List.nil!
//   } default List.cons!(aux, asd(tail))
  

asd(coord: Pair(U32, U32)): Pair(U32, U32)
  let {x, y} = coord

  let f = U32.to_f64
  let u = F64.to_u32

  let float_x = F64.sub(f(128u), f(x))
  let float_y = F64.sub(f(128u), f(y))

  let fourth = F64.div(f(1u), f(4u))
  let sixth = F64.div(f(1u), f(6u))
  let third = F64.div(f(1u), f(3u))
  let half = F64.div(f(1u), f(2u))

  let axial_x = F64.sub( F64.mul(float_x, fourth), F64.mul(float_y, sixth) )
  let axial_y = F64.mul(float_y, third)
  let axial_z = F64.sub(F64.sub(f(0u), axial_x), axial_y)

  let axial_x_half = F64.add(axial_x, half)
  let axial_y_half = F64.add(axial_y, half)
  let axial_z_half = F64.add(axial_z, half)

  let round_x = F64.floor(axial_x_half)
  let round_y = F64.floor(axial_y_half)
  let round_z = F64.floor(axial_z_half)

  let diff_x = F64.sub(axial_x, round_x)
  let diff_y = F64.sub(axial_y, round_y)
  let diff_z = F64.sub(axial_z, round_z)
  
  case F64.gtn(diff_x, diff_z) {
    true:
      case F64.gtn(diff_y, diff_x){
        true: 
          let new_y = F64.sub(F64.sub(f(0u), round_x), round_z)
          {u(round_x), u(new_y)}
        false:
          let new_x = F64.sub(F64.sub(f(0u), round_y), round_z)
          {u(new_x), u(round_y)}
      }
    false:
      case F64.gtn(diff_y, diff_z) {
        true:
          let new_y = F64.sub(F64.sub(f(0u), round_x), round_z)
          {u(round_x), u(new_y)}
        false:
          {u(round_x), u(round_y)}
      }
  }