Parser.first_of.go<A: Type>(pars: List<Parser(A)>): Parser(A)
  (long, idx, code) 
    case pars {
      nil:
        case long {
          none: Parser.Reply.error_long!(idx, code, "No parse.")
          some: Parser.Reply.error!(long.value)
        }
      cons:
        let parsed = pars.head(long, idx, code)
        case parsed {
          error:
            curr_err = Maybe.some!(parsed.val)
            open parsed.val
            furthest_err = Parser.ErrorAt.maybe_combine(long, curr_err)
            Parser.first_of.go!(pars.tail, furthest_err, idx, code)
          value:
            furthest_err = Parser.ErrorAt.maybe_combine(long, parsed.long)
            Parser.Reply.value!(furthest_err, parsed.idx, parsed.code, parsed.val)
        }
    }
