// Empty
. Empty : Type = $self {-P : {self : Empty} Type} (P self)

// Unit
. Unit : Type = $self {-P : {:Unit} Type} {:(P unit)} (P self)
. unit : Unit = @Unit [-P] [U] U

// Booleans
. Bool  : Type = $self {-P : {:Bool} Type} {:(P true)} {:(P false)} (P self)
. true  : Bool = @Bool [-P] [T] [F] T
. false : Bool = @Bool [-P] [T] [F] F

// Boolean induction
. Bool.induct
: {b : Bool} {P : {:Bool} Type} {:(P true)} {:(P false)} (P b)
= [b] [P] [T] [F] (~b -P T F)

// Boolean negation
. Bool.not
: {b : Bool} Bool
= [b] (~b -[b]Bool false true)

// Boolean negation (fusible)
. Bool.fnot_aux
: {b  : Bool} {-P : {:Bool} Type} {:(P true)} {:(P false)} (P @Bool (Bool.fnot_aux b))
= [b] [-P] [T] [F] (~b -[b](P @Bool (Bool.fnot_aux b)) F T)

. Bool.fnot
: {b : Bool} Bool
= [b] @Bool (Bool.fnot_aux b)

// Natural numbers (Scott, inductive)
. Nat            : Type = $self {-P : {:Nat} Type} {S : {n : Nat} (P (succ n))} {Z : (P zero)} (P self)
. succ [n : Nat] : Nat  = @Nat [-P] [S] [Z] (S n)
. zero           : Nat  = @Nat [-P] [S] [Z] Z

// Nat numbers
. Nat.0 Nat.zero
. Nat.1 (Nat.succ Nat.0)
. Nat.2 (Nat.succ Nat.1)
. Nat.3 (Nat.succ Nat.2)

// Natural numbers (Church, non-inductive)
. Cat                : Type = {-P : Type} {S : ! {:P} P} ! {Z : P} P
. Cat.succ [n : Cat] : Cat  = [-P] [S] [S = S] [A = (n -P #S)] # [Z] (S (A Z))
. Cat.zero           : Cat  = [-P] [S] [S = S] # [Z] Z

// Cat addition
. Cat.add
: {a : Cat} {b : Cat} Cat
= [a] [b] [-P] [s]
  [S = s]
  [A = (a -P #S)]
  [B = (b -P #S)]
# [z] (A (B z)) 

// Cat multiplication
. Cat.mul
: {a : Cat} {b : Cat} Cat
= [a] [b] [-P] [s]
  [S = s]
  (a -P (b -P #S))

// Cat numbers
. Cat.0  Cat.zero
. Cat.1  (Cat.succ Cat.0)
. Cat.2  (Cat.succ Cat.1)
. Cat.3  (Cat.succ Cat.2)
. Cat.4  (Cat.mul Cat.2 Cat.2)
. Cat.8  (Cat.mul Cat.4 Cat.2)
. Cat.16 (Cat.mul Cat.8 Cat.2)
. Cat.32 (Cat.mul Cat.16 Cat.2)
. Cat.64 (Cat.mul Cat.32 Cat.2)

// Natural numbers (Parigot, erased to Church, inductive)
. Rat                : Type = $self {-P : {:Rat} Type} {S : ! {-n : Rat} {h : (P n)} (P (Rat.succ n))} ! {Z : (P Rat.zero)} (P self)
. Rat.succ [n : Rat] : Rat  = @Rat [-P] [S] [S = S] [A = (~n -P #S)] # [Z] (S -n (A Z))
. Rat.zero           : Rat  = @Rat [-P] [S] [S = S] # [Z] Z

// Cat numbers
. Rat.0  Rat.zero
. Rat.1  (Rat.succ Rat.0)
. Rat.2  (Rat.succ Rat.1)
. Rat.3  (Rat.succ Rat.2)
. Rat.4  (Rat.succ Rat.3)

// Rat induction (but it increases a level)
. Rat.induct
: {n : Rat} {-P : {:Rat} Type} {:!{n : Rat}{:(P n)}(P (Rat.succ n))} !{:(P Rat.zero)} (P n)
= [a] [-P] [s] [S = s] [A = (~a -[n](P n) #S)] # [z] (A z)

// Rat double (uses induction, thus isn't fusible and increases a level)
. Rat.double
: {n : Rat} !Rat
= [n]
  [F = (~n -[s : Rat]Rat #[-n : Rat][h : Rat](Rat.succ (Rat.succ h)))]
  # (F Rat.zero)

// Rat double (doesn't use induction, is fusible, doesn't increase a level)
. Rat.fdouble_aux
: {n : Rat} {-P : {n : Rat} Type} {S : ! {-n : Rat} {h : (P n)} (P (Rat.succ n))} ! {Z : (P Rat.zero)} (P @Rat (Rat.fdouble_aux n))
= [n] [-P] [S] [S = S]
  [A = (~n -[n] (P @Rat (Rat.fdouble_aux n)) #[-n : Rat] [h : (P n)] (S -(Rat.succ @Rat (Rat.fdouble_aux n)) (S -@Rat (Rat.fdouble_aux n) h)))]
  # [Z] (A Z)
. Rat.fdouble
: {n : Rat} Rat
= [n] @Rat (Rat.fdouble_aux n)
  
// Tests non-fusible double (67 rewrites)
. non_fusible_double_test (Rat.double Rat.3)

// Tests fusible double (19 rewrites!)
. fusible_double_test (Rat.fdouble Rat.3)

. main fusible_double_test
