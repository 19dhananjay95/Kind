MultiArg<A: Type, B: Type>(n: Nat): Type
  case n {
    zero: B
    succ: A -> MultiArg<A, B>(n.pred)
  }

MultiArg.wrap<A: Type, B: Type, C: Type>(n: Nat, outer: B -> C, inner: MultiArg<A, B>(n)): MultiArg<A, C>(n)
  case n with inner {
    zero:
      let ret = outer(inner)
      ret
    succ:
      (x) MultiArg.wrap<A, B, C, n.pred>(outer, inner(x))
  }!

MultiArg.join<A: Type, B: Type, C: Type, D: Type>(
  n: Nat
  m: Nat
  join: B -> C -> D
  l: MultiArg<A, B>(n)
  r: MultiArg<A, C>(m)
): MultiArg<A, D>(Nat.add(n, m))
  case n with l {
    zero:
      MultiArg.wrap<A, C, D>(m, join(l), r)
    succ:
      (x) MultiArg.join<A, B, C, D>(n.pred, m, join, l(x), r)
  }!

MultiArg.equal<A: Type, B: Type>(
  n: Nat
  l: MultiArg<A, B>(n)
  r: MultiArg<A, B>(n)
): MultiArg<A, Type>(Nat.add(n, n))
  MultiArg.join<A, B, B, Type, n, n>(Equal<B>, l, r)

type Association <A: Type, op: A -> A -> A> ~ (c: Nat, exp: MultiArg<A, A>(c)) {
  inst(a: A) ~ (c = 0, exp = a)
  join(
    n: Nat
    m: Nat
    fst: MultiArg<A, A>(n)
    snd: MultiArg<A, A>(m)
  ) ~ (c = Nat.add(n, m), exp = MultiArg.join<A, A, A, A>(n, m, op, fst, snd))
}

Associative<A: Type>(op: A -> A -> A): Type
  (a: A, b: A, c: A) -> Equal<A>(op(op(a, b), c), op(a, op(b, c)));

//Association.unique<A: Type>(
//  op: A -> A -> A
//  Hyp0: Associative<A>(op)
//  n: Nat
//  fst: MultiArg<A, A>(n)
//  snd: MultiArg<A, A>(n)
//  Hyp1: Association<A, op, n>(fst)
//  Hyp2: Association<A, op, n>(snd)
//): MultiArg.equal<A, A>(n, fst, snd)
//  ?a

//Kind.Term.Shorthand(name: Kind.Name, n: Nat): MultiArg<Kind.Term>(n)
//  case n {
//    zero: Kind.Term.ref(name)
//    succ:
//      (out_arg)
//        let outer = (inn_arg) Kind.Term.app(inn_arg, out_arg)
//        let ind = Kind.Term.Shorthand(name, n.pred)
//        MultiArg.wrap<Kind.Term, n.pred>(outer, ind)
//  }!
//
//Test: _
//  let add = Kind.Term.Shorthand("Nat.add", 2)
//  add(Kind.Term.nat(2), Kind.Term.nat(3))
