// Litereum: a minimal decentralized computer
// ==========================================

// TODO:
// - cost measure
// - check do call.cont
// - Lit.Core.Term.get_caller
// - tipo "Bits" nativo no bloco genesis
// - conseguir modificar o dono no Lit.Core.Term.bind
// - revisar e usar a função validate
// - block difficulty (nakamoto consensus)
// - owned types/constructors?
// - melhorar mensagens de erro
// - Lit.Lang:
//   - consertar parser para ir ate o final do arquivo?
//   - do blocks (um "with" anonimo, sem assinatura)
//   - open?
// - paper:
//   - use railroad diagrams for syntax

// Types
// -----

// A Litereum term
type Lit.Core.Term {
  // A variable
  var(
    name: String
  )
  // Creates a value
  create(
    type: String
    ctor: Nat
    vals: List<Lit.Core.Term>
  )
  // Pattern-matches a value
  match(
    name: String
    type: String
    expr: Lit.Core.Term
    cses: List<Lit.Core.Term.Case>
  )
  // Creates a new 64-bit word
  word(
    numb: U64
  )
  // Compares two words
  compare(
    val0: Lit.Core.Term
    val1: Lit.Core.Term
    iflt: Lit.Core.Term
    ifeq: Lit.Core.Term
    ifgt: Lit.Core.Term
  )
  // Word addition
  operate(
    oper: Lit.Core.Operation
    val0: Lit.Core.Term
    val1: Lit.Core.Term
  )
  // Calls an external program
  call(
    name: String
    func: String
    args: List<Lit.Core.Term>
    cont: Lit.Core.Term
  )
  // Binds an new program
  bind(
    name: String
    main: Lit.Core.Term
    cont: Lit.Core.Term
  )
}

// An operation
type Lit.Core.Operation {
  add
  sub
  mul
  div
  mod
  or
  and
  xor
}

// A pattern-matching case
type Lit.Core.Term.Case {
  new(
    fields: List<String>
    body: Lit.Core.Term
  )
}

// Lit.Core types are algebraic datatypes (ADTs)
type Lit.Core.Type {
  word
  data(
    name: String
    constructors: List<Lit.Core.Type.Constructor>
  )
}

// A constructor of an ADT
type Lit.Core.Type.Constructor {
  new(
    name: String
    fields: List<Lit.Core.Type.Field>
  )
}

// A field of an ADT's constructor
type Lit.Core.Type.Field {
  new(
    name: String
    type: String
  )
}

// A function
type Lit.Core.Bond {
  new(
    name: String
    owners: List<String>
    main: Lit.Core.Term
    input_names: List<String>
    input_types: List<String>
    output_type: String
  )
}

// A Lit.Core global entry
type Lit.Core.Entry {
  type(value: Lit.Core.Type)
  bond(value: Lit.Core.Bond)
}

// Lit.Core's global state
Lit.Core.World: Type
  Map<Lit.Core.Entry>

// A paragraph in a Litereum page
// TODO: rename to Lit.Core.Command
type Lit.Core.Statement {
  define(entry: Lit.Core.Entry)
  call(expr: Lit.Core.Term)
}

// A page of the Litereum book
Lit.Core.Page: Type
  List<Lit.Core.Statement>

// Getters and Setters
// -------------------

Lit.Core.World.get_type(name: String, world: Lit.Core.World): Maybe<Lit.Core.Type>
  if name =? "U64" then
    some(Lit.Core.Type.word)
  else
    case world{name} as entry {
      some: case entry.value {
        type: some(entry.value.value)
      } default none
    } default none

// TODO prevent users from defining type named "U64"

Lit.Core.World.get_func(name: String, world: Lit.Core.World): Maybe<Lit.Core.Bond>
  case world{name} as entry {
    some: case entry.value {
      bond: some(entry.value.value)
    } default none
  } default none

Lit.Core.Type.find_ctor(name: String, type: Lit.Core.Type): Maybe<Pair<Nat,Lit.Core.Type.Constructor>>
  case type {
    word: none
    data: List.ifind!((i,f) String.eql(f@name,name), type.constructors)
  }

// Type-Checking
// -------------

Lit.Core.Type.equal(a: Lit.Core.Type, b: Lit.Core.Type): Bool
  case a b {
    word word: true
    data data: String.eql(a.name, b.name)
  } default false

Lit.Core.World.check.term(
  term: Lit.Core.Term
  type: Lit.Core.Type
  context: Map<Lit.Core.Type>
  world: Lit.Core.World
  caller: Maybe<String>
): Bool
//  log("- chk " | Lit.Lang.show.term(term,world) | " : " | Lit.Lang.show.type.short(type))
//  log("- ctx " | String.join(", ", List.map!!((a) a@fst|":"|Lit.Lang.show.type.short(a@snd), Map.to_list!(ctx))))
//  log("")
  case term {
    var:
      let vtyp = context{term.name} abort false
      //log("-- var " | Lit.Core.Type.show(var_type) | " " | Lit.Core.Type.show(type))
      Lit.Core.Type.equal(vtyp, type)
    create: 
      let ttyp = Lit.Core.World.get_type(term.type,world) abort false
      case ttyp {
        data:
          use ctor = ttyp.constructors[term.ctor] abort false
          let args = Lit.Core.World.check.many(term.vals, List.mapped!(ctor.fields)!((x) x@type), context, world, caller)
          args && Lit.Core.Type.equal(ttyp, type)
      } default false
    call:
      // verify owner
      let ownr = Lit.Core.World.check.owner(caller, term.func, world)
      use func = Lit.Core.World.get_func(term.func,world) abort false
      use otyp = Lit.Core.World.get_type(func.output_type,world) abort false
      let args = Lit.Core.World.check.many(term.args, func.input_types, context, world, caller)
      let cont = Lit.Core.World.check.term(term.cont, type, context{term.name} <- otyp, world, caller)
      ownr && args && cont
    match:
      let expr_type = Lit.Core.World.get_type(term.type,world) abort false
      case expr_type {
        data:
          let expr = Lit.Core.World.check.term(term.expr, expr_type, context, world, caller)
          let cses = List.mapped!(term.cses)!((x) x@body)
          let cses = Lit.Core.World.check.match.cases(cses, type, expr_type.constructors, term.name, context, world, caller)
          expr && cses
      } default false
    bind:
      // TODO: check access
      let ownr = Lit.Core.World.check.owner(caller, term.name, world)
      use func = Lit.Core.World.get_func(term.name,world) abort false
      use otyp = Lit.Core.World.get_type(func.output_type,world) abort false
      let nofn = List.is_empty!(func.input_names) // should we allow binds with functions?
      let main = Lit.Core.World.check.term(term.main, otyp, context, world, caller)
      // should the ctx change?
      let cont = Lit.Core.World.check.term(term.cont, type, context, world, caller)
      ownr && nofn && main && cont
    word:
      case type {
        word: true
      } default false
    compare:
      let val0 = Lit.Core.World.check.term(term.val0, Lit.Core.Type.word, context, world, caller)
      let val1 = Lit.Core.World.check.term(term.val0, Lit.Core.Type.word, context, world, caller)
      let iflt = Lit.Core.World.check.term(term.iflt, type, context, world, caller)
      let ifeq = Lit.Core.World.check.term(term.ifeq, type, context, world, caller)
      let ifgt = Lit.Core.World.check.term(term.ifgt, type, context, world, caller)
      val0 && val1 && iflt && ifeq && ifgt
    operate:
      let val0 = Lit.Core.World.check.term(term.val0, Lit.Core.Type.word, context, world, caller)
      let val1 = Lit.Core.World.check.term(term.val1, Lit.Core.Type.word, context, world, caller)
      val0 && val1
  }

Lit.Core.World.check.many(
  terms: List<Lit.Core.Term>
  types: List<String>
  context: Map<Lit.Core.Type>
  world: Lit.Core.World
  caller: Maybe<String>
): Bool
  open world
  case terms types {
    cons cons:
      let type = Lit.Core.World.get_type(types.head, world) abort false
      let head = Lit.Core.World.check.term(terms.head, type, context, world, caller)
      let tail = Lit.Core.World.check.many(terms.tail, types.tail, context, world, caller)
      head && tail
    nil nil:
      true
  } default false

Lit.Core.World.check.match.cases(
  cases: List<Lit.Core.Term>
  type: Lit.Core.Type
  ctors: List<Lit.Core.Type.Constructor>
  name: String
  context: Map<Lit.Core.Type>
  world: Lit.Core.World
  caller: Maybe<String>
): Bool
  case cases ctors {
    cons cons:
      let ext_context = context
      for field in ctors.head@fields with ext_context:
        let type = Lit.Core.World.get_type(field@type, world) <> Lit.Core.Type.data("Empty", [])
        ext_context{name | "." | field@name} <- type
      let case_ok = Lit.Core.World.check.term(cases.head, type, ext_context, world, caller)
      let rest_ok = Lit.Core.World.check.match.cases(cases.tail, type, ctors.tail, name, context, world, caller)
      case_ok && rest_ok
    nil nil:
      true
  } default false

Lit.Core.World.check.owner(
  caller: Maybe<String>
  name: String
  world: Lit.Core.World
): Bool
  let entry = world{name}
  case entry {
    none: false
    some: 
      case entry.value as func {
        bond: 
          use f = func.value
          case f.owners {
            nil:
              true
            cons:
              case caller {
                some:
                  if caller.value =? name then
                    true
                  else
                    List.in!(String.eql(caller.value), f.owners)
                none:
                  false
              }
          }
      } default false
  }

// Validation
// ----------
// Checks if:
// - no global binders with the same name
// - variables are used at most once

// TODO:
//  - error list

Lit.Core.World.validate(
  term: Lit.Core.Term
  used: Map<Bool>
): Pair<Map<Bool>,Bool>
  Lit.Core.World.validate.aux({used, true}, term)

Lit.Core.World.validate.aux(
  state: Pair<Map<Bool>, Bool>
  term: Lit.Core.Term
): Pair<Map<Bool>, Bool>
  //log("- vld " | String.join(", ", List.map!!((a) a@fst|":"|Bool.show(a@snd), Map.to_list!(used)))) // DEBUG
  //log("") // DEBUG

  case term {
    var:
      let {used, valid} = state
      case used{term.name} as was_used {
        none:
          // undefined variable
          {used, false}
        some:
          if was_used.value then
            // variable already used
            {used, false}
          else
            // first use of the variable
            {used{term.name} <- true, valid}
      }

    create:
      for val in term.vals with state:
        Lit.Core.World.validate.aux(state, val)
      state

    match:
      let state = Lit.Core.World.validate.aux(state, term.expr)
      for cse in term.cses with state:
        let {fields, _} = cse
        let field_state = state
        for field in fields with field_state:
          let {used, valid} = field_state
          case used{field} {
            some:
              {used, false} // same name used more than once
            none:
              {used{field} <- false, valid}
          }
        state
      state

    call:
      for arg in term.args with state:
        Lit.Core.World.validate.aux(state, arg)
      state

    bind:
      let {used, valid} = state
      let used = used{term.name} <- false
      let state = {used, valid}
      let state = Lit.Core.World.validate.aux(state, term.main)
      let state = Lit.Core.World.validate.aux(state, term.cont)
      state

    word:
      state

    compare:
      let terms = [term.val0, term.val1, term.iflt, term.ifeq, term.ifgt]
      for i_term in terms with state:
        Lit.Core.World.validate.aux(state, i_term)
      state

    operate:
      let state = Lit.Core.World.validate.aux(state, term.val0)
      let state = Lit.Core.World.validate.aux(state, term.val1)
      state
  }

// Execution
// ---------

Lit.Core.World.run.page(
  page: Lit.Core.Page
  world: Lit.Core.World
): Maybe<Lit.Core.World>
  case page {
    nil:
      some(world)
    cons:
      case Lit.Core.World.run.statement(page.head, world) as new_world {
        none:
          none
        some:
          Lit.Core.World.run.page(page.tail, new_world.value)
      }
  }


Lit.Core.World.run.statement(
  statement: Lit.Core.Statement
  world: Lit.Core.World
): Maybe<Lit.Core.World>
  case statement {
    define:
      case statement.entry {
        type:
          let type = statement.entry.value
          case type {
            word:
              log("error: word as an entry definition")
              none
            data: 
              log("- new_type: " | type.name)
              case world{type.name} as got_type {
                none:
                  if not(type.name =? "U64") then
                    some(world{type.name} <- Lit.Core.Entry.type(type))
                  else
                    log("error: cannot redefine built-in type named 'U64'") none
              } default log("error: type redefinition: " | type.name) none
          }
        bond:
          use func = statement.entry.value
          log("- new_func: " | func.name | List.show!(Function.id!, func.owners))
          case world{func.name} as got {
            none:
              let new_world = world{func.name} <- Lit.Core.Entry.bond(func)
              let ctx = some({})
              let ctx = for arg in List.zip!!(func.input_names, func.input_types): Maybe {
                let {arg_name, arg_type} = arg
                get ctx = ctx
                get typ = Lit.Core.World.get_type(arg_type, world)
                return ctx{arg_name} <- typ
              }
              let vld = {}
              let vld = for iarg in func.input_names:
                vld{iarg} <- false
              case ctx {
                none:
                  log("error: func input type undefined: " | func.name) none
                some:
                  let otyp = Lit.Core.World.get_type(func.output_type, world) abort log("error: func otyp not found: " | func.name) none
                  if Lit.Core.World.check.term(func.main, otyp, ctx.value, new_world, some(func.name)) then
                    let {ah, ok} = Lit.Core.World.validate(func.main, vld)
                    if ok then
                      //log("here")
                      some(new_world)
                    else
                      //log("there")
                      log("error: func invalid: " | func.name) none
                  else
                    log("error: func ill-typed: " | func.name) none
              }
          } default log("error: func redefinition: " | func.name) none
      }
    call:
      let exec = statement.expr
      // This assumes that the type Unit is already defined to avoid
      // duplicating the typechecking function.
      let term_ok = Lit.Core.World.check.term(exec, Lit.Core.Type.word, {}, world, none)
      if term_ok then
        let {result, world} = Lit.Core.World.run.term(exec, world, {})
        log("- ext_exec: " | Lit.Lang.show.term(result, world))
        some(world)
      else
        log("error: exec failed in typecheck") none
  }

Lit.Core.World.run.term(
  term: Lit.Core.Term
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
): Pair<Lit.Core.Term, Lit.Core.World>
//  log("- run " | Lit.Lang.show.term(term,world)) // DEBUG
//  log("- var " | String.join(", ", List.map!!((x) x@fst|":"|Lit.Lang.show.term(x@snd,world), Map.to_list!(vars)))) // DEBUG
//  log("")
  case term {
    var:
      case vars{term.name} as got {
        none:
          {term, world}
        some:
          Lit.Core.World.run.term(got.value, world, vars)
      }
    create:
      let {vals, world} = Lit.Core.World.run.terms(term.vals, world, vars)
      {Lit.Core.Term.create(term.type, term.ctor, vals), world}
    match:
      Maybe {
        let {expr, world} = Lit.Core.World.run.term(term.expr, world, vars)
        case expr {
          create: case term.cses[expr.ctor] as selected_case {
            some: 
              let {case_fields, case_body} = selected_case.value
              let vars = for subst in List.zip!!(case_fields, expr.vals):
                let {field, value} = subst
                vars{field} <- value
              Lit.Core.World.run.term(case_body, world, vars)
          } default {term, world}
        } default {term,world}
      }
    word:
      {term, world}
    compare:
      let {val0, world} = Lit.Core.World.run.term(term.val0, world, vars)
      let {val1, world} = Lit.Core.World.run.term(term.val1, world, vars)
      case val0 val1 {
          word word:
            case U64.cmp(val0.numb, val1.numb) {
              ltn:
                Lit.Core.World.run.term(term.iflt, world, vars)
              eql:
                Lit.Core.World.run.term(term.ifeq, world, vars)
              gtn:
                Lit.Core.World.run.term(term.ifgt, world, vars)
            }
      } default log("error: operands didn't reduce to words") {term, world}
    operate:
      let {val0, world} = Lit.Core.World.run.term(term.val0, world, vars)
      let {val1, world} = Lit.Core.World.run.term(term.val1, world, vars)
      case val0 val1 {
        word word:
          case term.oper {
            add:
              {Lit.Core.Term.word(val0.numb + val1.numb), world}
            sub:
              {Lit.Core.Term.word(val0.numb - val1.numb), world}
            mul:
              {Lit.Core.Term.word(val0.numb * val1.numb), world}
            div:
              {Lit.Core.Term.word(val0.numb / val1.numb), world}
            mod:
              {Lit.Core.Term.word(val0.numb % val1.numb), world}
            or:
              {Lit.Core.Term.word(val0.numb || val1.numb), world}
            and:
              {Lit.Core.Term.word(val0.numb && val1.numb), world}
            xor:
              {Lit.Core.Term.word(U64.xor(val0.numb, val1.numb)), world}
          }
      } default log("error: operand didn't reduce to word") {term, world}
    call:
      case world{term.func} as got {
        none:
          {term, world}
        some: case got.value as entry {
          bond:
            use func = entry.value
            let main_vars = vars
            let state = {main_vars, world}
            let state = for arg in List.zip!!(func.input_names, term.args):
              let {main_vars, world} = state
              let {arg_name, arg_term} = arg
              let {arg_term, world} = Lit.Core.World.run.term(arg_term, world, main_vars)
              let main_vars = main_vars{arg_name} <- arg_term
              {main_vars, world}
            let {main_vars, world} = state
            let {done, world} = Lit.Core.World.run.term(func.main, world, main_vars)
            let vars = vars{term.name} <- done
            Lit.Core.World.run.term(term.cont, world, vars)
        } default {term, world}
      }
    bind:
      case world{term.name} as got {
      none:
        {term, world}
      some: case got.value as entry {
        bond:
          use func = entry.value
          let {main, world} = Lit.Core.World.run.term(term.main, world, vars)
          let world = world{term.name} <- Lit.Core.Entry.bond(func@main <- main)
          Lit.Core.World.run.term(term.cont, world, vars)
      } default {term, world}
    }
  }

Lit.Core.World.run.terms(
  terms: List<Lit.Core.Term>
  world: Lit.Core.World
  vars: Map<Lit.Core.Term>
): Pair<List<Lit.Core.Term>, Lit.Core.World>
  case terms {
    nil:
      {[], world}
    cons:
      let {head, world} = Lit.Core.World.run.term(terms.head, world, vars)
      let {tail, world} = Lit.Core.World.run.terms(terms.tail, world, vars)
      {head & tail, world}
  }

// Tests
// -----
Lit.Core: _
  let world = {}
  let code = 
    Lit.Lang.Type
    | Lit.Lang.Cmp
    | Lit.Lang.Nat
    | Lit.Lang.Bits
    | Lit.Lang.BitsMap
    |`
type BoolList {
  nil
  cons{
    head: Bool
    tail: NatList
  }
}

type NatList {
  nil
  cons{
    head: Nat
    tail: BoolList
  }
}

Count.inc, MrDog @ Count(): Bits
  Bits/o{pred: Bits/e}

Count.inc(): Unit
  call c = Count();
  call d = Bits.inc(c);
  bind Count = d;
  Unit/new

user MrDog {
  01234
}

do {
  call ret = Bits.add(Bits/i{pred:Bits/i{pred: Bits/e}}, Bits/i{pred: Bits/e})
  call dupped = Bits.dup(ret)
  Unit/new
}: Unit
`
  let page = Parser.run!(Lit.Lang.parser.page(world), code) abort IO.print("parse error")
  case Lit.Core.World.run.page(page, world) as result {
    none:
      IO.print("failure")
    some:
      IO.print("success")
  }
