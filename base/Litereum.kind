// Litereum: a minimal decentralized computer

// A private key is a set of 32 words
Litereum.Private: Type
  Vector<U256, 32>

// A public key is the hash^32 of the private key
Litereum.Public: Type
  Vector<U256, 32>

// An address is the hash of a public key
Litereum.Address: Type
  U256

// A hash is a 256-bit word
Litereum.Hash: Type
  U256

// A signature is a set of 32 words
// - 30 words sign the first 30 bytes of the message hash
// -  2 words sign the checksum
Litereum.Signature: Type
  Vector<U256, 32>

// The 32 bytes to be signed by a signature
Litereum.Summary: Type
  Vector<U8, 32>

// The body of a Litereum Post can hold up to 8 words
Litereum.Body: Type
  Vector<U256,8>

// A term of the Litereum scripting language
type Litereum.Term {
  // A lambda
  lam(
    name: String,
    body: Litereum.Term -> Litereum.Term,
  )
  // An application
  app(
    func: Litereum.Term,
    argm: Litereum.Term,
  )
  // A variable
  var(
    name: String,
  )

  // The empty bitstring
  nil
  // Appends 0 to a bitstring
  cons0(
    pred: Litereum.Term,
  )
  // Appends 1 to a bitstring
  cons1(
    pred: Litereum.Term,
  )
  // Pattern-matches a bitstring
  elim(
    bits: Litereum.Term,
    name: String,
    case_nil: Litereum.Term,
    case_cons0: Litereum.Term -> Litereum.Term,
    case_cons1: Litereum.Term -> Litereum.Term,
  )

  // A block
  block(statements: Litereum.Block)
}

// A block with side-effective operations
type Litereum.Block {
  // Returns a value
  return(
    result: Litereum.Term,
  )
  // Gets the value of a key from storage
  get(
    key: Litereum.Term,
    bind: String,
    cont: Litereum.Term -> Litereum.Block,
  )
  // Sets a key/value pair on the storage
  set(
    key: Litereum.Term,
    val: Litereum.Term,
    cont: Litereum.Block,
  )
  // Calls an external contract, returns the result
  call(
    addr: Litereum.Term,
    args: Litereum.Term,
    bind: String,
    cont: Litereum.Term -> Litereum.Block,
  )
  // Creates a new external contract
  spawn(
    addr: Litereum.Term,
    main: Litereum.Term,
    cont: Litereum.Block,
  )
}

// A smart-contract
type Litereum.Bond {
  new(
    main: Litereum.Term
    state: Map<Bits>
  )
}

// The global state
type Litereum.World {
  new(
    bonds: Map<Litereum.Bond>
  )
}

Litereum.Body.deserializer: Deserializer<Litereum.Body>
  Vector.deserializer!(8,U256.deserializer)

Litereum.Body.serializer: Serializer<Litereum.Body>
  Vector.serializer!(8,U256.serializer)

Litereum.Signature.deserializer: Deserializer<Litereum.Signature>
  Vector.deserializer!(32,U256.deserializer)

Litereum.Signature.serializer: Serializer<Litereum.Signature>
  Vector.serializer!(32,U256.serializer)

Litereum.Hash.serializer: Serializer<Litereum.Hash>
  U256.serializer

Litereum.Hash.deserializer: Deserializer<Litereum.Hash>
  U256.deserializer

// Takes the Keccak hash of a list of words
Litereum.Hash.from_words(words: List<U256>): Litereum.Hash
  Crypto.Keccak.hash.words(words)

// Hashes a buffer into a 1024-byte signable string
Litereum.Summary.from_bytes(len_bytes: Pair<U32,Buffer8>): Litereum.Summary
  let vals = Buffer8.to_list(Crypto.Keccak.hash.bytes(len_bytes))
  let csum = 7650 :: U32
  let csum = for i from 2 to List.length!(vals): csum - U8.to_u32(vals[i] <> 0)
  let vals = vals[0] <- U32.to_u8(U32.div(csum, 256))
  let vals = vals[1] <- U32.to_u8(U32.mod(csum, 256))
  let vals = Vector.from_list.length!(32, 0, vals)
  vals

// Converts a list of words to a signable
Litereum.Summary.from_words(words: List<U256>): Litereum.Summary
  Litereum.Summary.from_bytes(Buffer8.from_list.256(words))

// Converts a UTF-8 string to a signable
Litereum.Summary.from_utf8(str: String): Litereum.Summary
  Litereum.Summary.from_bytes(Buffer8.from_hex(String.to_hex(str)))

// Converts a seed to a private key
Litereum.Private.from_seed(seed: U256): Litereum.Private
  Litereum.Private.from_seed.go(32, seed)

Litereum.Private.from_seed.go(len: Nat, seed: U256): Vector<U256,len>
  case len {
    zero:
      Vector.nil!
    succ:
      let head = Litereum.Hash.from_words([U256.add(seed, Nat.to_u256(len))])
      let tail = Litereum.Private.from_seed.go(len.pred, seed)
      Vector.cons<U256,len.pred>(head, tail)
  }!

// Coverts a private key to an address
Litereum.Public.from_private(pvt: Litereum.Private): Litereum.Private
  Litereum.Public.from_private.go(32, pvt)

Litereum.Public.from_private.go(len: Nat, pvt: Vector<U256,len>): Vector<U256,len>
  case len with pvt {
    zero: Vector.nil!
    succ: case pvt {
      cons:
        let hash = pvt.head
        let hash = for i from 0 to 256:
          Litereum.Hash.from_words([hash])
        Vector.cons<U256,len.pred>(hash, Litereum.Public.from_private.go(len.pred, pvt.tail))
    }
  }!

// Converts a public key to an address
Litereum.Address.from_public(pub: Litereum.Public): Litereum.Address
  let vals = Buffer8.from_list.256(Vector.to_list!(32, pub))
  let addr = Buffer8.to_u256(Crypto.Keccak.hash.bytes(vals)@snd)
  addr

// Signs a signable
Litereum.Signature.sign(msg: Litereum.Summary, pvt: Litereum.Private): Litereum.Signature
  Litereum.Signature.sign.go(32, msg, pvt)

Litereum.Signature.sign.go(len: Nat, msg: Vector<U8,len>, pvt: Vector<U256,len>): Vector<U256,len>
  case len with msg pvt {
    zero: case msg pvt {
      nil nil: Vector.nil!
    }
    succ: case msg pvt {
      cons cons:
        let hash = pvt.head
        let hash = for i from 0 to 256 - U8.to_nat(msg.head):
          Litereum.Hash.from_words([hash])
        Vector.cons<U256,len.pred>(hash, Litereum.Signature.sign.go(len.pred, msg.tail, pvt.tail))
    }
  }!

// Verifies if a signature is correct
Litereum.Signature.verify(msg: Litereum.Summary, addr: Litereum.Address, sig: Litereum.Signature): Bool
  let checksums = Litereum.Signature.checksum(msg)
  let sign_addr = Litereum.Signature.recover(msg, sig)
  checksums && U256.eql(addr, sign_addr)

// Checks if the signable checksum is correct
Litereum.Signature.checksum(msg: Litereum.Summary): Bool
  Litereum.Signature.checksum.go(32, msg)

Litereum.Signature.checksum.go(len: Nat, msg: Vector<U8,len>): Bool
  let vals = Vector.to_list<U8>(len, msg)
  let csum = 7650 :: U32
  let csum = for i from 2 to List.length!(vals):
    csum - U8.to_u32(vals[i] <> 0)
  let cs_0 = U8.to_u32(vals[0] <> 0)
  let cs_1 = U8.to_u32(vals[1] <> 0)
  U32.eql(csum, U32.add(U32.mul(cs_0, 256), cs_1))

// Returns the public key that signed a message
Litereum.Signature.recover(msg: Litereum.Summary, sig: Litereum.Signature): Litereum.Address
  Litereum.Address.from_public(Litereum.Signature.recover.go(32, msg, sig))

Litereum.Signature.recover.go(len: Nat, msg: Vector<U8,len>, sig: Vector<U256,len>): Vector<U256,len>
  case len with msg sig {
    zero: Vector.nil!
    succ: case msg sig {
      cons cons cons:
        let hash = sig.head
        let hash = for i from 0 to U8.to_nat(msg.head): Litereum.Hash.from_words([hash])
        Vector.cons<U256,len.pred>(hash, Litereum.Signature.recover.go(len.pred, msg.tail, sig.tail))
    }
  }!

Litereum.Term.to_bits(
  term: Litereum.Term
): Bits
  case Litereum.Term.reduce(term) as term {
    nil: Bits.e
    cons0: Bits.o(Litereum.Term.to_bits(term.pred))
    cons1: Bits.i(Litereum.Term.to_bits(term.pred))
  } default Bits.e

Litereum.Term.from_bits(
  bits: Bits
): Litereum.Term
  case bits {
    e: Litereum.Term.nil
    o: Litereum.Term.cons0(Litereum.Term.from_bits(bits.pred))
    i: Litereum.Term.cons1(Litereum.Term.from_bits(bits.pred))
  }

Litereum.Term.to_address(
  term: Litereum.Term
): Litereum.Address
  U256.from_nat(Bits.to_nat(Litereum.Term.to_bits(term)))

Litereum.Term.from_address(
  addr: Litereum.Address
): Litereum.Term
  Litereum.Term.from_bits(Bits.pad_left(256, false, Nat.to_bits(U256.to_nat(addr))))

Litereum.Term.reduce(
  term: Litereum.Term
): Litereum.Term
  case term {
    app: case Litereum.Term.reduce(term.func) as func {
      lam: Litereum.Term.reduce(func.body(term.argm))
    } default term
    elim: case Litereum.Term.reduce(term.bits) as bits {
      nil: Litereum.Term.reduce(term.case_nil)
      cons0: Litereum.Term.reduce(term.case_cons0(bits.pred))
      cons1: Litereum.Term.reduce(term.case_cons1(bits.pred))
    } default term
  } default term
  
type Litereum.Result {
  new(
    cost: Nat
    value: Litereum.Term
    world: Litereum.World
  )
}

Litereum.Term.execute(
  cost: Nat
  addr: Litereum.Address
  term: Litereum.Term
  world: Litereum.World
): Litereum.Result
  open world
  let bond = world.bonds{U256.show(addr)}
  case Litereum.Term.reduce(term) as term {
    return:
      Litereum.Result.new(cost, term.result, world)
    get: 
      let cost = cost + 1
      let key = Litereum.Term.to_bits(term.key)
      case bond {
        none:
          Litereum.Term.execute(cost, addr, term.cont(Litereum.Term.nil), world)
        some:
          use bond = bond.value
          let val = Litereum.Term.from_bits(bond.state{Bits.show(key)} <> Bits.e)
          Litereum.Term.execute(cost, addr, term.cont(val), world)
      }
    set:
      let cost = cost + 1
      let key = Litereum.Term.to_bits(term.key)
      let val = Litereum.Term.to_bits(term.val)
      let world = case bond {
        none:
          world
        some: 
          use bond = bond.value
          let state = bond.state{Bits.show(key)} <- val
          let bond = bond@state <- state
          let bonds = world.bonds{U256.show(addr)} <- bond
          world@bonds <- bonds
      }
      Litereum.Term.execute(cost, addr, term.cont, world)
    call:
      let cost = cost + 1
      let targ_addr = Litereum.Term.to_address(term.addr)
      let targ_bond = world.bonds{U256.show(targ_addr)}
      case targ_bond {
        none:
          Litereum.Term.execute(cost, addr, term.cont(Litereum.Term.nil), world)
        some:
          use targ_bond = targ_bond.value
          let targ_term = targ_bond.main
          let targ_term = Litereum.Term.app(targ_term, Litereum.Term.from_address(targ_addr))
          let targ_term = Litereum.Term.app(targ_term, Litereum.Term.to_bits(term.args))
          use result = Litereum.Term.execute(cost, targ_addr, targ_term, world)
          Litereum.Term.execute(result.cost, addr, term.cont(result.value), result.world)
      }
    spawn:
      let cost = cost + 1
      let bond_addr = Litereum.Term.to_address(term.addr)
      let world.bonds = world.bonds{U256.show(bond_addr)} <- Litereum.Bond.new(term.main, {})
      let world = world@bonds <- world.bonds
      Litereum.Term.execute(cost, addr, term.cont, world)
  } default Litereum.Result.new(cost, Litereum.Term.nil, world)

Litereum.Term.parser: Parser<Litereum.Term>
  Parser.choice!([
    Parser {
      Kind.Parser.text("@")
      get bind = Kind.Parser.name
      Kind.Parser.text("=>")
      get body = Litereum.Term.parser
      return Litereum.Term.lam(bind, () body)
    }
    Parser {
      Kind.Parser.text("(")
      get func = Litereum.Term.parser
      get argm = Litereum.Term.parser
      Kind.Parser.text(")")
      return Litereum.Term.app(func, argm)
    }
    Parser {
      Kind.Parser.text("*")
      return Litereum.Term.nil
    }
    Parser {
      Kind.Parser.text("0")
      get pred = Litereum.Term.parser
      return Litereum.Term.cons0(pred)
    }
    Parser {
      Kind.Parser.text("1")
      get pred = Litereum.Term.parser
      return Litereum.Term.cons1(pred)
    }
    Parser {
      Kind.Parser.text("case ")
      get bits = Litereum.Term.parser
      Kind.Parser.text("as")
      get name = Kind.Parser.name
      Kind.Parser.text("{")
      Kind.Parser.text("$:")
      get case_nil = Litereum.Term.parser
      Kind.Parser.text("0:")
      get case_cons0 = Litereum.Term.parser
      Kind.Parser.text("1:")
      get case_cons1 = Litereum.Term.parser
      Kind.Parser.text("}")
      return Litereum.Term.elim(bits, name, case_nil, () case_cons0, () case_cons1)
    }
    Parser {
      Kind.Parser.text("{")
      get statements = Litereum.Block.parser
      Kind.Parser.text("}")
      return Litereum.Term.block(statements)
    }
  ])

Litereum.Term.show(term: Litereum.Term): String
  case term {
    lam:
      "@"
      | term.name
      | " => "
      | Litereum.Term.show(term.body(Litereum.Term.var(term.name)))
    app:
      "("
      | Litereum.Term.show(term.func)
      | " "
      | Litereum.Term.show(term.argm)
      | ")"
    var:
      term.name
    nil:
      "*"
    cons0:
      "0" | Litereum.Term.show(term.pred)
    cons1:
      "1" | Litereum.Term.show(term.pred)
    elim:
      "case "
      | Litereum.Term.show(term.bits)
      | " as "
      | term.name
      | " {"
      | " $: " | Litereum.Term.show(term.case_nil)
      | " 0: " | Litereum.Term.show(term.case_cons0(Litereum.Term.var(term.name | ".pred")))
      | " 1: " | Litereum.Term.show(term.case_cons0(Litereum.Term.var(term.name | ".pred")))
      | "}"
    block:
      "{"
      | Litereum.Block.show(term.statements)
      | "}"
  }

Litereum.Block.parser: Parser<Litereum.Block>
  Parser.choice!([
    Parser {
      Kind.Parser.text("return ")
      get result = Litereum.Term.parser
      return Litereum.Block.return(result)
    }
    Parser {
      get bind = Kind.Parser.name
      Kind.Parser.text("=")
      Kind.Parser.text("(get ")
      get key = Litereum.Term.parser
      Kind.Parser.text(")")
      Kind.Parser.text(";")
      get cont = Litereum.Block.parser
      return Litereum.Block.get(key, bind, () cont)
    }
    Parser {
      Kind.Parser.text("(set ")
      get key = Litereum.Term.parser
      get val = Litereum.Term.parser
      Kind.Parser.text(")")
      Kind.Parser.text(";")
      get cont = Litereum.Block.parser
      return Litereum.Block.set(key, val, cont)
    }
    Parser {
      get bind = Kind.Parser.name
      Kind.Parser.text("=")
      Kind.Parser.text("(call")
      get addr = Litereum.Term.parser
      get args = Litereum.Term.parser
      Kind.Parser.text(")")
      Kind.Parser.text(";")
      get cont = Litereum.Block.parser
      return Litereum.Block.call(addr, args, bind, () cont)
    }
    Parser {
      Kind.Parser.text("(spawn ")
      get addr = Litereum.Term.parser
      get main = Litereum.Term.parser
      Kind.Parser.text(")")
      Kind.Parser.text(";")
      get cont = Litereum.Block.parser
      return Litereum.Block.spawn(addr, main, cont)
    }
  ])

Litereum.Block.show(block: Litereum.Block): String
  case block {
    return:
      "return "
      | Litereum.Term.show(block.result)
      | ";"
    get:
      block.bind
      | " = (get " | Litereum.Term.show(block.key) | "); "
      | Litereum.Block.show(block.cont(Litereum.Term.var(block.bind)))
    set:
      "(set "
      | Litereum.Term.show(block.key)
      | " "
      | Litereum.Term.show(block.val)
      | "); "
      | Litereum.Block.show(block.cont)
    call:
      block.bind
      | " = "
      | "(call "
      | Litereum.Term.show(block.addr)
      | " "
      | Litereum.Term.show(block.args)
      | "); "
      | Litereum.Block.show(block.cont(Litereum.Term.var(block.bind)))
    spawn:
      "(spawn "
      | Litereum.Term.show(block.addr)
      | " "
      | Litereum.Term.show(block.main)
      | "); "
      | Litereum.Block.show(block.cont)
  }
