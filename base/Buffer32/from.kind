//Buffer32.from(str: String): Buffer32
//  let size = String.length(str)
//  Buffer32.from.go(str, Buffer32.alloc(size), 0#32)

//[AA, BB, CC, DD] :: List<U8>
//AABBCCDD :: U32
//[AA, BB, CC] :: List<U8>
//AABBCC00 :: U32
//Buffer32.Bytelist.bytes_to_u32([AA, BB], 0)
//Buffer32.Bytelist.bytes_to_u32([BB], AA)
//AABB0000

Buffer32.Bytelist.bytes_to_u32(bytes: List<U8>, u_aux: U32): U32
  case bytes {
    nil:
      u_aux 
    cons:
      let h = Nat.to_u32(U8.to_nat(bytes.head))
      let u_aux = U32.shl(8, u_aux)
      let u_aux = U32.or(h, u_aux)
      Buffer32.Bytelist.bytes_to_u32(bytes.tail, u_aux)
  }

Buffer32.Bytelist.to_buffer32(list: List<U8>, buf: Buffer32, idx: U32): Buffer32
  let bytes = List.take!(4, list)
  let u = Buffer32.Bytelist.bytes_to_u32(bytes, 0)
  let u = U32.shl(8*(4 - Nat.to_u32(List.length!(bytes))), u)
  let buf = Buffer32.set(idx, u, buf)
  let tail = List.drop!(4, list)
  case tail {
    nil:
      buf
    cons:
      Buffer32.Bytelist.to_buffer32(tail, buf, U32.add(1#32, idx))
  }

String.to_utf8_bytes(str: String): List<U8>
  case str {
    nil:
      []
    cons:
      let u16_to_u8 = ((x) Nat.to_u8(U16.to_nat(x))) :: U16 -> U8
      let c = str.head
      if U16.ltn(c, 0x80) then
        let b0 = u16_to_u8(U16.or(0x00, U16.and(0x7F, U16.shr(0, c)))) // (c>>0 & 0x7F) | 0x00
        b0 & String.to_utf8_bytes(str.tail) 
      else if U16.ltn(c, 0x0800) then
        let b0 = u16_to_u8(U16.or(0xC0, U16.and(0x1F, U16.shr(6, c)))) // (c>>6 & 0x1F) | 0xC0
        let b1 = u16_to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(0, c)))) // (c>>0 & 0x3F) | 0x80
        b0 & b1 & String.to_utf8_bytes(str.tail) 
      else if U16.ltn(c, 0x010000) then
        let b0 = u16_to_u8(U16.or(0xE0, U16.and(0x0F, U16.shr(12, c)))) // (c>>12 & 0x0F) | 0xE0
        let b1 = u16_to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(6,  c)))) // (c>>6 & 0x3F) | 0x80
        let b2 = u16_to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(0,  c)))) // (c>>0 & 0x3F) | 0x80
        b0 & b1 & b2 & String.to_utf8_bytes(str.tail)
      else // 0x110000
        let b0 = u16_to_u8(U16.or(0xF0, U16.and(0x07, U16.shr(18, c)))) // (c>>18 & 0x07) | 0xF0
        let b1 = u16_to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(12, c)))) // (c>>12 & 0x3F) | 0x80
        let b2 = u16_to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(6,  c)))) // (c>>6 & 0x3F) | 0x80
        let b3 = u16_to_u8(U16.or(0x80, U16.and(0x3F, U16.shr(0,  c)))) // (c>>0 & 0x3F) | 0x80
        b0 & b1 & b2 & b3 & String.to_utf8_bytes(str.tail)
  }

Buffer32.from(str: String): Buffer32
  let bytelist = String.to_utf8_bytes(str)
  let buf_size = ((List.length!(bytelist)-1) / 4) + 1 // divide by 4 rounding up
  let buf = Buffer32.alloc(buf_size)
  Buffer32.Bytelist.to_buffer32(bytelist, buf, 0)
 

// 1. calcular o comprimento em bytes (da str)
// 2. passa escrevendo no buffer
// 00 73 | 05 AF
// c = 00 73
// c>>0 = 00 73
// c>>0 & 0x7F = 00 73
// c>>0 & 0x7F | 0x00 = 00 73
// 73
// c = 05 AF
// c>>6 = 00 16
// c>>6 & 0x1F = 00 16
// c>>6 & 0x1F | 0xC0 = 00 D6
