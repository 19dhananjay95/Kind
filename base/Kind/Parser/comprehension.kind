Kind.Parser.comprehension: Parser<Kind.Term>
  Parser.first_of!([
    Kind.Parser.comprehension_with_where,
    Kind.Parser.comprehension_without_where      
  ])
  
  
Kind.Parser.comprehension_without_where: Parser<Kind.Term>
  Parser {
    Kind.Parser.text("[")
    get loop = Kind.Parser.term
    Kind.Parser.text("for")
    get elem = Kind.Parser.name1
    Kind.Parser.text("in")
    get list = Kind.Parser.term
    Kind.Parser.text("]")

    let term = Kind.Term.ref("List.map")
    let term = Kind.Term.app(term, Kind.Term.hol(Bits.e))
    let term = Kind.Term.app(term, Kind.Term.hol(Bits.e))
    let lamb = Kind.Term.lam(elem, (i) loop)
    let term = Kind.Term.app(term, lamb)
    let term = Kind.Term.app(term, list)
    
    return term
  }


Kind.Parser.comprehension_with_where: Parser<Kind.Term>
  Parser {
    Kind.Parser.text("[")
    get loop = Kind.Parser.term
    Kind.Parser.text("for")
    get elem = Kind.Parser.name1
    Kind.Parser.text("in")
    get list = Kind.Parser.term
    get filters = Kind.Parser.items!("where", Kind.Parser.term ,"]")
    
    let and = Kind.Parser.comprehension.and_all(filters)

    let filter_fun = Kind.Term.ref("List.filter")
    let filter_fun = Kind.Term.app(filter_fun, Kind.Term.hol(Bits.e))
    let lamb_filter = Kind.Term.lam(elem, (i) and)
    let filter_fun = Kind.Term.app(filter_fun, lamb_filter)
    let filter_fun = Kind.Term.app(filter_fun, list)
    
    let term = Kind.Term.ref("List.map")
    let term = Kind.Term.app(term, Kind.Term.hol(Bits.e))
    let term = Kind.Term.app(term, Kind.Term.hol(Bits.e))
    let lamb = Kind.Term.lam(elem, (i) loop)
    let term = Kind.Term.app(term, lamb)
    let term = Kind.Term.app(term, filter_fun)
    
    return term
  }

// transform list of Kind.Term in a Kind.Term representing a list
Kind.Parser.comprehension.and_all(a: List<Kind.Term>): Kind.Term
  case a {
    nil: 
      Kind.Term.ref("Bool.true")
    cons:
      let and  = Kind.Term.ref("Bool.and")
      let and = Kind.Term.app(and, a.head)
      let and = Kind.Term.app(and, Kind.Parser.comprehension.and_all(a.tail))
      and
  }