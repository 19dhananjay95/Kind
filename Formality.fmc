// Bool
// ====

Bool: Type
  self<P: Bool -> Type> ->
  P(true) ->
  P(false) ->
  P(self)

true: Bool
  <> => (t) => (f) => t

false: Bool
  <> => (t) => (f) => f

_bool : (b: Bool) -> <P: Bool -> Type> -> P(true) -> P(false) -> P(b)
  (b) => <P> => (t) => (f) => b<P>(t)(f)

not: Bool -> Bool
  (a) =>
  let _t = false
  let _f = true
  a<() => Bool>(_t)(_f)

or: Bool -> Bool -> Bool
  (a) => (b) =>
  let _a_tru = (b)<() => Bool>(true)(true)
  let _a_fal = (b)<() => Bool>(true)(false)
  a<() => Bool>(_a_tru)(_a_fal)

and: Bool -> Bool -> Bool
  (a) => (b) =>
  let _a_tru = (b)<() => Bool>(true)(false)
  let _a_fal = (b)<() => Bool>(false)(false)
  a<() => Bool>(_a_tru)(_a_fal)

// Cmp

Cmp : Type
  self<P: Cmp -> Type> ->
  P(ltn) ->
  P(eql) ->
  P(gtn) ->
  P(self)

ltn: Cmp
  <> => (ltn) => (eql) => (gtn) => ltn

eql: Cmp
  <> => (ltn) => (eql) => (gtn) => eql

gtn: Cmp
  <> => (ltn) => (eql) => (gtn) => gtn

// Bit
// ===

Bit : Type
  self<P: Bit -> Type> ->
  P(t0) ->
  P(t1) ->
  P(self)

t0: Bit
  <> => (t0) => (t1) => t0

t1: Bit
  <> => (t0) => (t1) => t1

// Nat
// ===

Nat: Type
  self<P: (x: Nat) -> Type> ->
  (P(zero)) ->
  ((pred: Nat) -> P(succ(pred))) ->
  P(self)

zero: Nat
  <> => (z) => (s) => z

succ: Nat -> Nat
  (n) => <> => (z) => (s) => s(n)

pred: Nat -> Nat
  (n) =>
  let _zero = zero
  let _succ = (pred) => pred
  n<() => Nat>(_zero)(_succ)

fold_nat : (n: Nat) -> <P: Nat -> Type> -> P(zero) -> ((n:Nat) -> P(n) -> P(succ(n))) -> P(n)
  (n) => <P> => (z) => (s) =>
  n<P>(z)((pred) => s(pred)(fold_nat(pred)<P>(z)(s)))

double: Nat -> Nat
  (n) => 
  let _zero = zero
  let _succ = (pred) => succ(succ(double(pred)))
  n<() => Nat>(_zero)(_succ)

add: Nat -> Nat -> Nat
  (n) => (m) =>
  let _zero = m
  let _succ = (n_pred) => succ(add(n_pred)(m))
  n<() => Nat>(_zero)(_succ)

sub: Nat -> Nat -> Nat
  (n) => (m) =>
  let _zero = n
  let _succ = (m_pred) => sub(pred(n))(m_pred)
  m<() => Nat>(_zero)(_succ)

nat_cmp: Nat -> Nat -> Cmp
  (a) => (b) =>
  let _a_zero =
    let _b_zero = eql
    let _b_succ = (b_pred) => ltn
    b<() => Cmp>(_b_zero)(_b_succ)
  let _a_succ = (a_pred) =>
    let _b_zero = gtn
    let _b_succ = (b_pred) => nat_cmp(a_pred)(b_pred)
    b<() => Cmp>(_b_zero)(_b_succ)
  a<() => Cmp>(_a_zero)(_a_succ)

nat_ltn: Nat -> Nat -> Bool
  (a) => (b) => nat_cmp(a)(b)<() => Bool>(true)(false)(false)

nat_lte: Nat -> Nat -> Bool
  (a) => (b) => nat_cmp(a)(b)<() => Bool>(true)(true)(false)

nat_eql: Nat -> Nat -> Bool
  (a) => (b) => nat_cmp(a)(b)<() => Bool>(false)(true)(false)

nat_gte: Nat -> Nat -> Bool
  (a) => (b) => nat_cmp(a)(b)<() => Bool>(false)(true)(true)

nat_gtn: Nat -> Nat -> Bool
  (a) => (b) => nat_cmp(a)(b)<() => Bool>(false)(false)(true)

n0: Nat
  zero

n1: Nat
  succ(n0)

n2: Nat
  succ(n1)

n3: Nat
  succ(n2)

n4: Nat
  succ(n3)

n5: Nat
  succ(n4)

n6: Nat
  succ(n5)

n7: Nat
  succ(n6)

n8: Nat
  succ(n7)

n9: Nat
  succ(n8)

n9: Nat
  succ(n8)

n10: Nat
  succ(n9)

n11: Nat
  succ(n10)

n12: Nat
  succ(n11)

n13: Nat
  succ(n12)

n14: Nat
  succ(n13)

n15: Nat
  succ(n14)

n16: Nat
  succ(n15)

n17: Nat
  succ(n16)

n18: Nat
  succ(n17)

n19: Nat
  succ(n18)

n20: Nat
  succ(n19)

n21: Nat
  succ(n20)

n22: Nat
  succ(n21)

n23: Nat
  succ(n22)

n24: Nat
  succ(n23)

n25: Nat
  succ(n24)

n26: Nat
  succ(n25)

n27: Nat
  succ(n26)

n28: Nat
  succ(n27)

n29: Nat
  succ(n28)

n30: Nat
  succ(n29)

n31: Nat
  succ(n30)

n32: Nat
  succ(n31)

// Pair
// ====

Pair: Type -> Type -> Type
  (A) => (B) =>
  self<P: Pair(A)(B) -> Type> ->
  (pair: (a: A) -> (b: B) -> P(pair<A><B>(a)(b))) ->
  P(self)

pair: <A: Type> -> <B: Type> -> A -> B -> Pair(A)(B)
  <> => <> => (a) => (b) =>
  <> => (pair) =>
  pair(a)(b)

fst: <A: Type> -> <B: Type> -> Pair(A)(B) -> A
  <A> => <B> => (pair) =>
  pair<() => A>((a) => (b) => a)

snd: <A: Type> -> <B: Type> -> Pair(A)(B) -> B
  <A> => <B> => (pair) =>
  pair<() => B>((a) => (b) => b)

// Maybe
// =====

Maybe: Type -> Type
  (A) =>
  self<P: Maybe(A) -> Type> ->
  (P(none<A>)) ->
  ((value: A) -> P(some<A>(value))) ->
  P(self)

none: <A: Type> -> Maybe(A)
  <> =>
  <> => (none) => () => none

some: <A: Type> -> A -> Maybe(A)
  <> => (value) =>
  <> => () => (some) => some(value)

// List
// ====

List: (A: Type) -> Type
  (A) =>
  self<P: (x: List(A)) -> Type> ->
  (nil: P(nil<A>)) ->
  (cons: (head: A) -> (tail: List(A)) -> P(cons<A>(head)(tail))) ->
  P(self)

nil: <A: Type> -> List(A)
  <A> =>
  <> => (nil) => () => nil

cons: <A: Type> -> (:A) -> (:List(A)) -> List(A)
  <A> => (head) => (tail) =>
  <> => () => (cons) => cons(head)(tail)

find_aux: <A: Type> -> List(A) -> (A -> Nat -> Bool) -> Nat -> Maybe(Pair(A)(Nat))
  <A> => (list) => (cond) => (indx) =>
  let _nil = none<Pair(A)(Nat)>
  let _cons = (head) => (tail) =>
    let _true  = some<Pair(A)(Nat)>(pair<A><Nat>(head)(indx))
    let _false = find_aux<A>(tail)(cond)(succ(indx))
    cond(head)(indx)<() => Maybe(Pair(A)(Nat))>(_true)(_false)
  list<() => Maybe(Pair(A)(Nat))>(_nil)(_cons)

find: <A: Type> -> List(A) -> (A -> Nat -> Bool) -> Maybe(Pair(A)(Nat))
  <A> => (list) => (cond) =>
  find_aux<A>(list)(cond)(zero)

take: <A: Type> -> Nat -> List(A) -> List(A)
  <A> => (n) => (list) =>
  let _nil = nil<A>
  let _cons = (head) => (tail) =>
    let _zero = nil<A>
    let _succ = (pred) => cons<A>(head)(take<A>(pred)(tail))
    n<() => List(A)>(_zero)(_succ)
  list<() => List(A)>(_nil)(_cons)

drop: <A: Type> -> Nat -> List(A) -> List(A)
  <A> => (n) => (list) =>
  let _nil = nil<A>
  let _cons = (head) => (tail) =>
    let _zero = tail
    let _succ = (pred) => drop<A>(pred)(tail)
    n<() => List(A)>(_zero)(_succ)
  list<() => List(A)>(_nil)(_cons)

is_empty: <A: Type> -> List(A) -> Bool
  <A> => (list) =>
  let _nil = true
  let _cons = (head) => (tail) => false
  list<() => Bool>(_nil)(_cons)

zip_with: <A: Type> -> <B: Type> -> <C: Type> -> (A -> B -> C) -> List(A) -> List(B) -> List(C)
  <A> => <B> => <C> => (fn) => (as) => (bs) =>
  let _a_nil = nil<C>
  let _a_cons = (a_head) => (a_tail) =>
    let _b_nil = nil<C>
    let _b_cons = (b_head) => (b_tail) =>
      let head = fn(a_head)(b_head)
      let tail = zip_with<A><B><C>(fn)(a_tail)(b_tail)
      cons<C>(head)(tail)
    bs<() => List(C)>(_b_nil)(_b_cons)
  as<() => List(C)>(_a_nil)(_a_cons)

all_satisfy: <A: Type> -> (A -> Bool) -> List(A) -> Bool
  <A> => (cond) => (list) =>
  let _nil = true
  let _cons = (head) => (tail) =>
    let _t = all_satisfy<A>(cond)(tail)
    let _f = false
    cond(head)<() => Bool>(_t)(_f)
  list<() => Bool>(_nil)(_cons)

any_satisfy: <A: Type> -> (A -> Bool) -> List(A) -> Bool
  <A> => (cond) => (list) =>
  let _nil = false
  let _cons = (head) => (tail) =>
    let _t = true
    let _f = any_satisfy<A>(cond)(tail)
    cond(head)<() => Bool>(_t)(_f)
  list<() => Bool>(_nil)(_cons)

all_true: List(Bool) -> Bool
  (list) => all_satisfy<Bool>((x) => x)(list)

any_true: List(Bool) -> Bool
  (list) => any_satisfy<Bool>((x) => x)(list)

list_len: <A: Type> -> List(A) -> Nat
  <A> => (list) =>
  let _nil = zero
  let _cons = (head) => (tail) => succ(list_len<A>(tail))
  list<() => Nat>(_nil)(_cons)

concat : <A: Type> -> List(A) -> List(A) -> List(A)
  <A> => (as) => (bs) =>
  let _nil = bs
  let _cons = (head) => (tail) => cons<A>(head)(concat<A>(tail)(bs))
  as<() => List(A)>(_nil)(_cons)

flatten : <A: Type> -> List(List(A)) -> List(A)
  <A> => (as) =>
  let _nil = nil<A>
  let _cons = (head) => (tail) => concat<A>(head)(flatten<A>(tail))
  as<() => List(A)>(_nil)(_cons)

single : <A : Type> -> (x : A) -> List(A)
  <A> => (x) => cons<A>(x)(nil<A>)

// Bits
// ====

Bits: Type
  self<P: Bits -> Type> ->
  (P(be)) ->
  ((pred: Bits) -> P(b0(pred))) ->
  ((pred: Bits) -> P(b1(pred))) ->
  P(self)

be: Bits
  <P> => (be) => (b0) => (b1) => be

b0: (bs: Bits) -> Bits
  (bs) => <P> => (be) => (b0) => (b1) => b0(bs)

b1: (bs: Bits) -> Bits
  (bs) => <P> => (be) => (b0) => (b1) => b1(bs)

// Word
// ====

Word: Nat -> Type
  (size) =>
  self<P: (size: Nat) -> Word(size) -> Type> ->
  (P(zero)(we)) ->
  (<size: Nat> -> (pred: Word(size)) -> P(succ(size))(w0<size>(pred))) ->
  (<size: Nat> -> (pred: Word(size)) -> P(succ(size))(w1<size>(pred))) ->
  P(size)(self)

we: Word(zero)
  <P> => (we) => (w0) => (w1) =>
  we

w0: <size: Nat> -> Word(size) -> Word(succ(size))
  <size> => (wo) => <P> => (we) => (w0) => (w1) =>
  w0<size>(wo)

w1: <size: Nat> -> Word(size) -> Word(succ(size))
  <size> => (wo) => <P> => (we) => (w0) => (w1) =>
  w1<size>(wo)

word_inc: <size: Nat> -> Word(size) -> Word(size)
  <size> => (word) =>
  let _we = we
  let _w0 = <size> => (pred) => w1<size>(pred)
  let _w1 = <size> => (pred) => w0<size>(word_inc<size>(pred))
  let motive  = (size) => (word) => Word(size)
  word<motive>(_we)(_w0)(_w1)

word_add_aux: <size: Nat> -> Word(size) -> Word(size) -> Bool -> Word(size)
  <size> => (a) => (b) => (c) =>
  let _a_we = (b) => we
  let _a_w0 = <a_size> => (a_pred) => (b) =>
    let _b_we = (a_pred) =>
      we
    let _b_w0 = <b_size> => (b_pred) => (a_pred) =>
      let _c_tr = w1<b_size>(word_add_aux<b_size>(a_pred)(b_pred)(false))
      let _c_fa = w0<b_size>(word_add_aux<b_size>(a_pred)(b_pred)(false))
      let _c_ty = (c_bool) => Word(succ(b_size))
      c<_c_ty>(_c_tr)(_c_fa)
    let _b_w1 = <b_size> => (b_pred) => (a_pred) =>
      let _c_tr = w0<b_size>(word_add_aux<b_size>(a_pred)(b_pred)(true))
      let _c_fa = w1<b_size>(word_add_aux<b_size>(a_pred)(b_pred)(false))
      let _c_ty = (c_bool) => Word(succ(b_size))
      c<_c_ty>(_c_tr)(_c_fa)
    let _b_ty = (b_size) => (b_word) =>
      Word(pred(b_size)) -> Word(b_size)
    b<_b_ty>(_b_we)(_b_w0)(_b_w1)(a_pred)
  let _a_w1 = <a_size> => (a_pred) => (b) =>
    let _b_we = (a_pred) => we
    let _b_w0 = <b_size> => (b_pred) => (a_pred) =>
      let _c_tr = w0<b_size>(word_add_aux<b_size>(a_pred)(b_pred)(true))
      let _c_fa = w1<b_size>(word_add_aux<b_size>(a_pred)(b_pred)(false))
      let _c_ty = (c_bool) => Word(succ(b_size))
      c<_c_ty>(_c_tr)(_c_fa)
    let _b_w1 = <b_size> => (b_pred) => (a_pred) =>
      let _c_tr = w1<b_size>(word_add_aux<b_size>(a_pred)(b_pred)(true))
      let _c_fa = w0<b_size>(word_add_aux<b_size>(a_pred)(b_pred)(true))
      let _c_ty = (c_bool) => Word(succ(b_size))
      c<_c_ty>(_c_tr)(_c_fa)
    let _b_ty = (b_size) => (b_word) =>
      Word(pred(b_size)) -> Word(b_size)
    b<_b_ty>(_b_we)(_b_w0)(_b_w1)(a_pred)
  let _a_ty = (a_size) => (a_word) =>
    Word(a_size) -> Word(a_size)
  a<_a_ty>(_a_we)(_a_w0)(_a_w1)(b)

word_add: <size: Nat> -> Word(size) -> Word(size) -> Word(size)
  <size> => (a) => (b) => word_add_aux<size>(a)(b)(false)

word_cmp_aux: <size: Nat> -> Word(size) -> Word(size) -> Cmp -> Cmp
  <size> => (a) => (b) => (c) =>
  let _a_we = (b) => c
  let _a_w0 = <a_size> => (a_pred) => (b) =>
    let _b_we = (a_pred) => c
    let _b_w0 = <b_size> => (b_pred) => (a_pred) => word_cmp_aux<b_size>(a_pred)(b_pred)(c)
    let _b_w1 = <b_size> => (b_pred) => (a_pred) => word_cmp_aux<b_size>(a_pred)(b_pred)(ltn)
    let _b_ty = (b_size) => (b_word) => Word(pred(b_size)) -> Cmp
    b<_b_ty>(_b_we)(_b_w0)(_b_w1)(a_pred)
  let _a_w1 = <a_size> => (a_pred) => (b) =>
    let _b_we = (a_pred) => c
    let _b_w0 = <b_size> => (b_pred) => (a_pred) => word_cmp_aux<b_size>(a_pred)(b_pred)(gtn)
    let _b_w1 = <b_size> => (b_pred) => (a_pred) => word_cmp_aux<b_size>(a_pred)(b_pred)(c)
    let _b_ty = (b_size) => (b_word) => Word(pred(b_size)) -> Cmp
    b<_b_ty>(_b_we)(_b_w0)(_b_w1)(a_pred)
  let _a_ty = (a_size) => (a_word) =>
    Word(a_size) -> Cmp
  a<_a_ty>(_a_we)(_a_w0)(_a_w1)(b)

word_cmp: <size: Nat> -> Word(size) -> Word(size) -> Cmp
  <size> => (a) => (b) =>
  word_cmp_aux<size>(a)(b)(eql)

// a > b
word_ltn: <size:Nat> -> Word(size) -> Word(size) -> Bool
  <size> => (a) => (b) =>
  word_cmp<size>(a)(b)<() => Bool>(true)(false)(false)

// a <= b
word_lte: <size:Nat> -> Word(size) -> Word(size) -> Bool
  <size> => (a) => (b) =>
  word_cmp<size>(a)(b)<() => Bool>(true)(true)(false)

// a == b
word_eql: <size:Nat> -> Word(size) -> Word(size) -> Bool
  <size> => (a) => (b) =>
  word_cmp<size>(a)(b)<() => Bool>(false)(true)(false)

// a >= b
word_gte: <size:Nat> -> Word(size) -> Word(size) -> Bool
  <size> => (a) => (b) =>
  word_cmp<size>(a)(b)<() => Bool>(false)(true)(true)

// a > b
word_gtn: <size:Nat> -> Word(size) -> Word(size) -> Bool
  <size> => (a) => (b) =>
  word_cmp<size>(a)(b)<() => Bool>(false)(false)(true)

// Uint32
// ======

U32: Type
  Word(n32)

u32_0: U32
  w0<n31>(w0<n30>(w0<n29>(w0<n28>(w0<n27>(w0<n26>(w0<n25>(w0<n24>(
  w0<n23>(w0<n22>(w0<n21>(w0<n20>(w0<n19>(w0<n18>(w0<n17>(w0<n16>(
  w0<n15>(w0<n14>(w0<n13>(w0<n12>(w0<n11>(w0<n10>(w0<n9 >(w0<n8 >(
  w0<n7 >(w0<n6 >(w0<n5 >(w0<n4 >(w0<n3 >(w0<n2 >(w0<n1 >(w0<n0 >(
  we))))))))))))))))))))))))))))))))

u32_inc: U32 -> U32
  word_inc<n32>

u32_add: U32 -> U32 -> U32
  word_add<n32>

// a < b
u32_ltn: U32 -> U32 -> Bool
  word_ltn<n32>

// a <= b
u32_lte: U32 -> U32 -> Bool
  word_lte<n32>

// a == b
u32_eql: U32 -> U32 -> Bool
  word_eql<n32>

// a >= b
u32_gte: U32 -> U32 -> Bool
  word_gte<n32>

// a > b
u32_gtn: U32 -> U32 -> Bool
  word_gtn<n32>

// Char
// ====

Char: Type
  Word(n32)

ascii: Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Char
  (a) => (b) => (c) => (d) => (e) => (f) => (g) => (h) =>
  let ty = <size: Nat> -> Word(size) -> Word(succ(size))
  let wA = a<() => ty>(w0)(w1)
  let wB = b<() => ty>(w0)(w1)
  let wC = c<() => ty>(w0)(w1)
  let wD = d<() => ty>(w0)(w1)
  let wE = e<() => ty>(w0)(w1)
  let wF = f<() => ty>(w0)(w1)
  let wG = g<() => ty>(w0)(w1)
  let wH = h<() => ty>(w0)(w1)
  wH<n31>(wG<n30>(wF<n29>(wE<n28>(wD<n27>(wC<n26>(wB<n25>(wA<n24>(
  w0<n23>(w0<n22>(w0<n21>(w0<n20>(w0<n19>(w0<n18>(w0<n17>(w0<n16>(
  w0<n15>(w0<n14>(w0<n13>(w0<n12>(w0<n11>(w0<n10>(w0<n9 >(w0<n8 >(
  w0<n7 >(w0<n6 >(w0<n5 >(w0<n4 >(w0<n3 >(w0<n2 >(w0<n1 >(w0<n0 >(
  we))))))))))))))))))))))))))))))))

// ASCII characters
_NUL   : Char ascii(t0)(t0)(t0)(t0)(t0)(t0)(t0)(t0) // \NUL
_SOH   : Char ascii(t0)(t0)(t0)(t0)(t0)(t0)(t0)(t1) // \SOH
_STX   : Char ascii(t0)(t0)(t0)(t0)(t0)(t0)(t1)(t0) // \STX
_ETX   : Char ascii(t0)(t0)(t0)(t0)(t0)(t0)(t1)(t1) // \ETX
_EOT   : Char ascii(t0)(t0)(t0)(t0)(t0)(t1)(t0)(t0) // \EOT
_ENQ   : Char ascii(t0)(t0)(t0)(t0)(t0)(t1)(t0)(t1) // \ENQ
_ACK   : Char ascii(t0)(t0)(t0)(t0)(t0)(t1)(t1)(t0) // \ACK
_BEL   : Char ascii(t0)(t0)(t0)(t0)(t0)(t1)(t1)(t1) // \BEL
_BS    : Char ascii(t0)(t0)(t0)(t0)(t1)(t0)(t0)(t0) // \BS
_HT    : Char ascii(t0)(t0)(t0)(t0)(t1)(t0)(t0)(t1) // \HT
_LF    : Char ascii(t0)(t0)(t0)(t0)(t1)(t0)(t1)(t0) // \LF
_VT    : Char ascii(t0)(t0)(t0)(t0)(t1)(t0)(t1)(t1) // \VT
_FF    : Char ascii(t0)(t0)(t0)(t0)(t1)(t1)(t0)(t0) // \FF
_CR    : Char ascii(t0)(t0)(t0)(t0)(t1)(t1)(t0)(t1) // \CR
_SO    : Char ascii(t0)(t0)(t0)(t0)(t1)(t1)(t1)(t0) // \SO
_SI    : Char ascii(t0)(t0)(t0)(t0)(t1)(t1)(t1)(t1) // \S 
_DLE   : Char ascii(t0)(t0)(t0)(t1)(t0)(t0)(t0)(t0) // \DLE
_DC1   : Char ascii(t0)(t0)(t0)(t1)(t0)(t0)(t0)(t1) // \DC1
_DC2   : Char ascii(t0)(t0)(t0)(t1)(t0)(t0)(t1)(t0) // \DC2
_DC3   : Char ascii(t0)(t0)(t0)(t1)(t0)(t0)(t1)(t1) // \DC3
_DC4   : Char ascii(t0)(t0)(t0)(t1)(t0)(t1)(t0)(t0) // \DC4
_NAK   : Char ascii(t0)(t0)(t0)(t1)(t0)(t1)(t0)(t1) // \NAK
_SYN   : Char ascii(t0)(t0)(t0)(t1)(t0)(t1)(t1)(t0) // \SYN
_ETB   : Char ascii(t0)(t0)(t0)(t1)(t0)(t1)(t1)(t1) // \ETB
_CAN   : Char ascii(t0)(t0)(t0)(t1)(t1)(t0)(t0)(t0) // \CAN
_EM    : Char ascii(t0)(t0)(t0)(t1)(t1)(t0)(t0)(t1) // \EM
_SUB   : Char ascii(t0)(t0)(t0)(t1)(t1)(t0)(t1)(t0) // \SUB
_ESC   : Char ascii(t0)(t0)(t0)(t1)(t1)(t0)(t1)(t1) // \ESC
_FS    : Char ascii(t0)(t0)(t0)(t1)(t1)(t1)(t0)(t0) // \FS
_GS    : Char ascii(t0)(t0)(t0)(t1)(t1)(t1)(t0)(t1) // \GS
_RS    : Char ascii(t0)(t0)(t0)(t1)(t1)(t1)(t1)(t0) // \RS
_US    : Char ascii(t0)(t0)(t0)(t1)(t1)(t1)(t1)(t1) // \US
_space : Char ascii(t0)(t0)(t1)(t0)(t0)(t0)(t0)(t0) // ' '
_excl  : Char ascii(t0)(t0)(t1)(t0)(t0)(t0)(t0)(t1) // '!'
_quot  : Char ascii(t0)(t0)(t1)(t0)(t0)(t0)(t1)(t0) // '"'
_hash  : Char ascii(t0)(t0)(t1)(t0)(t0)(t0)(t1)(t1) // '#'
_dollar: Char ascii(t0)(t0)(t1)(t0)(t0)(t1)(t0)(t0) // '$'
_percnt: Char ascii(t0)(t0)(t1)(t0)(t0)(t1)(t0)(t1) // '%'
_amp   : Char ascii(t0)(t0)(t1)(t0)(t0)(t1)(t1)(t0) // '&'
_apos  : Char ascii(t0)(t0)(t1)(t0)(t0)(t1)(t1)(t1) // "'"
_lpar  : Char ascii(t0)(t0)(t1)(t0)(t1)(t0)(t0)(t0) // '('
_rpar  : Char ascii(t0)(t0)(t1)(t0)(t1)(t0)(t0)(t1) // ')'
_ast   : Char ascii(t0)(t0)(t1)(t0)(t1)(t0)(t1)(t0) // '*'
_plus  : Char ascii(t0)(t0)(t1)(t0)(t1)(t0)(t1)(t1) // '+'
_comma : Char ascii(t0)(t0)(t1)(t0)(t1)(t1)(t0)(t0) // ','
_dash  : Char ascii(t0)(t0)(t1)(t0)(t1)(t1)(t0)(t1) // '-'
_period: Char ascii(t0)(t0)(t1)(t0)(t1)(t1)(t1)(t0) // '.'
_sol   : Char ascii(t0)(t0)(t1)(t0)(t1)(t1)(t1)(t1) // '/'
_0     : Char ascii(t0)(t0)(t1)(t1)(t0)(t0)(t0)(t0) // '0'
_1     : Char ascii(t0)(t0)(t1)(t1)(t0)(t0)(t0)(t1) // '1'
_2     : Char ascii(t0)(t0)(t1)(t1)(t0)(t0)(t1)(t0) // '2'
_3     : Char ascii(t0)(t0)(t1)(t1)(t0)(t0)(t1)(t1) // '3'
_4     : Char ascii(t0)(t0)(t1)(t1)(t0)(t1)(t0)(t0) // '4'
_5     : Char ascii(t0)(t0)(t1)(t1)(t0)(t1)(t0)(t1) // '5'
_6     : Char ascii(t0)(t0)(t1)(t1)(t0)(t1)(t1)(t0) // '6'
_7     : Char ascii(t0)(t0)(t1)(t1)(t0)(t1)(t1)(t1) // '7'
_8     : Char ascii(t0)(t0)(t1)(t1)(t1)(t0)(t0)(t0) // '8'
_9     : Char ascii(t0)(t0)(t1)(t1)(t1)(t0)(t0)(t1) // '9'
_colon : Char ascii(t0)(t0)(t1)(t1)(t1)(t0)(t1)(t0) // ':'
_semi  : Char ascii(t0)(t0)(t1)(t1)(t1)(t0)(t1)(t1) // ';'
_lt    : Char ascii(t0)(t0)(t1)(t1)(t1)(t1)(t0)(t0) // '<'
_equals: Char ascii(t0)(t0)(t1)(t1)(t1)(t1)(t0)(t1) // '='
_gt    : Char ascii(t0)(t0)(t1)(t1)(t1)(t1)(t1)(t0) // '>'
_quest : Char ascii(t0)(t0)(t1)(t1)(t1)(t1)(t1)(t1) // '?'
_commat: Char ascii(t0)(t1)(t0)(t0)(t0)(t0)(t0)(t0) // '@'
_A     : Char ascii(t0)(t1)(t0)(t0)(t0)(t0)(t0)(t1) // 'A'
_B     : Char ascii(t0)(t1)(t0)(t0)(t0)(t0)(t1)(t0) // 'B'
_C     : Char ascii(t0)(t1)(t0)(t0)(t0)(t0)(t1)(t1) // 'C'
_D     : Char ascii(t0)(t1)(t0)(t0)(t0)(t1)(t0)(t0) // 'D'
_E     : Char ascii(t0)(t1)(t0)(t0)(t0)(t1)(t0)(t1) // 'E'
_F     : Char ascii(t0)(t1)(t0)(t0)(t0)(t1)(t1)(t0) // 'F'
_G     : Char ascii(t0)(t1)(t0)(t0)(t0)(t1)(t1)(t1) // 'G'
_H     : Char ascii(t0)(t1)(t0)(t0)(t1)(t0)(t0)(t0) // 'H'
_I     : Char ascii(t0)(t1)(t0)(t0)(t1)(t0)(t0)(t1) // 'I'
_J     : Char ascii(t0)(t1)(t0)(t0)(t1)(t0)(t1)(t0) // 'J'
_K     : Char ascii(t0)(t1)(t0)(t0)(t1)(t0)(t1)(t1) // 'K'
_L     : Char ascii(t0)(t1)(t0)(t0)(t1)(t1)(t0)(t0) // 'L'
_M     : Char ascii(t0)(t1)(t0)(t0)(t1)(t1)(t0)(t1) // 'M'
_N     : Char ascii(t0)(t1)(t0)(t0)(t1)(t1)(t1)(t0) // 'N'
_O     : Char ascii(t0)(t1)(t0)(t0)(t1)(t1)(t1)(t1) // 'O'
_P     : Char ascii(t0)(t1)(t0)(t1)(t0)(t0)(t0)(t0) // 'P'
_Q     : Char ascii(t0)(t1)(t0)(t1)(t0)(t0)(t0)(t1) // 'Q'
_R     : Char ascii(t0)(t1)(t0)(t1)(t0)(t0)(t1)(t0) // 'R'
_S     : Char ascii(t0)(t1)(t0)(t1)(t0)(t0)(t1)(t1) // 'S'
_T     : Char ascii(t0)(t1)(t0)(t1)(t0)(t1)(t0)(t0) // 'T'
_U     : Char ascii(t0)(t1)(t0)(t1)(t0)(t1)(t0)(t1) // 'U'
_V     : Char ascii(t0)(t1)(t0)(t1)(t0)(t1)(t1)(t0) // 'V'
_W     : Char ascii(t0)(t1)(t0)(t1)(t0)(t1)(t1)(t1) // 'W'
_X     : Char ascii(t0)(t1)(t0)(t1)(t1)(t0)(t0)(t0) // 'X'
_Y     : Char ascii(t0)(t1)(t0)(t1)(t1)(t0)(t0)(t1) // 'Y'
_Z     : Char ascii(t0)(t1)(t0)(t1)(t1)(t0)(t1)(t0) // 'Z'
_lbrack: Char ascii(t0)(t1)(t0)(t1)(t1)(t0)(t1)(t1) // '['
_bsol  : Char ascii(t0)(t1)(t0)(t1)(t1)(t1)(t0)(t0) // '\\'
_rbrack: Char ascii(t0)(t1)(t0)(t1)(t1)(t1)(t0)(t1) // ']'
_caret : Char ascii(t0)(t1)(t0)(t1)(t1)(t1)(t1)(t0) // '^'
_lowbar: Char ascii(t0)(t1)(t0)(t1)(t1)(t1)(t1)(t1) // '_'
_grave : Char ascii(t0)(t1)(t1)(t0)(t0)(t0)(t0)(t0) // '`'
_a     : Char ascii(t0)(t1)(t1)(t0)(t0)(t0)(t0)(t1) // 'a'
_b     : Char ascii(t0)(t1)(t1)(t0)(t0)(t0)(t1)(t0) // 'b'
_c     : Char ascii(t0)(t1)(t1)(t0)(t0)(t0)(t1)(t1) // 'c'
_d     : Char ascii(t0)(t1)(t1)(t0)(t0)(t1)(t0)(t0) // 'd'
_e     : Char ascii(t0)(t1)(t1)(t0)(t0)(t1)(t0)(t1) // 'e'
_f     : Char ascii(t0)(t1)(t1)(t0)(t0)(t1)(t1)(t0) // 'f'
_g     : Char ascii(t0)(t1)(t1)(t0)(t0)(t1)(t1)(t1) // 'g'
_h     : Char ascii(t0)(t1)(t1)(t0)(t1)(t0)(t0)(t0) // 'h'
_i     : Char ascii(t0)(t1)(t1)(t0)(t1)(t0)(t0)(t1) // 'i'
_j     : Char ascii(t0)(t1)(t1)(t0)(t1)(t0)(t1)(t0) // 'j'
_k     : Char ascii(t0)(t1)(t1)(t0)(t1)(t0)(t1)(t1) // 'k'
_l     : Char ascii(t0)(t1)(t1)(t0)(t1)(t1)(t0)(t0) // 'l'
_m     : Char ascii(t0)(t1)(t1)(t0)(t1)(t1)(t0)(t1) // 'm'
_n     : Char ascii(t0)(t1)(t1)(t0)(t1)(t1)(t1)(t0) // 'n'
_o     : Char ascii(t0)(t1)(t1)(t0)(t1)(t1)(t1)(t1) // 'o'
_p     : Char ascii(t0)(t1)(t1)(t1)(t0)(t0)(t0)(t0) // 'p'
_q     : Char ascii(t0)(t1)(t1)(t1)(t0)(t0)(t0)(t1) // 'q'
_r     : Char ascii(t0)(t1)(t1)(t1)(t0)(t0)(t1)(t0) // 'r'
_s     : Char ascii(t0)(t1)(t1)(t1)(t0)(t0)(t1)(t1) // 's'
_t     : Char ascii(t0)(t1)(t1)(t1)(t0)(t1)(t0)(t0) // 't'
_u     : Char ascii(t0)(t1)(t1)(t1)(t0)(t1)(t0)(t1) // 'u'
_v     : Char ascii(t0)(t1)(t1)(t1)(t0)(t1)(t1)(t0) // 'v'
_w     : Char ascii(t0)(t1)(t1)(t1)(t0)(t1)(t1)(t1) // 'w'
_x     : Char ascii(t0)(t1)(t1)(t1)(t1)(t0)(t0)(t0) // 'x'
_y     : Char ascii(t0)(t1)(t1)(t1)(t1)(t0)(t0)(t1) // 'y'
_z     : Char ascii(t0)(t1)(t1)(t1)(t1)(t0)(t1)(t0) // 'z'
_lbrace: Char ascii(t0)(t1)(t1)(t1)(t1)(t0)(t1)(t1) // '<'
_vert  : Char ascii(t0)(t1)(t1)(t1)(t1)(t1)(t0)(t0) // '|'
_rbrace: Char ascii(t0)(t1)(t1)(t1)(t1)(t1)(t0)(t1) // '>'
_tilde : Char ascii(t0)(t1)(t1)(t1)(t1)(t1)(t1)(t0) // '~'
_DEL   : Char ascii(t0)(t1)(t1)(t1)(t1)(t1)(t1)(t1) // \DEL

// String
// ======

String: Type
  List(Char)

string_eql: String -> String -> Bool
  (a) => (b) =>
  let eql_len = nat_eql(list_len<Char>(a))(list_len<Char>(b))
  let eql_val = all_satisfy<Bool>((x)=>x)(zip_with<Char><Char><Bool>(u32_eql)(a)(b))
  and(eql_len)(eql_val)

ext: Char -> String -> String
  (c) => (str) => cons<Char>(c)(str)

end: String
  nil<Char>

exts: String -> List(String) -> List(String)
  (s) => (strs) => cons<String>(s)(strs)

ends: List(String)
  nil<String>

str: Char -> String
  (c) => single<Char>(c)

strs: String -> List(String)
  (s) => single<String>(s)

cat: String -> String -> String
  concat<Char>

cat_list: List(String) -> String
  flatten<Char>

// Term
// ====

Term: Type
  self<P: Term -> Type> ->
  (var:
    (hash: U32) ->
    (indx: Nat) ->
    P(var(indx))) ->
  (ref:
    (hash: U32) ->
    (name: String) ->
    P(ref(name))) ->
  (typ:
    (hash: U32) ->
    P(typ)) ->
  (all:
    (hash: U32) ->
    (eras: Bool) ->
    (self: String) ->
    (name: String) ->
    (bind: Term) ->
    (body: Term) ->
    P(all(eras)(self)(name)(bind)(body))) ->
  (lam:
    (hash: U32) ->
    (eras: Bool) ->
    (name: String) ->
    (body: Term) ->
    P(lam(eras)(name)(body))) ->
  (app:
    (hash: U32) ->
    (eras: Bool) ->
    (func: Term) ->
    (argm: Term) ->
    P(app(eras)(func)(argm))) ->
  (lit:
    (hash: U32) ->
    (name: String) ->
    (expr: Term) ->
    (body: Term) ->
    P(lit(name)(expr)(body))) ->
  (ann:
    (hash: U32) ->
    (done: Bool) ->
    (expr: Term) ->
    (type: Term) ->
    P(ann(done)(expr)(type))) ->
  P(self)

var: Nat -> Term
  (indx)=>
  <> => (var) => () => () => () => () => () => () => () =>
  var(u32_0)(indx)

ref: String -> Term
  (name)=>
  <> => () => (ref) => () => () => () => () => () => () =>
  ref(u32_0)(name)

typ: Term
  <> => () => () => (typ) => () => () => () => () => () =>
  typ(u32_0)

all: Bool -> String -> String -> Term -> Term -> Term
  (eras) => (self) => (name) => (bind) => (body) =>
  <> => () => () => () => (all) => () => () => () => () =>
  all(u32_0)(eras)(self)(name)(bind)(body)

lam: Bool -> String -> Term -> Term
  (eras) => (name) => (body) =>
  <> => () => () => () => () => (lam) => () => () => () =>
  lam(u32_0)(eras)(name)(body)

app: Bool -> Term -> Term -> Term
  (eras) => (func) => (argm) =>
  <> => () => () => () => () => () => (app) => () => () =>
  app(u32_0)(eras)(func)(argm)

lit: String -> Term -> Term -> Term
  (name) => (expr) => (body) =>
  <> => () => () => () => () => () => () => (lit) => () =>
  lit(u32_0)(name)(expr)(body)

ann: Bool -> Term -> Term -> Term
  (done) => (expr) => (type) =>
  <> => () => () => () => () => () => () => () => (ann) =>
  ann(u32_0)(done)(expr)(type)

// Parsing
// =======

Parsed : (A: Type) -> Type
  (A) => Maybe(Pair(String)(A))

parsed: <A: Type> -> String -> A -> Parsed(A)
  <A> => (code) => (val) =>
  some<Pair(String)(A)>(pair<String><A>(code)(val))

noparse: <A: Type> -> Parsed(A)
  <A> => none<Pair(String)(A)>

parsing
  : <A: Type> ->
    <B: Type> ->
    (x: Parsed(A)) ->
    (f: String -> A -> Parsed(B)) ->
    Parsed(B)
  <A> => <B> => (x) => (f) =>
  let _none = noparse<B>
  let _some = (value) => value<() => Parsed(B)>(f)
  x<() => Parsed(B)>(_none)(_some)

LPAR: String                                        // "("
  str(_lpar)
RPAR: String                                        // ")"
  str(_rpar  )
LSIG: String                                        // "<"
  str(_lbrace)
RSIG: String                                        // ">"
  str(_rbrace)
COLO: String                                        // ":"
  str(_colon )
COLS: String                                        // "::"
  ext(_colon)(str(_colon))
ARR0: String                                        // "->"
  ext(_dash)(str(_gt))
ARR1: String                                        // "=>"
  ext(_equals)(str(_gt))
EQLS: String                                        // "="
  str(_equals)
OPEN: List(String)                                  // ["(","<"]
  exts(LPAR)(strs(LSIG))
CLOS: List(String)                                  // [")",">"]
  exts(LPAR)(strs(LSIG))
TYPS: String                                        // Type
  ext(_T)(ext(_y)(ext(_p)(single<Char>(_e))))
LETS: String                                        // "let "
  ext(_l)(ext(_e)(ext(_t)(single<Char>(_space))))
SPAC : String                                       // " "
  str(_space)

is_space: Char -> Bool
  (c) =>
    let is_spc = word_eql<n32>(c)(_space)
    let is_tab = word_eql<n32>(c)(_HT)
    let is_lin = word_eql<n32>(c)(_LF)
    or(is_spc)(or(is_tab)(is_lin))

is_name: Char -> Bool
  (c) =>
    let is_num = and(word_gte<n32>(c)(_0))(word_lte<n32>(c)(_9))
    let is_low = and(word_gte<n32>(c)(_a))(word_lte<n32>(c)(_z))
    let is_upp = and(word_gte<n32>(c)(_A))(word_lte<n32>(c)(_Z))
    let is_und = word_eql<n32>(c)(_lowbar)
    or(is_num)(or(is_low)(or(is_upp)(is_und)))

first_valid: <A: Type> -> List(Maybe(A)) -> Maybe(A)
  <A> => (list) =>
  let _nil = none<A>
  let _cons = (head) => (tail) =>
    let _none = first_valid<A>(tail)
    let _some = (value) => some<A>(value)
    head<() => Maybe(A)>(_none)(_some)
  list<() => Maybe(A)>(_nil)(_cons)

drop_while: (Char -> Bool) -> String -> String
  (cond) => (code) =>
  let _nil = nil<Char>
  let _cons = (head) => (tail) =>
    let _t = drop_while(cond)(tail)
    let _f = tail
    cond(head)<() => String>(_t)(_f)
  code<() => String>(_nil)(_cons)

drop_spaces: String -> String
  drop_while(is_space)

// TODO: /* multi-line comment */
drop_comment: String -> String
  (code) =>
  let code = drop_spaces(code)
  // Removes "// ... \n"
  let code = 
    let fst2 = take<Char>(n2)(code)
    let sla2 = ext(_sol)(ext(_sol)(end))
    let _t =
      let code = drop<Char>(n2)(code)
      let code = drop_while((x) => not(u32_eql(_LF)(x)))(code)
      code
    let _f =
      code
    string_eql(fst2)(sla2)<() => String>(_t)(_f)
  code

// TODO: remove many comments (not just one)
next: String -> String
  (code) => drop_comment(code)

parse_str: String -> String -> Parsed(String)
  (code) => (str) =>
  let _str_nil = parsed<String>(code)(str)
  let _str_cons = (str_head) => (str_tail) =>
    let _code_nil = noparse<String>
    let _code_cons = (code_head) => (code_tail) =>
      let _t = parse_str(code_tail)(str_tail)
      let _f = noparse<String>
      u32_eql(code_head)(str_head)<() => Parsed(String)>(_t)(_f)
    code<() => Parsed(String)>(_code_nil)(_code_cons)
  str<() => Parsed(String)>(_str_nil)(_str_cons)

parse_one_aux: String -> List(String) -> Nat -> Maybe(Pair(String)(Nat))
  (code) => (strs) => (indx) =>
  let _nil = noparse<Nat>
  let _cons = (head) => (tail) =>
    let _none = parse_one_aux(code)(tail)(succ(indx))
    let _some = (value) => value<() => Parsed(Nat)>((code)=>() => parsed<Nat>(code)(indx))
    parse_str(code)(head)<() => Maybe(Pair(String)(Nat))>(_none)(_some)
  strs<() => Parsed(Nat)>(_nil)(_cons)

parse_one: String -> List(String) -> Maybe(Pair(String)(Nat))
  (code) => (strs) =>
  parse_one_aux(code)(strs)(zero)

parse_nam_aux: String -> Pair(String)(String)
  (code) =>
  let Ret = Pair(String)(String)
  let ret = pair<String><String>
  let _nil = ret(code)(end)
  let _cons = (head) => (tail) =>
    let _t =
      let _pair = (code) => (rest) => ret(code)(ext(head)(rest))
      parse_nam_aux(tail)<() => Ret>(_pair)
    let _f = ret(code)(end)
    is_name(head)<() => Ret>(_t)(_f)
  code<() => Ret>(_nil)(_cons)

parse_nam: String -> Bool -> Maybe(Pair(String)(String))
  (code) => (allow_empty) =>
  let _pair = (code) => (name) =>
    let _t = parsed<String>(code)(name)
    let _f = noparse<String>
    let valid = or(allow_empty)(not(is_empty<Char>(name)))
    valid<() => Parsed(String)>(_t)(_f)
  parse_nam_aux(code)<() => Parsed(String)>(_pair)

// Stringify
// =========

nest : Bool -> String -> String
  (b) => (s) =>
  let _true  = cat(LSIG)(cat(s)(RSIG))
  let _false = cat(LPAR)(cat(s)(RPAR))
  b<() => String>(_true)(_false)

sp : String -> String
  (s) => cat_list(exts(SPAC)(exts(s)(strs(SPAC))))

ERR : String
  ext(_hash)(ext(_E)(ext(_R)(str(_R))))

stringify_trm_go : List(String) -> Term -> String
  (vs) => (term) =>
  let go   = stringify_trm_go
  let _var = () => (indx) =>
    let res = find<String>(vs)(() => (i) => nat_eql(indx)(i))
    res<() => String>(ERR)((x) => fst<String><Nat>(x))
  let _ref = () => (nam) => nam
  let _typ = () => TYPS
  let _all = () => (e) => (s) => (n) => (h) => (b) =>
    let body = go(exts(n)(vs))(b)
    let head = nest(e)(cat_list(exts(n)(exts(sp(COLO))(strs(go(vs)(h))))))
    cat_list(exts(s)(exts(head)(exts(sp(ARR0))(strs(body)))))
  let _lam = () => (e) => (n) => (b) =>
    let head = nest(e)(n)
    let body = go(exts(n)(vs))(b)
    cat_list(exts(head)(exts(sp(ARR1))(strs(body))))
  let _app = () => (e) => (f) => (a) =>
    let func = nest(false)(go(vs)(f))
    let argm = nest(e)(go(vs)(a))
    cat_list(exts(func)(strs(argm)))
  let _let = () => (n) => (x) => (b) =>
    cat_list(exts(LETS)(exts(n)(exts(sp(EQLS))(strs(go(exts(n)(vs))(b))))))
  let _ann = () => () => (x) => (t) =>
    cat_list(exts(go(vs)(x))(exts(sp(COLS))(strs(go(vs)(t)))))
  term<() => String>(_var)(_ref)(_typ)(_all)(_lam)(_app)(_let)(_ann)

stringify_trm : Term -> String
  (t) => stringify_trm_go(nil<String>)(t)

parse_par: String -> List(String) -> Parsed(Term)
  (code) => (vars) =>
  parsing<String><Term>(parse_str(next(code))(LPAR))((code) => (skip) =>
  parsing<Term  ><Term>(parse_trm(next(code))(vars))((code) => (term) =>
  parsing<String><Term>(parse_str(next(code))(RPAR))((code) => (skip) =>
  parsed<Term>(code)(term))))

parse_all: String -> List(String) -> Parsed(Term)
  (code) => (vars) =>
  parsing<String><Term>(parse_nam(next(code))(true))((code) => (self) =>
  parsing<Nat   ><Term>(parse_one(     code )(OPEN))((code) => (eras) =>
  parsing<String><Term>(parse_nam(next(code))(true))((code) => (name) =>
  parsing<String><Term>(parse_str(next(code))(COLO))((code) => (skip) =>
  parsing<Term  ><Term>(parse_trm(next(code))(cons<String>(self)(vars)))((code) => (bind) =>
  parsing<Nat   ><Term>(parse_one(next(code))(CLOS))((code) => (skip) =>
  parsing<String><Term>(parse_str(next(code))(ARR0))((code) => (skip) =>
  parsing<Term  ><Term>(parse_trm(next(code))(cons<String>(name)(cons<String>(self)(vars))))((code) => (body) =>
  parsed<Term>(code)(all(nat_eql(eras)(n1))(self)(name)(bind)(body))))))))))

parse_lam: String -> List(String) -> Parsed(Term)
  (code) => (vars) =>
  parsing<Nat   ><Term>(parse_one(next(code))(OPEN))((code) => (eras) =>
  parsing<String><Term>(parse_nam(next(code))(true))((code) => (name) =>
  parsing<Nat   ><Term>(parse_one(next(code))(CLOS))((code) => (skip) =>
  parsing<String><Term>(parse_str(next(code))(ARR1))((code) => (skip) =>
  parsing<Term  ><Term>(parse_trm(next(code))(cons<String>(name)(vars)))((code) => (body) =>
  parsed<Term>(code)(lam(nat_eql(eras)(n1))(name)(body)))))))

parse_let: String -> List(String) -> Parsed(Term)
  (code) => (vars) =>
  parsing<String><Term>(parse_str(next(code))(LETS))((code) => (skip) =>
  parsing<String><Term>(parse_nam(next(code))(false))((code) => (name) =>
  parsing<String><Term>(parse_str(next(code))(EQLS))((code) => (skip) =>
  parsing<Term  ><Term>(parse_trm(next(code))(vars))((code) => (expr) =>
  parsing<Term  ><Term>(parse_trm(next(code))(cons<String>(name)(vars)))((code) => (body) =>
  parsed<Term>(code)(lit(name)(expr)(body)))))))

parse_typ: String -> List(String) -> Parsed(Term)
  (code) => (vars) =>
  parsing<String><Term>(parse_str(next(code))(TYPS))((code) => (skip) =>
  parsed<Term>(code)(typ))

parse_var: String -> List(String) -> Parsed(Term)
  (code) => (vars) =>
  parsing<String><Term>(parse_nam(next(code))(false))((code) => (name) =>
  let got = find<String>(vars)((x) => (i) => string_eql(x)(name))
  let _none = parsed<Term>(code)(ref(name))
  let _some = (value) => parsed<Term>(code)(var(snd<String><Nat>(value)))
  got<() => Parsed(Term)>(_none)(_some))

parse_app: String -> Term -> List(String) -> Parsed(Term)
  (code) => (func) => (vars) =>
  parsing<Nat ><Term>(parse_one(next(code))(OPEN))((code) => (eras) =>
  parsing<Term><Term>(parse_trm(next(code))(vars))((code) => (argm) =>
  parsing<Nat ><Term>(parse_one(next(code))(CLOS))((code) => (skip) =>
  parsed<Term>(code)(app(nat_eql(eras)(n1))(func)(argm)))))

parse_arr: String -> Term -> List(String) -> Parsed(Term)
  (code) => (bind) => (vars) =>
  parsing<String><Term>(parse_str(next(code))(ARR0))((code) => (skip) =>
  parsing<Term  ><Term>(parse_trm(next(code))(cons<String>(nil<Char>)(cons<String>(nil<Char>)(vars))))((code) => (body) =>
  parsed<Term>(code)(all(false)(nil<Char>)(nil<Char>)(shift(bind)(n1)(n0))(body))))

parse_ann: String -> Term -> List(String) -> Parsed(Term)
  (code) => (expr) => (vars) =>
  parsing<String><Term>(parse_str(next(code))(COLS))((code) => (skip) =>
  parsing<Term  ><Term>(parse_trm(next(code))(vars))((code) => (type) =>
  parsed<Term>(code)(ann(false)(expr)(type))))

parse_pst: String -> Term -> List(String) -> Parsed(Term)
  (code) => (term) => (vars) =>
  let post_parse = first_valid<Pair(String)(Term)>(
    cons<Parsed(Term)>(parse_app(code)(term)(vars))(
    cons<Parsed(Term)>(parse_arr(code)(term)(vars))(
    cons<Parsed(Term)>(parse_ann(code)(term)(vars))(
    nil<Parsed(Term)>))))
  let _none = parsed<Term>(code)(term)
  let _some = (value) =>
    let _pair = (code) => (term) => parse_pst(code)(term)(vars)
    value<() => Parsed(Term)>(_pair)
  post_parse<() => Parsed(Term)>(_none)(_some)

parse_trm: String -> List(String) -> Parsed(Term)
  (code) => (vars) =>
  let base_parse = first_valid<Pair(String)(Term)>(
    cons<Parsed(Term)>(parse_all(code)(vars))(
    cons<Parsed(Term)>(parse_lam(code)(vars))(
    cons<Parsed(Term)>(parse_let(code)(vars))(
    cons<Parsed(Term)>(parse_par(code)(vars))(
    cons<Parsed(Term)>(parse_typ(code)(vars))(
    cons<Parsed(Term)>(parse_var(code)(vars))(
    nil<Parsed(Term)>)))))))
  parsing<Term><Term>(base_parse)((code) => (term) =>
    parse_pst(code)(term)(vars))

// Substitution
// ============

shift: Term -> Nat -> Nat -> Term
  (term) => (inc) => (dep) =>
  let _var = (hash) => (indx) =>
    let _t = var(indx)
    let _f = var(add(inc)(indx))
    nat_ltn(indx)(dep)<() => Term>(_t)(_f)
  let _ref = (hash) => (name) =>
    ref(name)
  let _typ = (hash) =>
    typ
  let _all = (hash) => (eras) => (self) => (name) => (bind) => (body) =>
    let eras = eras
    let self = self
    let name = name
    let bind = shift(bind)(inc)(succ(dep))
    let body = shift(body)(inc)(succ(succ(dep)))
    all(eras)(self)(name)(bind)(body)
  let _lam = (hash) => (eras) => (name) => (body) =>
    let eras = eras
    let name = name
    let body = shift(body)(inc)(succ(dep))
    lam(eras)(name)(body)
  let _app = (hash) => (eras) => (func) => (argm) =>
    let eras = eras
    let func = shift(func)(inc)(dep)
    let argm = shift(argm)(inc)(dep)
    app(eras)(func)(argm)
  let _lit = (hash) => (name) => (expr) => (body) =>
    let name = name
    let expr = shift(expr)(inc)(dep)
    let body = shift(expr)(inc)(succ(dep))
    lit(name)(expr)(body)
  let _ann = (hash) => (done) => (expr) => (type) =>
    let done = done
    let expr = shift(expr)(inc)(dep)
    let type = shift(expr)(inc)(dep)
    ann(done)(expr)(type)
  term<()=>Term>(_var)(_ref)(_typ)(_all)(_lam)(_app)(_lit)(_ann)

subst: Term -> Term -> Nat -> Term
  (term) => (val) => (dep) =>
  let _var = (hash) => (indx) =>
    let _ltn = var(indx)
    let _eql = val
    let _gtn = var(pred(indx))
    nat_cmp(indx)(dep)<() => Term>(_ltn)(_eql)(_gtn)
  let _ref = (hash) => (name) =>
    ref(name)
  let _typ = (hash) =>
    typ
  let _all = (hash) => (eras) => (self) => (name) => (bind) => (body) =>
    let eras = eras
    let self = self
    let name = name
    let bind = subst(bind)(shift(val)(n1)(n0))(succ(dep))
    let body = subst(body)(shift(val)(n2)(n0))(succ(succ(dep)))
    all(eras)(self)(name)(bind)(body)
  let _lam = (hash) => (eras) => (name) => (body) =>
    let eras = eras
    let name = name
    let body = subst(body)(shift(val)(n1)(n0))(succ(dep))
    lam(eras)(name)(body)
  let _app = (hash) => (eras) => (func) => (argm) =>
    let eras = eras
    let func = subst(func)(val)(dep)
    let argm = subst(argm)(val)(dep)
    app(eras)(func)(argm)
  let _lit = (hash) => (name) => (expr) => (body) =>
    let name = name
    let expr = subst(expr)(val)(dep)
    let body = subst(expr)(shift(val)(n1)(n0))(succ(dep))
    lit(name)(expr)(body)
  let _ann = (hash) => (done) => (expr) => (type) =>
    let done = done
    let expr = subst(expr)(val)(dep)
    let type = subst(expr)(val)(dep)
    ann(done)(expr)(type)
  term<()=>Term>(_var)(_ref)(_typ)(_all)(_lam)(_app)(_lit)(_ann)

// Evaluation
// ==========

HTerm: Type
  self<P: HTerm -> Type> ->
  (hvar:
    (indx: Nat) ->
    (posi: Bool) ->
    P(hvar(indx)(posi))) ->
  (href:
    (name: String) ->
    P(href(name))) ->
  (htyp:
    P(htyp)) ->
  (hall:
    (eras: Bool) ->
    (bind: HTerm -> HTerm) ->
    (body: HTerm -> HTerm -> HTerm) ->
    P(hall(eras)(bind)(body))) ->
  (hlam:
    (body: HTerm -> HTerm) ->
    P(hlam(body))) ->
  (happ:
    (func: HTerm) ->
    (argm: HTerm) ->
    P(happ(func)(argm))) ->
  (hlit:
    (expr: HTerm) ->
    (body: HTerm -> HTerm) ->
    P(hlit(expr)(body))) ->
  P(self)

hvar: Nat -> Bool -> HTerm
  (indx) => (posi) =>
  <> => (hvar) => () => () => () => () => () => () =>
  hvar(indx)(posi)

href: String -> HTerm
  (name) =>
  <> => () => (href) => () => () => () => () => () =>
  href(name)

htyp: HTerm
  <> => () => () => (htyp) => () => () => () => () =>
  htyp

hall: Bool -> (HTerm -> HTerm) -> (HTerm -> HTerm -> HTerm) -> HTerm
  (eras) => (bind) => (body) =>
  <> => () => () => () => (hall) => () => () => () =>
  hall(eras)(bind)(body)

hlam: (HTerm -> HTerm) -> HTerm
  (body) =>
  <> => () => () => () => () => (hlam) => () => () =>
  hlam(body)

happ: HTerm -> HTerm -> HTerm
  (func) => (argm) =>
  <> => () => () => () => () => () => (happ) => () =>
  happ(func)(argm)

hlit: HTerm -> (HTerm -> HTerm) -> HTerm
  (expr) => (body) =>
  <> => () => () => () => () => () => () => (hlit) =>
  hlit(expr)(body)

to_high_order: Term -> List(HTerm) -> Nat -> HTerm
  (term) => (vars) => (depth) =>
  let _var = (hash) => (indx) =>
    let got = find<HTerm>(vars)((x) => (i) => nat_eql(i)(indx))
    let _none = hvar(sub(succ(indx))(depth))(false)
    let _some = (value) => fst<HTerm><Nat>(value)
    got<() => HTerm>(_none)(_some)
  let _ref = (hash) => (name) =>
    href(name)
  let _typ = (hash) =>
    htyp
  let _all = (hash) => (eras) => (self) => (name) => (bind) => (body) =>
    let eras = eras
    let bind = (s) => to_high_order(bind)(cons<HTerm>(s)(vars))(succ(depth))
    let body = (s) => (x) => to_high_order(body)(cons<HTerm>(x)(cons<HTerm>(s)(vars)))(succ(succ(depth)))
    hall(eras)(bind)(body)
  let _lam = (hash) => (eras) => (name) => (body) =>
    let _t =
      let body = subst(body)(ref(nil<Char>))(n0)
      to_high_order(body)(vars)(depth)
    let _f =
      let body = (x) => to_high_order(body)(cons<HTerm>(x)(vars))(succ(depth))
      hlam(body)
    eras<() => HTerm>(_t)(_f)
  let _app = (hash) => (eras) => (func) => (argm) =>
    let _t =
      to_high_order(func)(vars)(depth)
    let _f =
      let func = to_high_order(func)(vars)(depth)
      let argm = to_high_order(argm)(vars)(depth)
      happ(func)(argm)
    eras<() => HTerm>(_t)(_f)
  let _lit = (hash) => (name) => (expr) => (body) =>
    let expr = to_high_order(expr)(vars)(depth)
    let body = (x) => to_high_order(body)(cons<HTerm>(x)(vars))(succ(depth))
    hlit(expr)(body)
  let _ann = (hash) => (done) => (expr) => (type) =>
    to_high_order(expr)(vars)(depth)
  term<() => HTerm>(_var)(_ref)(_typ)(_all)(_lam)(_app)(_lit)(_ann)

to_low_order: HTerm -> Nat -> Term
  (hterm) => (depth) =>
  let _hvar = (indx) => (posi) =>
    let _t = var(sub(sub(depth)(indx))(n1))
    let _f = var(sub(add(depth)(indx))(n1))
    posi<() => Term>(_t)(_f)
  let _href = (name) =>
    ref(name)
  let _htyp =
    typ
  let _hall = (eras) => (bind) => (body) =>
    let eras = eras
    let self = nil<Char> // TODO
    let name = nil<Char> // TODO
    let bind = to_low_order(bind(hvar(depth)(true)))(succ(depth))
    let body = to_low_order(body(hvar(depth)(true))(hvar(succ(depth))(true)))(succ(succ(depth)))
    all(eras)(self)(name)(bind)(body)
  let _hlam = (body) =>
    let eras = false
    let name = nil<Char> // TODO
    let body = to_low_order(body(hvar(depth)(true)))(succ(depth))
    lam(eras)(name)(body)
  let _happ = (func) => (argm) =>
    let eras = false
    let func = to_low_order(func)(depth)
    let argm = to_low_order(argm)(depth)
    app(eras)(func)(argm)
  let _hlit = (expr) => (body) =>
    let name = nil<Char> // TODO
    let expr = to_low_order(expr)(depth)
    let body = to_low_order(body(hvar(depth)(true)))(succ(depth))
    lit(name)(expr)(body)
  hterm<() => Term>(_hvar)(_href)(_htyp)(_hall)(_hlam)(_happ)(_hlit)

// Main
// ====

example_0: Word(n4)
  let w0011 = w1<n3>(w1<n2>(w0<n1>(w0<n0>(we))))
  let w0101 = w1<n3>(w0<n2>(w1<n1>(w0<n0>(we))))
  word_add<n4>(w0011)(w0101) // 3 + 5 == 8

main: Bool
  true
