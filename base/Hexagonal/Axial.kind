//TODO : Separate functions to its specific files
//TODO : Add ALIAS to Hexagonal.Axial.from_screen_xy and Hexagonal.Axial.from_screen_xy
//TODO : Rheidner to fix some of the Round Functions (Past line 277)

//Type for Axial coordinates in an Hexagon
type Hexagonal.Axial { 
  new(i: I32, j: I32)
} deriving (serializer, deserializer, stringifier)

// GENERAL FUNCTIONS
//===============================================

// Returns the distance between 2 Coords
Hexagonal.Axial.distance(
  fst_coord: Hexagonal.Axial,
  snd_coord: Hexagonal.Axial
): I32

  convert_fst = Hexagonal.Axial.to_cubic(fst_coord)
  convert_snd = Hexagonal.Axial.to_cubic(snd_coord)
  Hexagonal.Cubic.distance(convert_fst, convert_snd)


// Returns a list of coordinates in-line from a start to a goal
Hexagonal.Axial.line(
  start: Hexagonal.Axial,
  goal: Hexagonal.Axial
): List<Hexagonal.Axial>

  open start
  open goal

  {si, sj} =  {I32.to_f64(start.i), I32.to_f64(start.j)}
  {gi, gj} = {I32.to_f64(goal.i), I32.to_f64(goal.j)}
  
  coords = []
  distance = I32.to_nat(Hexagonal.Axial.distance(start, goal))
  for i from 0 to distance with coords:
    i = F64.from_nat(i + 1)
    distance = F64.from_nat(distance)
    ratio = i/distance
    inter_x = F64.lerp(si, gi, ratio)
    inter_y = F64.lerp(sj, gj, ratio)
    {new_i, new_j} = App.Kaelin.Coord.round(inter_x, inter_y)
    Hexagonal.Axial.new(new_i, new_j) & coords
  coords

// Returns a list of coordinates within a given range inside an hexagonal region
Hexagonal.Axial.range(
  coord: Hexagonal.Axial
  region: I32
  distance: I32
): List<Hexagonal.Axial>
  center = Hexagonal.Axial.to_cubic(coord)
  list_coords = List.map!!(Hexagonal.Cubic.to_axial, Hexagonal.Cubic.range(center, distance))
  fit = (x)
  Hexagonal.Axial.inside(x, region)
  List.filter!(fit, list_coords)


// Returns an Axial coordinate as a String
Hexagonal.Axial.show(
  coord: Hexagonal.Axial
): String

  Stringifier.run!(Hexagonal.Axial.stringifier, coord)


// PATHING FUNCTIONS
//===============================================
Hexagonal.Axial.path(
  coord: Hexagonal.Axial,
  goal: Hexagonal.Axial
): Maybe<List<Hexagonal.Axial>>

  path_min = Hexagonal.Axial.minimum(coord, goal)
  case path_min {
    none: 
      none
    some: 
      if (Hexagonal.Axial.eql(path_min.value, goal)) then
        some([path_min.value])
      else
        ls = Hexagonal.Axial.path(path_min.value, goal)
        Maybe.extract!(ls, Maybe<List<Hexagonal.Axial>>, none, (a) some(path_min.value & a))
  }


// Returns the minor path between 2 coords
Hexagonal.Axial.minimum(
  origin: Hexagonal.Axial,
  goal: Hexagonal.Axial
): Maybe(Hexagonal.Axial)

  neighborhood = Hexagonal.Axial.moore(origin)
sort = ((x, y) 
  case y {
    none: 
      some(x)
    some: 
     shorter = Hexagonal.Axial.shorter(goal, x, y.value)
      if shorter then
        some(x)
      else 
        y
    }) :: Hexagonal.Axial -> Maybe(Hexagonal.Axial) -> Maybe(Hexagonal.Axial)
  List.foldr!!(none, sort, neighborhood)


// Returns the list of coordinates available in a range
Hexagonal.Axial.moore(
  coord: Hexagonal.Axial
): List<Hexagonal.Axial>

  open coord
  U32_i = ((i) Int.to_i32(Int.sub(Int.from_nat(U32.to_nat(i)), +1))) :: U32 -> I32
  result = []
  for x : U32 from 0 to 3 with result:
    for y : U32 from 0 to 3 with result:
       if (U32.eql(x, y)) then 
        result 
      else 
        Hexagonal.Axial.new(coord.i + U32_i(x), coord.j + U32_i(y)) & result // U32
    result
  result

// COMPARISONS
//===============================================

// Verifies if two points A and B are the same
Hexagonal.Axial.eql(
  a: Hexagonal.Axial,
  b: Hexagonal.Axial
): Bool

  open a
  open b
  Bool.and(I32.eql(a.i,b.i), I32.eql(a.j, b.j))

// Compares two coordinates
Hexagonal.Axial.cmp(
  a: Hexagonal.Axial,
  b: Hexagonal.Axial
): Cmp
  let c = I32.cmp(a@i, b@i)
  case c {
    eql: I32.cmp(a@j, b@j)
  } default c

// Verifies if a coordinate is inside an hexagonal region
Hexagonal.Axial.inside(
  coord: Hexagonal.Axial,
  region_size: I32
): Bool
  coord = Hexagonal.Axial.to_cubic(coord)
  open coord

  x = I32.abs(coord.x)
  y = I32.abs(coord.y)
  z = I32.abs(coord.z)
  greater = I32.max(x, I32.max(y, z))
  I32.lte(greater, region_size)

//Verifies if its the shorter path between 2 coords
Hexagonal.Axial.shorter(
  goal: Hexagonal.Axial
  a: Hexagonal.Axial,
  b: Hexagonal.Axial
): Bool

  open goal
  open a
  open b
    a_dis0 = a.i - goal.i // I32
    a_dis1 = a.j - goal.j // I32
    b_dis0 = b.i - goal.i // I32
    b_dis1 = b.j - goal.j // I32
    ab_dis0_comp = I32.ltn(I32.abs(a_dis0), I32.abs(b_dis0))
    ab_dis0_min = I32.eql(I32.abs(a_dis0), I32.abs(b_dis0))
    ab_dis1_comp = I32.ltn(I32.abs(a_dis1), I32.abs(b_dis1))
    diff = ab_dis0_min && ab_dis1_comp
    Bool.or(ab_dis0_comp, diff)

// CONVERSIONS
//===============================================

// Converts Axial coordinates to Cubic coordinates
Hexagonal.Axial.to_cubic(
  coord: Hexagonal.Axial
): Hexagonal.Cubic
    open coord
    x = coord.i
    z = coord.j
    y = (I32.neg(x) - z)

    Hexagonal.Cubic.new(x, y, z)

// Converts a natural number to an axial coordinate, so it can be used as a key in a NatMap, for example
// 10020997 is transformed to the coordinate {+2, -3}
// TODO maybe add I32 to nat?
Hexagonal.Axial.from_nat(n: Nat): Hexagonal.Axial
  n_converted = Nat.to_u32(n)
  coord_i = n_converted /  1000  //U32
  coord_i = U32.to_i32(coord_i)
  coord_i = coord_i - 100   // I32
  coord_j = U32.mod(n_converted, 1000) // U32
  coord_j = U32.to_i32(coord_j)
  coord_j = coord_j - 100 // I32
  Hexagonal.Axial.new(coord_i, coord_j)


// Converts an Axial Coordinate to a Natural Number
Hexagonal.Axial.to_nat(
  coord: Hexagonal.Axial
): Nat

  open coord
  i = coord.i + 100 //  I32
  i = i * 1000
  i = I32.to_u32(i)
  j = coord.j + 100
  j = I32.to_u32(j)
  sum = i + j   //U32
  U32.to_nat(sum)


// Converts Axial coordinates to Canvas coordinate
Hexagonal.Axial.to_screen_xy(
  coord: Hexagonal.Axial,
  radius: I32,
  center_x: I32,
  center_y: I32
): Pair<U32,U32> // TODO add alias

  open coord
  i   = coord.i
  j   = coord.j
  
  i = I32.to_f64(i)
  j = I32.to_f64(j)
  int_rad = I32.to_f64(radius)
  hlf = F64.div(int_rad, 2.0#64)
  int_screen_center_x = I32.to_f64(center_x)
  int_screen_center_y = I32.to_f64(center_y)
  
  cx = int_screen_center_x + j * int_rad  // screen_center + j * rad
  cx = cx + i * int_rad * 2 // screen_center + j * rad + i * 2rad
  cy = int_screen_center_y + j * hlf * 3 // screen_center + j * (3rad/2)
  
  cx = F64.to_u32(cx)
  y = cy + 0.5 // to round correctly
  cy = F64.to_u32(cy)
  {cx, cy}

// Converts screen coordinates to hexagon Axial coordinates
Hexagonal.Axial.from_screen_xy(
  coord: Pair<U32, U32> // TODO add alias
  radius: I32,
  center_x: I32,
  center_y: I32
): Hexagonal.Axial

  {x, y} = coord

  f = I32.to_f64
  i = U32.to_f64
  float_hex_rad = F64.div(f(radius), 2)

  float_x = F64.div(F64.sub(i(x), f(center_x)), float_hex_rad)
  float_y = F64.div(F64.sub(i(y), f(center_y)), float_hex_rad)
  

  fourth = 0.25
  sixth = F64.div(1, 6)
  third = F64.div(1, 3)
  half = 0.5

  axial_x = F64.sub( F64.mul(float_x, fourth), F64.mul(float_y, sixth) )
  axial_y = F64.mul(float_y, third)
  Hexagonal.Axial.round(axial_x, axial_y)

// Converts Axial coordinates to Bits
Hexagonal.Axial.to_bits(
  coord : Hexagonal.Axial
): Bits

  unique_nat = Hexagonal.Axial.to_nat(coord)
  Nat.to_bits(unique_nat)





// TODO Rheidner -- ROUND
// Round Functions (Send some to F64?) (F64.Floor)

// ROUND
//===============================================

// Round an Axial coordinate
Hexagonal.Axial.round(
  axial_x: F64,
  axial_y: F64
): Hexagonal.Axial
  i = F64.to_i32
  axial_z = (0.0 - axial_x) - axial_y

  round_x = Hexagonal.Axial.aux.round_F64(axial_x)
  round_y = Hexagonal.Axial.aux.round_F64(axial_y)
  round_z = Hexagonal.Axial.aux.round_F64(axial_z)

  diff_x  = Hexagonal.Axial.aux.abs_diff(axial_x, round_x)
  diff_y  = Hexagonal.Axial.aux.abs_diff(axial_y, round_y)
  diff_z  = Hexagonal.Axial.aux.abs_diff(axial_z, round_z)
  
  case F64.gtn(diff_x, diff_z) {
    true:
      case F64.gtn(diff_y, diff_x) {
        true: 
          new_y = (0.0 - round_x) - round_z
          Hexagonal.Axial.new(i(round_x), i(new_y))
        false:
          new_x = (0.0 - round_y) - round_z
          Hexagonal.Axial.new(i(new_x), i(round_y))
      }
    false:
      case F64.gtn(diff_y, diff_z) {
        true:
          new_y = (0.0 - round_x) - round_z
          Hexagonal.Axial.new(i(round_x), i(new_y))
        false:
          Hexagonal.Axial.new(i(round_x), i(round_y))
      }
  }




// TODO: Rheidner
// Rounds a F64 number to the nearest integer
Hexagonal.Axial.aux.round_F64(n: F64): F64
  half = 0.5
  big_number = 1000.0 // TODO while F64.gtn, cmp and ltn is broken
  n = n + big_number
  result = Hexagonal.Axial.aux.floor(n + half)
  result - big_number

// TODO
Hexagonal.Axial.aux.floor(n: F64): F64
  I32.to_f64(F64.to_i32(n))

// TODO: Rheidner
// Rounds a F64 and get its absolute value
Hexagonal.Axial.aux.abs_diff(x: F64, y: F64): F64 // TODO while F64.abs doesnt exist
  case F64.gtn(x, y) {
    true: x - y
    false: y - x
  }

