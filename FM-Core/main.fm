// ::::::::::
// :: Bool ::
// ::::::::::

// Bool datatype. Desugars to self-encoded datatypes.
// def Bool  : Type = $ self {~P : {b : Bool} -> Type, T : (P true), F : (P false)} -> (P self)
// def true  : Bool = new Bool {~P, T, F} => T
// def false : Bool = new Bool {~P, T, F} => F
T Bool
| true
| false 

// Simple not
not : {|b : Bool} -> Bool
| true  = false
| false = true

// Simple and
and : {|b0 : Bool, |b1 : Bool} -> Bool
| true  | true  = true
        | false = false
| false | true  = false
        | false = false

// Simple or
or : {|b0 : Bool, |b1 : Bool} -> Bool
| true  | true  = true
        | false = true
| false | true  = true
        | false = false

// Not with runtime fusion
not_f : {b : Bool} -> Bool
  new Bool {~P, T, F} =>
    let moti       = {b} => P(not_f(b))
    let case_true  = F
    let case_false = T
    (%b)(~moti, case_true, case_false)

// Type of boolean induction
induction : {b : Bool} -> Type
  {~P : {b : Bool} -> Type
  , T : P(true)
  , F : P(false)
  } -> P(b)

// Boolean induction is just `%b`.
induct : {b : Bool} -> induction(b)
  %b

// Boolean example
example
  and(or(true, false), true)

// :::::::::
// :: Nat ::
// :::::::::

// A natural number. Desugars to:
// Nat  : Type             = $ self {~P : {n : Nat} -> Type, S : {n : Nat} -> (P (succ n)), Z : (P zero)} -> (P self)
// succ : {n : Nat} -> Nat = {n, ~P, S, Z} => (S n)
// zero : Nat              = {~P, S, Z} => Z
T Nat
| succ {pred : Nat}
| zero

pred : {|n : Nat} -> Nat
| succ = n.pred
| zero = zero

pred.example
  pred(succ(succ(zero)))

pred_if : {|n : Nat, |b : Bool} -> Nat
| succ | true  = n.pred
       | false = succ(n.pred)
| zero | true  = zero
       | false = zero

// Recursive functions must be boxed (annotated with `:!`). They must also
// provide a "halt" case with `*`, which will be returned in the case the
// function runs out of "gas". That's because Formality is terminating. This is
// NOT a "native" "bounded recursion" feature, instead, it is desugared to
// `rec(TYPE, {r} => func[func <- r], halt)`. Notice that the `rec`, the
// function that repeatedly calls `func` as many times as needed, must be in
// scope. See `rec` below to see how Church nats can be used for that.
// Note: if the halt value isn't any of the function arguments, you can simply
// provide it after the end of the function by writting `* halt_value` there.
double :! {|*n : Nat} -> Nat
| succ = succ(succ(double(n.pred)))
| zero = zero

// Non-recursive functions that use recursive functions must also be boxed.
// They must unbox the recursive functions they use.
double.example :! Nat
  unbox double
  double(succ(zero))

// ::::::::::
// :: List ::
// ::::::::::

T List <A : Type>
| push {head : A, tail : List(A)}
| empty

// The dependent pattern match syntax is still not able to deal with indices,
// so we must use the `case` syntax
head : {~T : Type, default : T, list : List(T)} -> T
  case<List> list
  | push  => head
  | empty => default
  : T

tail : {~T : Type, list : List(T)} -> List(T)
  case<List> list
  | push  => tail
  | empty => empty(~T)
  : List(T)

map :! {~A : Type, fn : !{x : A} -> A, *list : List(!A)} -> List(!A)
  dup fn = fn
  case<List> list
  | push =>
    dup head = head
    let head = #fn(head)
    let tail = map<A>(#fn, tail)
    push<!A>(head, tail)
  | empty =>
    empty<!A>
  : List(!A)
  
map.example
  dup map = map
  let list = empty<!U32>
  let list = push<!U32>(#1, list)
  let list = push<!U32>(#2, list)
  let list = push<!U32>(#3, list)
  # map<U32>(#{x} => |x * 2|, list)

// ::::::::::::
// :: Vector ::
// ::::::::::::

// A vector with a statically known length.
T Vector <A : Type> {len : Nat}
| vpush {~len : Nat, head : A, tail : Vector(A, len)} & succ(len)
| vempty                                              & zero

// A type-safe `head` that *can't* be used on empty vectors.
vhead : {~T : Type, n : Nat, vector : Vector(T, succ(n))} -> T
  case<Vector> vector
  | vpush  => head
  | vempty => 0
  : case<Nat> len
    | succ => T
    | zero => U32
    : Type

vtail : {~T : Type, n : Nat, vector : Vector(T, n)} -> Vector(T, pred(n))
  case<Vector> vector
  | vpush  => tail
  | vempty => vempty(~T)
  : Vector(T, pred(len))

// :::::::::
// :: Rec ::
// :::::::::

// A Rec is a Parigot (erased to Church) of a Nat. It has this name because
// those encodings should be used for recursion, not to store data. The ADT
// syntax still doesn't allow making those datatypes, so I encode manually.

Rec : Type
  $ self {
   ~P : {n : Rec} -> Type
  , C : ! {~n : Rec, i : P(n)} -> P(Rec.call(n))
  , S : ! P(Rec.halt)
  }  -> ! P(self)

Rec.call : {n : Rec} -> Rec
  new Rec {~P, C, S} =>
  dup C = C
  dup S = S
  dup A = (%n)(~P, #C, #S)
  # C(~n, A)

Rec.halt : Rec
  new Rec {~P, C, S} =>
  S

// This "fuels" recursive functions. Here, I use `Rec.256` (defined below),
// which gives us a "bound" of 256 calls per recursive function. This can be
// changed to be a very large number (i.e., 2^64 for example).
rec : {~T : Type, call : !{x : T} -> T, halt : !T} -> !T
  dup call = call
  dup halt = halt
  (%Rec.256)(~{r} => T, #{~n} => call, #halt)

Rec.induction : {n : Rec} -> Type
  {~P : {n : Rec} -> Type
  , C : ! {~n : Rec, i : P(n)} -> P(Rec.call(n))
  , S : ! P(Rec.halt)
  } -> ! P(n)

Rec.induct : {n : Rec} -> Rec.induction(n)
  %n

Rec.double : {n : Rec} -> Rec
  new Rec {~P, call, halt} =>
  dup call = call
  dup halt = halt
  let moti = {n} => P(Rec.double(n))
  let call = # {~n, i} => call(~Rec.call(Rec.double(n)), call(~Rec.double(n), i))
  let halt = # halt
  (%n)(~moti, call, halt)

Rec.256 : Rec
  Rec.double(Rec.double(Rec.double(Rec.double(
  Rec.double(Rec.double(Rec.double(Rec.double(
  Rec.call(Rec.halt)))))))))

// Runtime fusion on repeated not
Rec.example
  let moti = {n}     => Bool
  let call = {~n, x} => not_f(x)
  let halt = true
  (%Rec.256)(~moti, #call, #halt)

// ::::::::::
// :: Main ::
// ::::::::::

main
  vhead
