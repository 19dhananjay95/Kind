type App.GG.Creature { 
  new(
    category: App.GG.Monster
    team: App.GG.Team
    animation: Pair<App.GG.Animation, U64>
    actions: App.GG.Actions
    statuses: App.GG.Creature.Statuses
    hp: I32
    id: Nat
  )
}

//===========================================================
//Creature Management

App.GG.Creature.modify_at(
  mod: App.GG.Creature -> App.GG.Creature
  pos: App.GG.Coord
  grid: App.GG.Grid
): App.GG.Grid
  
  let result = Maybe { 
    get creature = App.GG.Creature.get(pos, grid)
    let mod = App.GG.Tile.update_creature(mod)
    let new_grid = App.GG.Grid.update(pos, mod, grid)
    return new_grid
  }
  result <> grid


App.GG.Creature.get(
  place: App.GG.Coord
  grid: App.GG.Grid
): Maybe<App.GG.Creature>

  let tile = App.GG.Grid.get(place, grid)
  case tile { 
    none:
      none
    some:
      tile.value@creature
  }


//===========================================================
//Status Management

type App.GG.Creature.Statuses {
  new(
    poison: Maybe<App.GG.Creature.Status>
    stun: Maybe<App.GG.Creature.Status>
  )
}

type App.GG.Creature.Status {
  // invulnerable(duration: U64)
  // intangible(duration: U64)
  // poison(duration: U64, damage: I32)
  // root(duration: U64)
  poison(duration: U64, damage: I32)
  stun(category: App.GG.Creature.Status.Stun)
}

App.GG.Creature.Statuses.pure: App.GG.Creature.Statuses
  App.GG.Creature.Statuses.new(none, none)

type App.GG.Creature.Status.Stun {
  flinch
  shock
}

App.GG.Creature.Status.del_from_nat(count: Nat, creature: App.GG.Creature): App.GG.Creature
  let statuses = creature@statuses
  let new_statuses = 
    switch Nat.eql(count) {
    0: statuses@poison <- none
    1: statuses@stun <- none
  }default statuses
  creature@statuses <- new_statuses

App.GG.Creature.Status.add(status: App.GG.Creature.Status, creature: App.GG.Creature): App.GG.Creature
  let statuses = creature@statuses
  let new_statuses = 
    case status {
      poison: statuses@poison <- some(status)
      stun: statuses@stun <- some(status)
    }
  creature@statuses <- new_statuses

App.GG.Creature.Status.get_from_nat(count: Nat, statuses: App.GG.Creature.Statuses): Maybe<Maybe<App.GG.Creature.Status>>
  switch Nat.eql(count) {
    0: some(statuses@poison)
    1: some(statuses@stun)
  }default none

App.GG.Creature.Status.update_grid(coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
  App.GG.Creature.Status.update_grid.go(0, coord, local)

App.GG.Creature.Status.update_grid.go(count: Nat, coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
let grid = local@grid
  let new_local = 
    Maybe {
      get creature = App.GG.Creature.get(coord, grid)
      let statuses = creature@statuses
      get status = App.GG.Creature.Status.get_from_nat(count, statuses)
      let new_local = 
        without status: local
        case status {
          poison: App.GG.Creature.Status.update_poison(status, coord, local)
          stun: App.GG.Creature.Status.update_stun(status, coord, local)
        }default local
      let new_local = App.GG.Creature.Status.update_grid.go(count +1, coord, new_local)
      return new_local
    } <> local
  new_local

App.GG.Creature.Status.update_poison(status: App.GG.Creature.Status, coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
  case status {
    poison: 
      log(U64.show(status.duration))
      let grid = local@grid
      let new_grid = 
        if status.duration =? 0 then
          let new_creature = App.GG.Creature.Status.del_from_nat(0)
          let new_grid     = App.GG.Creature.modify_at(new_creature, coord, grid)
          new_grid
        else
          let new_creature = App.GG.Creature.Status.add(App.GG.Creature.Status.poison(status.duration - 1, status.damage))
          let new_grid = App.GG.Creature.modify_at(new_creature, coord, grid)
          new_grid
      let new_local = local@grid <- new_grid
      if (status.duration % 10) =? 0 then 
        let eff = App.GG.Effect.creature.change_hp_at(status.damage, coord, false)
        let result = eff(coord, App.GG.Effect.Origin.creature, new_local)
        case result {err: new_local, new: result.local}
      else
        new_local

  }default local

App.GG.Creature.Status.update_stun(status: App.GG.Creature.Status, coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
  case status {
    stun: 
      let grid = local@grid
      let new_creature = App.GG.Creature.Status.add(App.GG.Creature.Status.stun(status.category))
      let new_grid     = App.GG.Creature.modify_at(new_creature, coord, grid)
      let new_local    = local@grid <- new_grid
      new_local
  }default local

//===========================================================

App.GG.Creature.sub_folder(quantity: Nat, creature: App.GG.Creature): App.GG.Creature
  case creature@category as monster {
    minion: creature
    slime:
      creature@category <- App.GG.Monster.slime(monster.data, monster.attributes, monster.charge, monster.hand, List.drop!(quantity, monster.folder), monster.energy)
  }

App.GG.Creature.shuffle_folder(seed: Nat, creature: App.GG.Creature): App.GG.Creature
  case creature@category as monster {
    minion: creature
    slime:
      let new_folder = App.GG.Chips.shuffle(seed, monster.folder)
      creature@category <- App.GG.Monster.slime(monster.data, monster.attributes, monster.charge, monster.hand, new_folder, monster.energy)
  }

App.GG.Creature.add_chip(chip: App.GG.Chip, creature: App.GG.Creature): App.GG.Creature
  case creature@category as monster {
    minion: creature
    slime:
      let category = App.GG.Monster.slime(monster.data, monster.attributes, monster.charge, chip & monster.hand, monster.folder, monster.energy)
      creature@category <- category
  }

App.GG.Creature.delete(coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  let tile = App.GG.Grid.get(coord, grid)
  without tile: grid
  let new_tile = tile@creature <- none
  App.GG.Grid.set(coord, new_tile, grid)

App.GG.Creature.create_slime(slime: App.GG.Slime, grid: App.GG.Grid): App.GG.Creature
  let team = App.GG.Team.blue
  let animation = {App.GG.Animation.idle, 0#64}
  let actions = App.GG.Actions.new(none, none, false)
  let status = App.GG.Creature.Statuses.pure
  let id = App.GG.Grid.next_id(grid)
  let body = slime@body
  let data = slime
  let charge = none
  let hand = []
  let folder = App.GG.Body.to_folder(body)
  let attributes = App.GG.Attributes.add(App.GG.Attributes.base, App.GG.Body.attributes(body))
  let hp = attributes@hp * 10
  let energy = 0 :: I32
  let monster = App.GG.Monster.slime(data, attributes, none, hand, folder, energy)
  App.GG.Creature.new(monster, team, animation, actions, status, hp, id)

App.GG.Creature.create_minion(minion: App.GG.Minion, grid: App.GG.Grid): App.GG.Creature
  let team = App.GG.Team.red
  let animation = {App.GG.Animation.idle, 0#64}
  let actions = App.GG.Actions.new(none, none, false)
  let status = App.GG.Creature.Statuses.pure
  let id = App.GG.Grid.next_id(grid)
  let AI = {"seen": +0#32, "unseen": +0#32}
  let hp = minion@hp
  let monster = App.GG.Monster.minion(minion, AI)
  App.GG.Creature.new(monster, team, animation, actions, status, hp, id)

App.GG.Creature.place(creature: App.GG.Creature, coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  let f = 
    (tile: App.GG.Tile)
    tile@creature <- some(creature)
  App.GG.Grid.update(coord, f, grid)

App.GG.Creature.dmg_with_attribute(creature: App.GG.Creature, dmg: I32): I32
  let attributes = App.GG.Attributes.get(creature)
  without attributes: dmg
  let destruction = attributes@damage
  (dmg * destruction) / 25

App.GG.Creature.basic_attack_dmg(creature: App.GG.Creature): I32
  let attributes = App.GG.Attributes.get(creature)
  without attributes: 0 :: I32
  let base_dmg  = 2 :: I32
  let extra_dmg = (attributes@damage - 25) / 5
  let total_dmg = base_dmg + extra_dmg
  I32.neg(total_dmg)

App.GG.Creature.max_hp_percentage(creature: App.GG.Creature): I32
  let max_hp = App.GG.Monster.get_max_hp(creature@category)
  let actual_hp = creature@hp
  actual_hp/max_hp


App.GG.Attributes.get(creature: App.GG.Creature): Maybe<App.GG.Attributes>
  case creature@category as monster {
    minion: none
    slime:
      some(monster.attributes)
  }

// ============================================================================
// Grid Update functions

// If creature hasn't acted, update its actions, run its effects and update animation to next frame
App.GG.Creature.run(coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
  if App.GG.Creature.has_acted(coord, local) then 
    local
  else
    let new_local = App.GG.Creature.update_charge()
    let new_local = App.GG.Creature.run_ai(coord, local)
    let new_local = App.GG.Creature.update_actions(coord, new_local)
    let new_local = App.GG.Creature.update_animation(coord, new_local)
    let new_local = App.GG.Actions.run(coord, new_local)
    new_local

// Checks if creature has acted in this frame
App.GG.Creature.has_acted(coord: App.GG.Coord, local: App.GG.State.local): Bool
  let creature = App.GG.Creature.get(coord, local@grid)
  without creature: false
  creature@actions@has_acted

App.GG.Creature.reset_actions.aux(creature: App.GG.Creature): App.GG.Creature
  let actions = creature@actions
  let new_actions = actions@has_acted <- false
  creature@actions <- new_actions

// Updates animation to its next frame
App.GG.Creature.update_animation(coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
  let mod = (creature: App.GG.Creature) creature@animation <- {creature@animation@fst, creature@animation@snd + 1}
  let new_grid = App.GG.Creature.modify_at(mod, coord, local@grid)
  let new_local = local@grid <- new_grid
  new_local

// If current action is "none", moves next action to its place
App.GG.Creature.update_actions(coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
  let grid = local@grid
  let new_grid = App.GG.Creature.modify_at(App.GG.Creature.update_actions.aux, coord, grid)
  let new_local = local@grid <- new_grid
  new_local

App.GG.Creature.update_actions.aux(creature: App.GG.Creature): App.GG.Creature
  let actions = creature@actions
  let next_action = actions@next
  let curr_action  = actions@current
  without curr_action: 
    without next_action: creature
    let new_actions = actions@current <- some(next_action)
    let new_actions = new_actions@next <- none
    let new_creature = creature@actions <- new_actions
    new_creature
  creature

// Changes creature's has_acted to false
App.GG.Creature.reset_actions(coord: App.GG.Coord, grid: App.GG.Grid): App.GG.Grid
  App.GG.Creature.modify_at(App.GG.Creature.reset_actions.aux, coord, grid)

App.GG.Creature.run_ai(coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
  Maybe {
    let grid = local@grid
    get minion = App.GG.Minion.get(coord, grid)
    let result = minion@effect(coord, App.GG.Effect.Origin.creature, local)
    let new_local = case result {err: local, new: result.local}
    return new_local
  } <> local

App.GG.Creature.update_charge(coord: App.GG.Coord, local: App.GG.State.local): App.GG.State.local
  let grid = local@grid
  let mod = (creature: App.GG.Creature)
    case creature@category as monster {
      minion: creature
      slime:
        let body = monster.data@body
        let hull_data = App.GG.Body.Hull.Form.data(body@hull@form) 
        let extra_charge = hull_data@frame_charge
        let new_charge = Maybe.map!!(U64.min(960) Maybe.map!!(U64.add(extra_charge), monster.charge))
        let monster = App.GG.Monster.slime(monster.data, monster.attributes, new_charge, monster.hand, monster.folder, monster.energy)
        creature@category <- monster
    }
  let new_grid = App.GG.Creature.modify_at(mod, coord, grid)
  let new_local = local@grid <- new_grid
  new_local

// ============================================================================
